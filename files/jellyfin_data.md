# https://jellyfin.org/docs/

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/#__docusaurus_skipToContent_fallback

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/

Skip to main content
The Free Software Media System

Jellyfin is the volunteer-built media solution that puts you in control of your media. Stream to any device from your own server, with no strings attached. Your media, your server, your way.

See it in Action
Download Now

Note: We do not run servers for users.

What is Jellyfin?

Jellyfin enables you to collect, manage, and stream your media. Run the Jellyfin server on your system and gain access to the leading free-software entertainment system, bells and whistles included.

Movies

Enjoy your entire movie collection, easy to browse and with beautiful artwork.

Shows

Watch your favorite shows, automatically sorted by season and ready to binge.

Music

Listen to music, your artists and your playlists, at home or on the go.

Live TV & DVR

Watch TV and set automatic recordings to expand your library.

Books

Read your books, comics, and magazines.

Photos

Organize your photos and share memories with your friends and family.

SyncPlay

Sharing a movie night remotely has never been so easy.

Your media, wherever you are

With a large array of official and third-party clients, Jellyfin is available on most popular platforms. Your media is ready to follow you, wherever you go.

Web
Desktop
Android
Apple
Amazon
Roku
Kodi
And more
Find a Client
See Jellyfin in Action
The home screen highlights your media library. The sections can be customized to each user’s individual preferences.
The library screen lists your media with options to filter and sort so you can find exactly what you are looking for.
The details screen displays all the information about your media.
The playback screen gives you the controls you need to play or cast your media or start a SyncPlay session with friends or family.
Try the Demo
Free Software

Jellyfin is Free Software, licensed under the GNU GPL. You can use it, study it, modify it, build it, and distribute it for free, as long as your changes are licensed the same way.

Community Built

The project relies entirely on contributions from volunteers. Want to help out? There’s lots of ways to do so, and you don’t even have to code! See our contribution guide for more details.

No Fees

The Jellyfin server and official clients are free to download, now and always. There are no costs, hidden or otherwise, to use Jellyfin, either for yourself, for your friends, or for your company. All our incidental costs are paid through donations from users like you.

Privacy Focused

Jellyfin has no tracking, phone-home, or central servers collecting your data. We believe in keeping our software open and transparent. We’re also not in the media business, so the only media you see is your own.

Get Started Now

Check out our Getting Started guide to download and set up your server today.

Download Jellyfin
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts

Skip to main content
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Jellyfin 10.10.0
October 26, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.10.0!

This major release brings several new features, improvements, and bugfixes to improve your Jellyfin experience. With our faster release cadence between 10.9.0 and 10.10.0, this release should be far less daunting, so please read on for a quick peek at what's new and some important-to-know breaking changes!

You may upgrade your Jellyfin instances at any time now. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version. As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Happy watching!

- Joshua

Tags:release
Read more
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

Tags:releasetesting
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Jellyfin 10.9.0
May 11, 2024 · 9 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.9.0!

This major release brings many new features, improvements, and bugfixes to improve your Jellyfin experience.

You may upgrade your Jellyfin instances at any time now, however please read on for a complete detailing of what's new and changed, including some very important release notes. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version.

Happy watching!

- Joshua

Tags:release
Read more
Testing 10.9.0
March 27, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now in our feature freeze window for the 10.9.0 release! That means that from now until the release, we'll be focusing only on merging bugfixes and other improvements, while all features will be on hold until the release is finalized.

That also means it's time to start testing. As outlined in our last blog post, we're doing things a bit differently this release, so this post will provide the steps one would need to take to help us test the new release.

If you want to help out, please read on!

- Joshua

Tags:release
Read more
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Tags:releaseinfrastructure
Read more
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/contribute

Skip to main content
How to Contribute

Jellyfin is a community project run by volunteers. We're always looking for additional help.

Find a way to contribute

If you are interested in helping the Jellyfin project, there are a few different ways to contribute depending on your skills and availability. Of course, simply using Jellyfin, finding issues, and reporting them, are a major help to our project, even if none of these apply to you!

Before contributing, please read over our Community Standards and Contributing Guide.

CodeTranslationsOther
Meet the people that bring you Jellyfin
Sponsors
DigitalOcean
JetBrains
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/contact

Skip to main content
Contact
Chat
Matrix
We primarily use Element to access the Matrix network. Find all the official rooms in the Jellyfin Space!
General Rooms
#jellyfin
#jellyfin-announce
#jellyfin-troubleshooting
#jellyfin-offtopic
#jellyfin-translate
Development Rooms
#jellyfin-dev
#jellyfin-dev-client
#jellyfin-dev-android
#jellyfin-dev-ios
#jellyfin-vue
#jellyfin-dev-roku
#jellyfin-dev-python
#jellyfin-ui-ux
#jellyfin-hwa-tool
Join the Jellyfin Space
Discord
The Jellyfin Discord server is bridged to the official Matrix rooms for convenience.
NOTE: Matrix is the preferred chat platform. Discord messages may be missed or delayed due to bridge instability.
Join the Discord Server
Other
Social
Forum
Join us on our Forum for release announcements, troubleshooting, and development discussions.
Jellyfin Forum
Mastodon
Follow us on Mastodon for release announcements and more, just like our Twitter account.
@jellyfin@mastodon.online
Twitter
Follow us on Twitter for release announcements and other updates, along with general musings.
@jellyfin
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/quick-start/

Skip to main content
Quick Start
Quick Start

Install Jellyfin on your system with the installation method for your platform.

Edit the web configuration and adjust the options to fit your desired privacy level.

Our defaults sacrifice some absolute self-hosting for often requested features.
If this is concerning, please review the documentation and edit accordingly.

Browse to http://SERVER_IP:8096 to access the included web client.

Follow the initial setup wizard.

Libraries and users can always be added later from the dashboard.
Remember the username and password so you can login after the setup.

Secure the server with a method of your choice.

Create an SSL certificate and add it on the Networking page.
Put your server behind a reverse proxy.
Only allow local connections and refrain from forwarding any ports.

Enjoy your media!

Edit this page
Previous
Introduction
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/getting-help

Skip to main content
Getting Help
Getting Help

If you are having trouble using or configuring Jellyfin, there are several ways to get help. Please ensure you read our Community Standards before interacting with the Jellyfin community. See the Contact page for a comprehensive list of places to find community discussion and support.

Edit this page
Previous
Windows
Next
FAQ
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/

Skip to main content
Installation
Installation

The Jellyfin project and its contributors offer a number of pre-built binary packages to assist in getting Jellyfin up and running quickly on multiple systems.

CAUTION

FreeBSD and its derivatives, such as TrueNAS CORE, are NOT supported by Jellyfin due to .NET officially not being compatible with these platforms.

Even though there are builds available online for these platforms, they are unofficial and from a separate project. If you do encounter issues on these platforms, please ask for support in their respective support channels first.

TrueNAS SCALE is based on Linux and therefore officially supported. Please install the Jellyfin app from its app repository. This app is not officially maintained by the Jellyfin team, therefore please use the TrueNAS support channels for help first.

For info on selecting hardware for a Jellyfin server, please refer to the Hardware Selection Guide

📄️ Container

Install as a container using Docker, Podman and others.

📄️ Linux

Install on Linux.

📄️ Windows

Install on Windows.

📄️ TrueNAS SCALE

Install on TrueNAS SCALE.

📄️ Synology

Install on Synology NAS.

📄️ macOS

Install on macOS.

📄️ Building from source

Compile and run Jellyfin yourself.

Edit this page
Previous
FAQ
Next
Container
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/#

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/style-guides/

Skip to main content
Style Guides
Style Guides

This section documents the code style used for the different languages used by Jellyfin.

If the language you are looking for does not have a style guide yet, respect the style of the surrounding code in the files you are editing.

Edit this page
Previous
Source Tree
Next
JavaScript
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/#getting-started

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation

Skip to main content
Installation
Installation

The Jellyfin project and its contributors offer a number of pre-built binary packages to assist in getting Jellyfin up and running quickly on multiple systems.

CAUTION

FreeBSD and its derivatives, such as TrueNAS CORE, are NOT supported by Jellyfin due to .NET officially not being compatible with these platforms.

Even though there are builds available online for these platforms, they are unofficial and from a separate project. If you do encounter issues on these platforms, please ask for support in their respective support channels first.

TrueNAS SCALE is based on Linux and therefore officially supported. Please install the Jellyfin app from its app repository. This app is not officially maintained by the Jellyfin team, therefore please use the TrueNAS support channels for help first.

For info on selecting hardware for a Jellyfin server, please refer to the Hardware Selection Guide

📄️ Container

Install as a container using Docker, Podman and others.

📄️ Linux

Install on Linux.

📄️ Windows

Install on Windows.

📄️ TrueNAS SCALE

Install on TrueNAS SCALE.

📄️ Synology

Install on Synology NAS.

📄️ macOS

Install on macOS.

📄️ Building from source

Compile and run Jellyfin yourself.

Edit this page
Previous
FAQ
Next
Container
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#arch-linux

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#debian

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#ubuntu

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#fedora

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#centos

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container#docker

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container#kubernetes

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/windows

Skip to main content
InstallationWindows
On this page
Windows

Windows installers and builds in ZIP archive format are available here.

CAUTION

If you installed a version prior to 10.4.0 using a PowerShell script, you will need to manually remove the service using the command nssm remove Jellyfin and uninstall the server by remove all the files manually. Also one might need to move the data files to the correct location, or point the installer at the old location.

CAUTION

The Basic Install is the recommended way to run the Jellyfin Server. Using the Advanced/Service mode may experience FFmpeg hardware acceleration issues and is only for advanced users.

Install using installer​

Install

Download the latest version.
Run the installer.
(Optional) When installing as a service (not recommended), pick the service account type.
If everything was completed successfully, Jellyfin is now running.
Open your browser at http://your_local_IP_address:8096 to finish setting up Jellyfin.

Update

Download the latest version.
Close or Stop Jellyfin if it is running.
Run the installer.
If everything was completed successfully, the new version is installed.

Uninstall

Go to Add or remove programs in Windows.
Search for Jellyfin.
Click Uninstall.
Install manually (portable)​

Install

Download and extract the latest version.

Create a folder jellyfin at your preferred install location.

Copy the extracted folder into the jellyfin folder and rename it to system.

Create jellyfin.bat within your jellyfin folder containing:

To use the default library/data location at %localappdata%:
<--Your install path-->\jellyfin\system\jellyfin.exe

To use a custom library/data location (Path after the -d parameter):
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data

To use a custom library/data location (Path after the -d parameter) and disable the auto-start of the webapp:
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data -noautorunwebapp


Run

jellyfin.bat


Open your browser at http://<--Server-IP-->:8096.

Update

Stop Jellyfin
Rename the Jellyfin system folder to system-bak
Download and extract the latest Jellyfin version
Copy the extracted folder into the jellyfin folder and rename it to system
Run jellyfin.bat to start the server again

Rollback

Stop Jellyfin.
Delete the system folder.
Rename system-bak to system.
Run jellyfin.bat to start the server again.
Edit this page
Previous
Linux
Next
TrueNAS SCALE
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux#linux-generic-amd64

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/#administrator-documentation

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/quick-start

Skip to main content
Quick Start
Quick Start

Install Jellyfin on your system with the installation method for your platform.

Edit the web configuration and adjust the options to fit your desired privacy level.

Our defaults sacrifice some absolute self-hosting for often requested features.
If this is concerning, please review the documentation and edit accordingly.

Browse to http://SERVER_IP:8096 to access the included web client.

Follow the initial setup wizard.

Libraries and users can always be added later from the dashboard.
Remember the username and password so you can login after the setup.

Secure the server with a method of your choice.

Create an SSL certificate and add it on the Networking page.
Put your server behind a reverse proxy.
Only allow local connections and refrain from forwarding any ports.

Enjoy your media!

Edit this page
Previous
Introduction
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/monitoring

Skip to main content
NetworkingMonitoring
On this page
Monitoring
Monitoring​

Jellyfin has two monitoring and metrics endpoints built-in: a basic health check endpoint and a Prometheus-compatible metrics endpoint.

Health check endpoint​

Jellyfin exposes the /health endpoint designated for checking the status of the underlying service. Currently this will verify HTTP and database connectivity and return a 200 OK response if successful. You can see this for yourself by using curl:

curl -i http://myserver:8096/health


The -i option tells curl to also print the HTTP response code and headers.

Prometheus metrics​

Jellyfin can make Prometheus metrics available at /metrics, but this is turned off by default to avoid unintentionally leaking this information on the public internet. To enable it, you will need to edit /etc/jellyfin/system.xml and change this line from false to true:

<EnableMetrics>false</EnableMetrics>


If you have a reverse proxy configured, you can configure it to block access to the /metrics endpoint except for your internal network.

Edit this page
Previous
Let's Encrypt
Next
Nginx
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/hardware-acceleration

Skip to main content
AdministrationHardware Acceleration
On this page
Hardware Acceleration

The Jellyfin server can offload on the fly video transcoding by utilizing an integrated or discrete graphics card (GPU) suitable to accelerate this workloads very efficiently without straining your CPU.

Supported Acceleration Methods​

The Jellyfin server uses a modified version of FFmpeg as its transcoder, namely jellyfin-ffmpeg. It enables the Jellyfin server to access the fixed-function video codecs, video processors and GPGPU computing interfaces provided by vendor of the installed GPU and the operating system.

The supported and validated video hardware acceleration (HWA) methods are:

Intel Quick Sync Video (QSV)

NVIDIA NVDEC/NVENC (NVENC)

AMD Advanced Media Framework (AMF)

Intel/AMD Video Acceleration API (VA-API, Linux only)

Apple Video Toolbox (macOS only)

Rockchip RKMPP (Linux only)

Full & Partial Acceleration​

The transcoding pipeline usually has multiple stages, which can be simplified to:

Video Decoding

Video Deinterlacing (optional)

Video Scaling & Format conversion (optional)

Video HDR/DV Tone-mapping (optional)

Video Subtitle burn-in (optional)

Video Encoding

Zero-copy in above stages

NOTE

Some of these stages cannot be GPU accelerated due to software, hardware or driver limitations.

Partial acceleration may result in higher CPU usage and lower transcoding speed.

Jellyfin supports full acceleration for:

Mainstream Intel and Nvidia GPUs on Windows and Linux
AMD Polaris and newer GPUs on Linux via VA-API and Vulkan interop
Older AMD GPUs on Windows
Rockchip VPU of RK3588/3588S
Intel and Apple Silicon on macOS 12 and above

Using jellyfin-ffmpeg with Jellyfin is highly recommended, which has a -Jellyfin suffix in the version string.

$ /usr/lib/jellyfin-ffmpeg/ffmpeg

ffmpeg version 6.0.1-Jellyfin Copyright (c) 2000-2023 the FFmpeg developers
  built with gcc 12.2.0 (crosstool-NG 1.25.0.90_cf9beb1)
...

CAUTION

Using FFmpeg binaries downloaded from somewhere else will result in partial acceleration.

Jellyfin-ffmpeg usually ships with our deb package, official Docker images and Windows installers.

The only exception is when using a portable installation or an unsupported distro, then it's required to manually download and set it in Jellyfin.

Configure & Verify Hardware Acceleration​

There are some preparations that need to be done before enabling hardware acceleration.

The specific configuration steps may vary between GPU vendors, installation methods, and operating systems.

On Linux you can check available GPU using the lspci command:

lspci -nn | grep -Ei "3d|display|vga"


Or using lshw:

lshw -C display

Intel QSV & VA-API​

Click Intel GPU.

AMD AMF & VA-API​

Click AMD GPU.

NVIDIA NVENC​

Click NVIDIA GPU.

Apple VideoToolbox​

Click Apple Mac.

Rockchip RKMPP​

Click Rockchip VPU.

Enable Hardware Acceleration​

Hardware acceleration options can be found in the Admin Dashboard under the Transcoding section of the Playback tab.

Select a valid hardware acceleration method from the drop-down menu and a device if applicable. Supported codecs need to be indicated by checking the boxes in Enable hardware decoding for and Hardware encoding options.

The hardware acceleration is available immediately for media playback. No server restart is required.

Remote Hardware Acceleration​

If your Jellyfin server does not support hardware acceleration, but you have another machine that does, you can leverage rffmpeg to delegate the transcoding to another machine.

NOTE

Currently Linux-only and requires SSH between the machines, as well as shared storage for media and the Jellyfin data directory.

Hardware Accelerated Tone-mapping​

Jellyfin supports hardware accelerated tone-mapping of HDR10 and HLG to SDR.

Dolby Vision (P5 & P8) to SDR tone-mapping is supported in Jellyfin 10.8 and requires jellyfin-ffmpeg 5.0.1-5 or newer.

NOTE

Intel VPP HDR10 tone-mapping is supported on Intel QSV and VA-API on Linux.

VPP is prefered if both tone-mapping options are enabled.

Rockchip RKMPP currently only support HDR10 and HLG tone-mapping.

Tips For Hardware Acceleration​

Avoid H.264 / AVC 10-bit videos

TIP

The hardware decoding of H.264 / AVC 10-bit (High 10 profile) video is not supported by any Intel, NVIDIA and AMD GPU. It is only supported by Apple Silicon and Rockchip. Jellyfin will fall back to software decoding for it when there is no hardware decoder available. Consider upgrading such video to H.265 / HEVC 10-bit (Main 10 profile).

iGPU / APU Prefer dual-channel memory

TIP

Integrated GPUs take up a portion of system memory as their video memory, which means using dual-channel memory can double the video memory bandwidth. This can be useful while computing intensive workloads such as hardware HDR/DV tone-mapping.

Use SSD or RamDisk for caching

TIP

On modern GPUs the peak throughput of video transcoding can be limited by the I/O speed of your hard drives. In this case, an SSD or RamDisk can be used for caching the transcoded temporary video segments.

Tune encoder presets to trade off quality for speed

TIP

Hardware encoder presets can greatly affect encoding speed. You can lower this preset in the Jellyfin dashboard to sacrifice encoding quality to maximize speed, or raise the preset to optimize encoding quality on an overkill GPU.

Raspberry Pi Hardware Acceleration Support Deprecation​

Jellyfin previously supported hardware acceleration on Raspberry Pi via OpenMAX OMX in Jellyfin 10.8, with partial support for Raspberry Pi via V4L2 in 10.9. However, the support never reached the level of maturity seen with other acceleration methods. Many operations fell back to the already underperforming CPU, due to the lacking of full hardware acceleration. The situation worsened with the release of the latest generation of Raspberry Pi 5, which lacks hardware encoders entirely, rendering further development of hardware acceleration on this platform impractical.

As a result, we have to deprecate V4L2 support for Raspberry Pi, unfortunately. While it may continue to work for now, future updates to the Linux kernel or FFmpeg could break this support, and it's unlikely that we'll address any resulting issues. This decision may be reversed if future Raspberry Pi models reintroduce hardware encoders.

Edit this page
Previous
Configuration
Next
AMD GPU
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/#contributing-to-jellyfin

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/issues#reporting-bugs

Skip to main content
ContributingReporting Issues
On this page
Reporting Issues

This page discusses how to open issues, including the policies and procedures of the Jellyfin project around handling issues.

Issues should only detail software bug reports.

All other discussions, including initial troubleshooting, should be directed towards our help channels.

Requesting Features​

Please note that feature and enhancement requests should be directed towards our Fider instance for tracking, voting, and reporting. Please keep all feature requests to this page and not GitHub issues.

Searching and Voting​

Before opening an issue, please search the existing issues to see if a similar problem or feature request has been reported. Duplicate issues clutter the repository and should be avoided.

If you do find an issue that matches, or closely matches, your issue, please make use of the 👍 reaction to confirm the issue also affects you or that you support the feature request. If you wish, add a comment as well describing your version of the issue or feature use case.

If the existing issue is closed, please read through it to see if the accepted workaround(s) apply to your case. If not, leave a comment and the issue will be reopened. Note that, since PRs go into dev first but releases are built from master, an issue's fix won't be immediately available in the official sources, but will be included in the next release.

Opening an Issue​

Once you're ready to open an issue, please see this page!

Reporting Bugs​

When writing a bug issue, please ensure you capture as much relevant detail as possible - this is very important to assist in troubleshooting and triaging/investigating the issue. Some useful elements include:

How you installed Jellyfin (upgrade or fresh install)

What platform and operating system you are using (Debian, Arch, Docker, etc.)

What you were doing that caused the issue to appear

Any relevant log output

Any non-standard configurations you use

Bugs should be tagged with [bug] at the beginning of their title. This will later be removed by the Jellyfin team when assigning labels. To assist in triaging, if you know which other label(s) should be applied to your issue, please add them after the [bug] label.

Bugs should be reproduceable. That is, you should be able to have determined through troubleshooting how to replicate the issue. While one-time bugs should not be ignored, if they're difficult or impossible to reproduce, it's likely very hard to fix them. Please attempt to reproduce the bug before filing the issue and include the smallest test case you can to demonstrate it.

If you ever need assistance for troubleshooting or opening an issue, please contact the community and we'll try to help you out!

Issue Labels​

Jellyfin features a number of issue labels to assist in triaging and managing issues. Users cannot assign these themselves due to GitHub's permissions, but they will be added by a team member during triaging.

Categories​

These labels are broad categories for which part of the codebase is affected.

backend: An issue that mainly relates to the server backend code.
build: An issue that mainly relates to the build process.
Criticality​

These labels help determine how critical an issue is.

regression: An issue in need of immediate attention due to a regression from the last build.
bug: A bug in the code that affects normal usage.
Management​

These labels help assist in managing the project and direction.

good first issue: Something that should be very straightforward to do and is a great place to get started.
help wanted: An issue that currently has no clear expert within the project and could use outside assistance.
roadmap: A meta-issue related to the future roadmap of the project.
investigation: An investigation-type issue into the codebase.
Pull Requests​

These labels apply only to pull requests for administrative purposes.

requires testing: A PR that has not been tested in a live environment yet. Any major backend-affecting PRs should be tested before being merged to avoid regressions.
Edit this page
Previous
Development
Next
Releases
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/issues#requesting-features

Skip to main content
ContributingReporting Issues
On this page
Reporting Issues

This page discusses how to open issues, including the policies and procedures of the Jellyfin project around handling issues.

Issues should only detail software bug reports.

All other discussions, including initial troubleshooting, should be directed towards our help channels.

Requesting Features​

Please note that feature and enhancement requests should be directed towards our Fider instance for tracking, voting, and reporting. Please keep all feature requests to this page and not GitHub issues.

Searching and Voting​

Before opening an issue, please search the existing issues to see if a similar problem or feature request has been reported. Duplicate issues clutter the repository and should be avoided.

If you do find an issue that matches, or closely matches, your issue, please make use of the 👍 reaction to confirm the issue also affects you or that you support the feature request. If you wish, add a comment as well describing your version of the issue or feature use case.

If the existing issue is closed, please read through it to see if the accepted workaround(s) apply to your case. If not, leave a comment and the issue will be reopened. Note that, since PRs go into dev first but releases are built from master, an issue's fix won't be immediately available in the official sources, but will be included in the next release.

Opening an Issue​

Once you're ready to open an issue, please see this page!

Reporting Bugs​

When writing a bug issue, please ensure you capture as much relevant detail as possible - this is very important to assist in troubleshooting and triaging/investigating the issue. Some useful elements include:

How you installed Jellyfin (upgrade or fresh install)

What platform and operating system you are using (Debian, Arch, Docker, etc.)

What you were doing that caused the issue to appear

Any relevant log output

Any non-standard configurations you use

Bugs should be tagged with [bug] at the beginning of their title. This will later be removed by the Jellyfin team when assigning labels. To assist in triaging, if you know which other label(s) should be applied to your issue, please add them after the [bug] label.

Bugs should be reproduceable. That is, you should be able to have determined through troubleshooting how to replicate the issue. While one-time bugs should not be ignored, if they're difficult or impossible to reproduce, it's likely very hard to fix them. Please attempt to reproduce the bug before filing the issue and include the smallest test case you can to demonstrate it.

If you ever need assistance for troubleshooting or opening an issue, please contact the community and we'll try to help you out!

Issue Labels​

Jellyfin features a number of issue labels to assist in triaging and managing issues. Users cannot assign these themselves due to GitHub's permissions, but they will be added by a team member during triaging.

Categories​

These labels are broad categories for which part of the codebase is affected.

backend: An issue that mainly relates to the server backend code.
build: An issue that mainly relates to the build process.
Criticality​

These labels help determine how critical an issue is.

regression: An issue in need of immediate attention due to a regression from the last build.
bug: A bug in the code that affects normal usage.
Management​

These labels help assist in managing the project and direction.

good first issue: Something that should be very straightforward to do and is a great place to get started.
help wanted: An issue that currently has no clear expert within the project and could use outside assistance.
roadmap: A meta-issue related to the future roadmap of the project.
investigation: An investigation-type issue into the codebase.
Pull Requests​

These labels apply only to pull requests for administrative purposes.

requires testing: A PR that has not been tested in a live environment yet. Any major backend-affecting PRs should be tested before being merged to avoid regressions.
Edit this page
Previous
Development
Next
Releases
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs

Skip to main content
Introduction
On this page
Welcome to the Jellyfin Documentation




Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

You can find a list of all available clients here. For more information please see our about page or the FAQ. If you are looking for help, check out this page for all the different communication channels we use.

Note: Jellyfin is a fast-moving project that is in its early stages, and this documentation as well as the code may change frequently. Please check back often and do not hesitate to contact us via our Matrix channels or Forum!

Getting Started​

Want to get starting using Jellyfin right now? Check out the pages below for how to install Jellyfin on your machine.

Arch
Debian
Ubuntu
Fedora
CentOS
Docker
Kubernetes
Windows
MacOS
Generic Linux

Alternatively, Jellyfin may be built directly from the source code.

Administrator Documentation​

Want to know more about administering a Jellyfin server? Check out these pages!

Quick-Start Guide: What to do after you have installed Jellyfin to get it up and running.
Migrating: How to migrate Jellyfin.
Backup and Restore: How to back up or restore your Jellyfin metadata and configuration.
Plugins: How to install and manage plugins.
Networking: Networking settings and troubleshooting.
Monitoring: Integration with external monitoring software.
Hardware Acceleration: Improve transcoding performance on supported hardware.
Contributing to Jellyfin​

Want to help out? Check out the pages below for how to contribute.

Contribution Guide: General information on contributing to Jellyfin.
Plugin Guide: Documentation and resources to get started writing a plugin to extend Jellyfin functionality.
Reporting Bugs: How to use our issue tracker on GitHub to report bugs.
Requesting Features: How to use our issue tracker on GitHub to request new features or enhancements.
Edit this page
Next
Quick Start
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/#__docusaurus_skipToContent_fallback

Skip to main content
The Free Software Media System

Jellyfin is the volunteer-built media solution that puts you in control of your media. Stream to any device from your own server, with no strings attached. Your media, your server, your way.

See it in Action
Download Now

Note: We do not run servers for users.

What is Jellyfin?

Jellyfin enables you to collect, manage, and stream your media. Run the Jellyfin server on your system and gain access to the leading free-software entertainment system, bells and whistles included.

Movies

Enjoy your entire movie collection, easy to browse and with beautiful artwork.

Shows

Watch your favorite shows, automatically sorted by season and ready to binge.

Music

Listen to music, your artists and your playlists, at home or on the go.

Live TV & DVR

Watch TV and set automatic recordings to expand your library.

Books

Read your books, comics, and magazines.

Photos

Organize your photos and share memories with your friends and family.

SyncPlay

Sharing a movie night remotely has never been so easy.

Your media, wherever you are

With a large array of official and third-party clients, Jellyfin is available on most popular platforms. Your media is ready to follow you, wherever you go.

Web
Desktop
Android
Apple
Amazon
Roku
Kodi
And more
Find a Client
See Jellyfin in Action
The home screen highlights your media library. The sections can be customized to each user’s individual preferences.
The library screen lists your media with options to filter and sort so you can find exactly what you are looking for.
The details screen displays all the information about your media.
The playback screen gives you the controls you need to play or cast your media or start a SyncPlay session with friends or family.
Try the Demo
Free Software

Jellyfin is Free Software, licensed under the GNU GPL. You can use it, study it, modify it, build it, and distribute it for free, as long as your changes are licensed the same way.

Community Built

The project relies entirely on contributions from volunteers. Want to help out? There’s lots of ways to do so, and you don’t even have to code! See our contribution guide for more details.

No Fees

The Jellyfin server and official clients are free to download, now and always. There are no costs, hidden or otherwise, to use Jellyfin, either for yourself, for your friends, or for your company. All our incidental costs are paid through donations from users like you.

Privacy Focused

Jellyfin has no tracking, phone-home, or central servers collecting your data. We believe in keeping our software open and transparent. We’re also not in the media business, so the only media you see is your own.

Get Started Now

Check out our Getting Started guide to download and set up your server today.

Download Jellyfin
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/server

Skip to main content
Downloads
Clients
Server
Full Repository
Linux
Docker
Windows
macOS
.NET
Unstable
Stable
Help?
Debian and Ubuntu
Official

Install Jellyfin via our APT repository or via manual archives (.deb).

Install Instructions
Downloads (Debian)
Downloads (Ubuntu)
Generic Linux
OfficialCustom FFmpeg Unavailable

Linux self-contained binary TAR archives (.tar.gz) are provided.

Downloads
Arch Linux
OS Package

Install Jellyfin via Arch-Extra Repository.

Arch Downloads
AUR Downloads
Gentoo Linux
OS PackageCustom FFmpeg Unavailable

Install Jellyfin via the Gentoo Repository.

Install Instructions
Fedora/CentOS Linux
CommunityCustom FFmpeg Unavailable

Install Jellyfin via the RPMFusion Repository (Free).

Install Instructions
RPMFusion
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/servers

Skip to main content
Community StandardsServer Policy
On this page
Server Policy

Jellyfin is a free and open source project that provides the tools to run your own server for hosting your media, and clients to connect to one of those servers.

The Jellyfin Project itself, and members of the Jellyfin team, do not provide servers for you to use, with the sole exception of our demo server for evaluation and testing.

If you are using or paying someone for "Jellyfin" i.e. access to a specific server:

It is not us. We do not run that server. Do not contact us, privately or publicly, for help with connecting, resetting your password, etc. We cannot help you because we do not run the server. Contact whoever you are paying. If you do not know who that is, we cannot help you.

This is almost unequivocally piracy of some sort. Do not discuss it with us as per our community standards.

Requests for support/help with other people's servers will be ignored.

If You Run A Jellyfin Server​

If you run a Jellyfin server instance for other people, ensure that your users are aware that you are their contact for help and support, not us as a project. We are not your server's "customer support" team. You are not "Jellyfin". Do not insinuate to your users that your server is run by us or that we are the same people.

The best way to avoid problems here is to use the "Branding" -> "Login disclaimer" field in the server "General" settings. In this field, give your users a help link, contact form, or something that directs them to you, so they know who to contact when they need help with the server.

We will link your users to this page if they contact us for help with specific issues on your server. If you are charging people for pirate access to a Jellyfin server and violate these guidelines, and we become aware, we reserve the right to report you to your hosting provider for piracy and ban you and your users from our support channels. This is a violation of our community standards and will not be tolerated.

You have been warned.

Edit this page
Previous
Commercial Support Policy
Next
Contributing
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=Desktop

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=Android,Android%20TV

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=iOS,tvOS

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=Fire%20TV

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=Roku

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients?platform=Kodi

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/#__docusaurus_skipToContent_fallback

Skip to main content
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Jellyfin 10.10.0
October 26, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.10.0!

This major release brings several new features, improvements, and bugfixes to improve your Jellyfin experience. With our faster release cadence between 10.9.0 and 10.10.0, this release should be far less daunting, so please read on for a quick peek at what's new and some important-to-know breaking changes!

You may upgrade your Jellyfin instances at any time now. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version. As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Happy watching!

- Joshua

Tags:release
Read more
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

Tags:releasetesting
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Jellyfin 10.9.0
May 11, 2024 · 9 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.9.0!

This major release brings many new features, improvements, and bugfixes to improve your Jellyfin experience.

You may upgrade your Jellyfin instances at any time now, however please read on for a complete detailing of what's new and changed, including some very important release notes. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version.

Happy watching!

- Joshua

Tags:release
Read more
Testing 10.9.0
March 27, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now in our feature freeze window for the 10.9.0 release! That means that from now until the release, we'll be focusing only on merging bugfixes and other improvements, while all features will be on hold until the release is finalized.

That also means it's time to start testing. As outlined in our last blog post, we're doing things a bit differently this release, so this post will provide the steps one would need to take to help us test the new release.

If you want to help out, please read on!

- Joshua

Tags:release
Read more
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Tags:releaseinfrastructure
Read more
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/efcore-refactoring

Skip to main content
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

What exactly have we done​

Joshua’s blog post in November 2024 outlined much of what we aimed to achieve, and I want to take this opportunity to address the feedback and questions we've received, clarifying a few key points.

The old code included many instances of direct access to the underlying SQLite database. SQLite is a file-based database where Jellyfin stores most of its important data. This has been an issue for 4 reasons.

The old code was very poorly written
The old code was very complex
The old code was explicitly written to support SQLite only and nothing else
The old code migration handling was manual and error-prone

Because of this, we have been unable to quickly and reliably extend the database to add new features or improve existing ones. The new code uses EntityFramework migrations, which is the industry standard for database migrations in the C# ecosystem.

What haven't we done​

While we are currently working on it, the current code does not add support for alternative database providers on its own. Adding support for other database providers will be a significant change beyond just the refactor, and when introduced, will likely remain highly experimental for quite some time.

Very importantly, we have not yet optimized the rest of Jellyfin to work with the new database access. That means it is possible that unstable builds may be significantly slower while we are rewriting the rest of the code to utilize the new structures.

The new architecture also allows for a proper way of backing up Jellyfin instances while they are running, something that was previously impossible to do reliably.

The Future​

Unstable builds have been active for some time, but we will be temporarily turning them off this week, skipping the 20240127 unstable to provide a full week of in-master testing as originally stated by Joshua. We will re-enable unstable builds for the 20240203 unstable week with these changes, so ensure you have backups ready this week if you run unstable builds.

The migration will aggregate the old library.db into the jellyfin.db file and then rename it to library.db.old, so the unstable builds will no longer be compatible with the previous versions.

To migrate, we explicitly do not support versions older than 10.10.3. This means that if you want to test the migrations, you must start with an up-to-date database from the 10.10.z release train or current unstable.

Thank you, and if you have questions, please don't hesitate to join our matrix channels for assistance.

- JPVenson.

Tags:unstablewarningefcore
Older post
Jellyfin for Android TV 0.18
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/androidtv-v0.18.0

Skip to main content
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

This release marks another milestone in our journey to delivering the best media app on Android TV. Jellyfin 10.10 or newer is required. A complete list of changes, including their respective pull requests, can be found on GitHub. I've listed a subset of all changes below.

Skipping intros, outros and more with media segments​

Media segments are a new feature added in Jellyfin 10.10. A segment provides metadata for specific parts of a video or audio file. This can be used to mark an intro in your episode or the credits of a movie. The Android TV app can now use those segments to skip parts. By default, the app will ask to skip intros and outros, but you can fine-tune this to your liking within the app preferences. All media segment types are supported: intro, outro, preview, recap and commercial with three actions to choose from:

Skip
Immediately skips the playback forward to the end of the segment, or the next episode

Ask to skip
Shows a popup that the segment can be skipped by pressing the OK button on your remote and disappears after 8 seconds or when pressing the back button.

Do nothing
The segment will be ignored, with no skips or popups.

More actions and functionality related to media segments is already in the works for future releases, like a "mute" action that temporarily silences audio.

Revamped subtitles​

This release completely redesigns the way subtitles are loaded and shown on screen, resolving a large number of issues reported over the past few years.

Previously the app did not support embedded subtitles and forced the server to extract them from video files first. This is a resource-heavy process and often causes subtitles to not show up or with a big delay. A workaround for this was to use the "Subtitle Extract" plugin that will do this extraction ahead of time, this was cumbersome and is now no longer necessary.

Together with these loading changes, the app now reliably supports Presentation Graphic Stream (PGS) subtitles and positioning tags in the SubRip Subtitle Format (SRT), a much requested feature!

To make these changes happen, the preferences for subtitles have also slightly changed. It is now possible to choose your own background and outline colors.

Sing along with lyrics​

Not only did video playback improve, playing music has gotten some upgrades as well! The most exciting change here is support for lyrics. Whenever your song has lyrics available (added by a plugin or on your file system), they will be shown in the app. This works especially well when combined with our screensaver, which will show lyrics fullscreen.

Currently, 2 types of lyrics are supported: timed lyrics, which will highlight the current line of the vocal track, and untimed lyrics, which will automatically scroll based on the track duration.

In addition to the lyric changes, some bugs have been fixed where a music queue would never disappear when the last track ends and some text elements did not update properly.

Other changes​

In addition to the previously mentioned changes there's a lot more to enjoy. The video player will no longer randomly show its controls and they stay hidden when the video is loading for a smoother experience. An issue where sorting libraries by "last played" did not work for TV shows was fixed. And finally, a lot of improvements under the hood were made to make the app faster, easier to maintain, and more stable than ever.

There are as also two new experimental options for playback. The first one is related to decoding audio codecs, while normally the app will automatically fall back to using a different decoding approach using FFmpeg, this might not always work. You can now enable the "Prefer FFmpeg for audio playback" preference to force the fallback approach.

The second experimental option adds support for previews when scrubbing, once "Enable trickplay in video player" is checked you'll see image previews above the progress bar while scrubbing through your videos! There are some issues and annoyances with the current implementation which will be resolved before this feature will be enabled by default and marked non-experimental. Make sure the Trickplay feature is enabled on your libraries for the previews to show up.

Contributors​

Jellyfin is completely developed by volunteers, and couldn't be made without their great skills and dedication. Consider donating if you appreciate their work. A big shout-out to all contributors that made this release possible:

Jellyfin Team

@nielsvanvelzen - Donate via GitHub sponsors

Other contributors

@MichaelRUSF
@JagerSprinkles
@pascalwei
@kabel2
@starsep
@rickysixx
@ericleb010
@reacocard

And finally a big thank you to everyone who contributed translations, reported bugs, provided feedback and participated in beta testing!

Helping out​

If you have experience with Android TV development or with Kotlin and are interested in contributing yourself, feel free to dive into the source code and open a pull request. Alternatively, you can help with translating the app into your own language on our Weblate instance.

Downloads​

Update your app now to check out all these changes! The app stores will auto-update your Jellyfin app if you're already using the app. For new users, you can find the app on the app store of your platform.

  

Direct downloads are available for sideloading at repo.jellyfin.org or in the GitHub release assets.

You can also join our beta program on Google Play and help test new versions before they're released to the public. Read more about our beta program.

Tags:releaseandroid-tv
Newer post
EFCore refactoring is here
Older post
Warning for Unstable - EFCore refactoring is coming
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/efcore-refactoring-incoming

Skip to main content
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

What is EFCore, and why are we migrating to it?​

EFCore is the C#/.NET database handling framework, which simplifies database query handling in the Jellyfin codebase.

Our original database code was written by Emby in a time long before .NET Core existed, when Mono ruled the world in terms of cross-platform C# compatibility. As such, it handled the database poorly: SQLite queries embedded directly in the code, and a fairly horrific schema with no migration capabilities. This has caused us a lot of problems over the years as we try to change and improve the codebase and add new features, and as such, the team began migrating to EFCore quite a while ago.

We were able to move many of the databases quickly, mostly due to the diligent work of @BarronPM; those have been live for several major releases now. But the Library database has remained as it was, due to its massive complexity and exceptionally poor schema. This has caused a lot of problems, for instance very slow search, problems adding new media types (or deprecating old ones), and lots of complexity inside the codebase around handling "non-standard" (i.e. not Movies/TV Shows/Music Albums) media types, resulting in bugs.

Now, thanks to @JPVenson, we finally have the library database EFCore implementation ready to go. But there is a big catch.

There Will Be Bugs​

Once we merge this massive change set, there will be bugs. This is certain. And these bugs may completely trash your library database. So first and foremost, it is incredibly important that everyone running the Unstable builds understands that this is coming and how to prepare yourself.

What we will be focusing on​

Our primary goal will be to ensure that stable-to-stable migrations between 10.10.x and 10.11.x will work without a hitch, as we want and need this transition to be as seamless as possible for the majority of users running stable builds when 10.11.0 drops.

But to do this, we need to both test the changes in unstable, and ensure that our migrations are valid for data coming from the 10.10.x stable.

The downside of this is, though, that we might not be able to cleanly implement unstable-to-unstable migrations in a way that will work properly. While we will try to do this, we cannot guarantee it.

Our timeline​

This blog post starts the process to provide the warning to all unstable users that this is coming. Note that as of posting, unstable builds are disabled due to the recent 10.10.0 release, and will remain off for a little while.

About 1-2 weeks after this blog post, we will merge the Library EFCore migration into our master branch and begin preliminary testing. If you want to help here, you will have to build Jellyfin from source, and the more people who can help here the better!

About 2 weeks after merging, assuming everything looks generally OK, we will re-enable unstable builds for the general public. At this point, all unstable builds will apply the initial migrations on startup. That will bring us to about 4 weeks (give or take a week) from the 10.10.0 release.

Over the following weeks, we will take bug reports and try to correct them. This is the possible sticking point: if it's not possible for us to implement a clean set of migrations, we may decide to only focus the migration on stable-to-unstable conversions, rather than unstable-to-unstable. If this happens, you may need to restore a previous version and apply the new migrations to it.

What this actually means for you​

First and foremost, if this is too much for you, this is your warning for the off-ramp. Switch away from unstable now before we restore the unstable builds in a few weeks.

Second, ensure you have a robust backup strategy based on our suggested backup process. Take backups regularly, and, to help us test, try to also have a backup of your last stable release so you can run that through the migrations as well. Take backups before applying the next unstable build, every time.

Third, ensure you disable automatic upgrades. We generally recommend this anyways, but if you're still doing this, now is the time to stop.

Fourth, if you run into trouble, please ensure you report the bug with a title containing [EFCore Library]. This will help us find and fix the bugs.

Fifth and finally, if you have a failing migration, restore an older database version first and try to re-run it. If it still fails, try your oldest (ideally, 10.9.11 or 10.10.0 stable) backup as well. If that one doesn't work, it's a new bug to report.

Tags:unstablewarningefcore
Newer post
Jellyfin for Android TV 0.18
Older post
Jellyfin 10.10.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/jellyfin-release-10.10.0

Skip to main content
Jellyfin 10.10.0
October 26, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.10.0!

This major release brings several new features, improvements, and bugfixes to improve your Jellyfin experience. With our faster release cadence between 10.9.0 and 10.10.0, this release should be far less daunting, so please read on for a quick peek at what's new and some important-to-know breaking changes!

You may upgrade your Jellyfin instances at any time now. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version. As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Happy watching!

- Joshua

Breaking Changes​

Most clients should continue to work as-is without any issues or any forced upgrades, though this may change in the future. The sole exception is Jellyfin4Kodi, which currently has issues due to point 5 below, though a fix is hopefully forthcoming shortly.

We have deprecated Raspberry Pi V4L2 hardware transcoding support, and are looking to deprecate 32-bit ARM support (i.e. armv7 or armhf) in general for 10.10.0 and later, with a goal to remove 32-bit ARM support in 10.11.0. Older, slow ARM systems have always been tricky platforms for us: they're popular but extremely poor in performance, and this has caused a lot of people a lot of headaches. With the RPi5 entirely removing a hardware acceleration engine, and most ARM single-board computers now supporting ARM64, we are taking this action now to ensure it's widely known. If you are running Jellyfin on old ARM hardware, now is the time to start looking at an upgrade. See PR #1148.

We now use the system temporary storage engine (e.g. /tmp on Linux) for storing short-lived transient temporary files, to allow us to leverage temporary ramdisks and the like and avoid cluttering potentially slow storage. This may cause issues if you specifically depended on the previous behaviour. Note that this does not include transcoding temporary files. See PR #12226.

The server will now refuse to start if ffmpeg cannot be found, is an incorrect version, or does not function properly (missing extensions, etc.). With how critical ffmpeg is to Jellyfin, this has become very important to avoid mis-reported issues. This can be explicitly bypassed if needed. See PR #12463.

Network paths in libraries have been fully removed and will no longer work. This functionality has been deprecated for a long time, and most of it was removed in 10.9.0, but this removes the remainder. See PR #12446. Third-party clients relying on this functionality should be able to re-implement it as required.

Systems with Trickplay enabled may see a relatively long migration occurring during the upgrade. If Jellyfin seems to hang starting up after upgrading, please observe the logs and wait for the migration to complete. This helps enable the functionality below.

Cool New Features​
Media Segments​

The Jellyfin server now supports the management of Media Segments. This means that we store some additional information for certain time-spans on a video that clients can then use to provide additional actions. For example, when there is a Media Segment of the type intro, a client may display a button to skip that particular segment. For 10.10, we only provide the general structure to store those Media Segments, and you will still require a plugin to create them. We have created one plugin that does this, based on the Chapter names of a movie or Episode, which you can find in the Plugin catalogue, and others may be implemented in the future. The Web interface fully supports skipping segments; other client support is pending.

Trickplay​

We have significantly improved extraction by implementing optional keyframe extraction, which can boost image generating time significantly (around 100x, depending on configuration) at the cost of some frame accuracy, which should be fine for most users with longer trickplay frame durations. This should mean no more multi-day Trickplay jobs! Note that this must be explicitly enabled in the Trickplay settings.

Playback/Transcoding​

Many major enhancements to transcoding and playback, including support for software tonemapping of HDR10, HLG and DoVi, preliminary support for DoVi Profile 10, support for Dolby AC-4 audio, more stereo downmixing algorithms, QSV device selection, and more! Our FFmpeg is also now based off the upstream FFmpeg 7.0 release for additional features and improvements there.

Metadata​

It is now possible to select which plugins can provide lyrics to your music libraries, similar to how you can select the plugins providing metadata. This will provide more variety to Lyrics support.

Audio tag scanning has been significantly improved, and will thus hopefully be much more reliable and consistent.

Home videos should also now keep their rotation metadata.

Web​

We have added support for CBT and CB7 books, client-side rendering of PGS subtitles, and auto-scrolling lyrics as well as a lyrics editor interface.

Full Changelogs​

Full changelogs are available on the various release pages:

Server
Web
The Next Version​

Our faster release cadence has generally been received fairly positively within the team, though lack of structure has been a bit of a problem. So right now, we are outlining the development roadmap for 10.11.0. This may change as time goes on, but this should give everyone an idea of roughly when 10.11.0 is coming.

Target 10.11.z development window: November 2024 to March 2025
Target feature freeze: second week of April 2025
Target release date: end April 2025

A more detailed roadmap will be published closer to the feature freeze date.

Final Thoughts​

We want to thank everyone who contributed to the 10.10.0 release; Jellyfin wouldn't be what it is without your help. We're really proud of this project we've built as a community, and hope to continue to be the go-to FLOSS media system solution for a long time to come. Happy watching!

Tags:release
Newer post
Warning for Unstable - EFCore refactoring is coming
Older post
Release Roadmap for 10.10.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/release-roadmap-10.10.0

Skip to main content
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

The Release​
What's Different This Time?​

Not much at all! We're following the same general process as the 10.9.0 release, though with a slightly tweaked timeline and with more defined steps.

The Release Timeline​
Monday, September 9th, 2024 (unstable 20240909): Feature PR last-call, first beta. Any new feature PRs should get in right now to avoid missing the feature freeze. This is your 1 week warning! Developers/contributors please keep on top of your PR review feedback or your PR may miss the following deadlines and have to wait until 10.11.0.
Monday, September 16th, 2024 (unstable 20240916): Feature freeze, second beta. Any new feature PRs after this point must wait until 10.11.0 (in another ~6 months). In-flight feature PRs will likely make it assuming that all feedback is resolved before the API freeze. Again developers/contributors, please keep on top of your PR review feedback. New PRs should be bugfixes only after this point. Users should be safe to begin testing in earnest with this unstable.
Monday, September 23rd, 2024 (unstable 20240923): API freeze, third beta. All feature PRs should be merged by this point. If they're not, they will be moved to the 10.11.0 project and only merged to master once 10.10.0 is released. API is now soft-frozen so that client developers can begin confidently working on any client support changes needed for 10.10.0.
Monday, September 30th, 2024 (unstable 20240930): API lock, first release candidate. Major bugfix PRs should hopefully be either be merged or well in-flight by this point. Only non-API-changing bugfixes after this point. We should have a feature overview blog post in draft state by this point.
Monday, October 7th, 2024 (unstable 20241007): Final planned unstable, second release candidate. The release should basically be ready to go, and any remaining bugfix PRs should be merged before this unstable.
Saturday, October 12th, 2024: Release of 10.10.0!
Possible Timeline Changes​

EDIT 2024-10-12: We have opted to take the two week delay due to pending changes in Web that must get in. We are currently planning for a release on October 26th.

Since this is a much smaller and quicker release than 10.8.0 or 10.9.0 were, hopefully this is enough time to get everything sorted and ready to go. But if we find it's not, we reserve the right to add an extra week in one or both of the following places:

After the Feature freeze, if we find that there are any outstanding major bugfixes that require additional time to merge before the API freeze.
After the API lock, if we find that there are any outstanding non-API-breaking bugfixes that require additional time to merge before the final unstable.

If neither of those happen, the release will proceed as planned; otherwise, an extra step will be added into the timeline after the given points that matches the previous stage. This might push the final unstable back to either October 14th or October 21st, and the final release to either October 19th or October 26th. If this is relevant to your interests, please keep an eye on our Announcements Matrix channel for announcements.

Information for 3rd Party Clients​

After the API freeze, our API should ideally remain stable, though it's possible there might be minor changes up until the API lock step. Please feel free to begin testing compatibility and report any issues to us now, and keep an eye out on those dates for the final API specification.

Information for Contributors​

If you're contributing to Jellyfin and your feature PRs miss the deadline, please don't fret. We are committed to this shorter major release timeline going forward, so 10.11.0 is at most about 6 months away. Your feature should eventually make it in.

If you wish to help by submitting a bugfix, please do so as soon as you can, as we'd like to get as many fixes in and tested before the API lock as possible, to give at least 2 weeks of final testing before the release. Ensure you clearly specify that it is a bugfix, and ensure you keep your changes to an absolute minimum needed to fix the bug. Bugfix PRs will target the master branch until the final release, at which point they will target the release-10.10.z branch for upcoming point releases.

How You Can Test​

Testing this release should be very easy, identical to 10.9.0. Since our pre-releases are "just" our unstable releases here, that means that following our normal "unstable" installation process is all you need to do.

To find that, visit our main server downloads page, select the platform you require along the top centre, then on the top right, select "Unstable". The instructions and links will now be for the unstable release. You can also find additional testing documentation in the docs.

For Docker this simply means pulling the unstable tag on the image. For Debian and Ubuntu repositories, this means adding unstable to your existing jellyfin.sources entry. For other platforms, please review the provided instructions as not all platforms will support unstable.

Next, before installing an unstable release, ensure that you back up your existing server configuration. It is not possible to downgrade in-place as there are database changes. Just making a simple copy of your configuration directories with Jellyfin stopped is sufficient, and where those can be found depends on the platform.

Next, if you use plugins, install the unstable plugin repository. Due to compatibility issues, we distribute plugins for unstable in a separate manifest, so this must be added manually, and on first start all incompatible plugins (i.e. all existing plugins on an upgrade) will be upgraded. To add the repository, navigate to the Administration Dashboard, Advanced, Plugins, then click the Repositories tab at the top. Click the "+" Add button, and enter "Unstable" for the name and "https://repo.jellyfin.org/files/plugin-unstable/manifest.json" for the Repository URL. We also recommend that you disable/remove the Stable repository at this time, as it's possible they will conflict. After the initial update you may need to manually restart your Jellyfin instance one further time to ensure all plugins are activated properly.

Finally, install the unstable version and run it. The upgrade should happen seamlessly in the background, and you'll be able to log in to your Jellyfin instance normally after this point. Ensure you perform a hard refresh in your browser, and restart all clients.

Once 10.10.0 is fully released, you can switch back easily by reinstalling the new stable version, and changing back to the stable plugin manifest (URL "https://repo.jellyfin.org/files/plugin/manifest.json"). Unstable releases will be paused for at least 2 weeks after the release to give you plenty of time to switch.

How To Report Bugs​

While running the unstable prereleases, reporting bugs is important. After all, if we don't know about bugs, we can't work to fix them!

First, if you encounter a bug, ensure you're running the latest unstable version, and try to reproduce it a couple times. If you can't, it's always possible it was a one-off occurrence, but if it happens again, definitely report it!

Bugs can be reported on our GitHub issues page or on our Forums.

You'll want to include two important pieces of information in your bug report, beyond the standard asks. First, ensure you include the "Build Version" as shown in the main dashboard page. This reports the exact unstable build you're using to help narrow down what might have caused the issue. This is doubly important if you see a new bug turn up in a future unstable build. Second, please make clear that you are running the unstable builds and not stable builds, as well as if this is an upgrade or fresh install, as that can be an important piece of information.

Once your bug is reported, please check back diligently to see if any additional information has been requested, and we hope to get it fixed soon.

Thanks, and happy watching!

Tags:releasetesting
Newer post
Jellyfin 10.10.0
Older post
Android TV version 0.17
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/unstable

Skip to main content
2 posts tagged with "unstable"
View All Tags
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/warning

Skip to main content
2 posts tagged with "warning"
View All Tags
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/efcore

Skip to main content
2 posts tagged with "efcore"
View All Tags
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/authors/nielsvanvelzen

Skip to main content
Niels van Velzen
Core Team, Android Lead
View all authors
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Android TV version 0.16
December 10, 2023 · 4 min read
Niels van Velzen
Core Team, Android Lead

It has been a busy year with a lot of work on the Android TV app. After an extended beta period today is finally the day to share this work to the public. Read along to learn everything about improved music playback, the new screensaver and more!

- Niels

Tags:releaseandroid-tv
Read more
Android TV 0.15
December 24, 2022 · 3 min read
Niels van Velzen
Core Team, Android Lead

I'm excited to announce the third and final release of 2022 for the Android TV app. While this release mostly includes internal changes, there are still a few new features to highlight. Keep reading to learn more about what's new.

- Niels

Tags:releaseandroid-tv
Read more
Android TV version 0.14
August 2, 2022 · 6 min read
Niels van Velzen
Core Team, Android Lead

Introducing Quick Connect, external trailers, improved crash reporting and more.

Tags:releaseandroid-tv
Read more
Android TV v0.13
March 17, 2022 · 4 min read
Niels van Velzen
Core Team, Android Lead

We're back with another release for Android TV and Fire TV users containing a lot of bugfixes!

Tags:releaseandroid-tv
Read more
Android TV v0.12
September 30, 2021 · 6 min read
Niels van Velzen
Core Team, Android Lead

Today we're bringing the Android TV app to 2021 with a modern design and tons of other changes.

Tags:releaseandroid-tv
Read more
Regarding the Android betas
July 24, 2021 · 2 min read
Niels van Velzen
Core Team, Android Lead

With the release of the first Android TV 0.12 release beta, this is a good time to explain how our Android beta programs work and how to start using them. The mobile app has used a public beta channel for around a year now and with the Android TV app coming close to a new release we're adding a similar program for that as well.

Tags:android-tv
Read more
Android app now on F-Droid
March 1, 2021 · One min read
Niels van Velzen
Core Team, Android Lead

We're happy to announce the immediate availability of the Android mobile app on the F-Droid store. The F-Droid version does not contain any proprietary libraries and builds are fully reproducible.

Read more
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/release

Skip to main content
21 posts tagged with "release"
View All Tags
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Jellyfin 10.10.0
October 26, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.10.0!

This major release brings several new features, improvements, and bugfixes to improve your Jellyfin experience. With our faster release cadence between 10.9.0 and 10.10.0, this release should be far less daunting, so please read on for a quick peek at what's new and some important-to-know breaking changes!

You may upgrade your Jellyfin instances at any time now. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version. As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Happy watching!

- Joshua

Tags:release
Read more
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

Tags:releasetesting
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Jellyfin 10.9.0
May 11, 2024 · 9 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.9.0!

This major release brings many new features, improvements, and bugfixes to improve your Jellyfin experience.

You may upgrade your Jellyfin instances at any time now, however please read on for a complete detailing of what's new and changed, including some very important release notes. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version.

Happy watching!

- Joshua

Tags:release
Read more
Testing 10.9.0
March 27, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now in our feature freeze window for the 10.9.0 release! That means that from now until the release, we'll be focusing only on merging bugfixes and other improvements, while all features will be on hold until the release is finalized.

That also means it's time to start testing. As outlined in our last blog post, we're doing things a bit differently this release, so this post will provide the steps one would need to take to help us test the new release.

If you want to help out, please read on!

- Joshua

Tags:release
Read more
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Tags:releaseinfrastructure
Read more
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Roku Version 2.0.0
December 11, 2023 · 6 min read
1hitsong
Roku Team

When we say this 2.0.0 release is a major milestone, we honestly mean it. New features and bug fixes abound, but even behind the scenes the updates continue all the way to the foundation with us updating every single file in the app to support a new programming language. You can't get more monumental than that!

Read more to learn about some of the exciting new features.

- 1hitsong

Tags:releaseroku
Read more
Android TV version 0.16
December 10, 2023 · 4 min read
Niels van Velzen
Core Team, Android Lead

It has been a busy year with a lot of work on the Android TV app. After an extended beta period today is finally the day to share this work to the public. Read along to learn everything about improved music playback, the new screensaver and more!

- Niels

Tags:releaseandroid-tv
Read more
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/android-tv

Skip to main content
9 posts tagged with "android-tv"
View All Tags
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Android TV version 0.16
December 10, 2023 · 4 min read
Niels van Velzen
Core Team, Android Lead

It has been a busy year with a lot of work on the Android TV app. After an extended beta period today is finally the day to share this work to the public. Read along to learn everything about improved music playback, the new screensaver and more!

- Niels

Tags:releaseandroid-tv
Read more
Android TV 0.15
December 24, 2022 · 3 min read
Niels van Velzen
Core Team, Android Lead

I'm excited to announce the third and final release of 2022 for the Android TV app. While this release mostly includes internal changes, there are still a few new features to highlight. Keep reading to learn more about what's new.

- Niels

Tags:releaseandroid-tv
Read more
Android TV version 0.14
August 2, 2022 · 6 min read
Niels van Velzen
Core Team, Android Lead

Introducing Quick Connect, external trailers, improved crash reporting and more.

Tags:releaseandroid-tv
Read more
Android TV v0.13
March 17, 2022 · 4 min read
Niels van Velzen
Core Team, Android Lead

We're back with another release for Android TV and Fire TV users containing a lot of bugfixes!

Tags:releaseandroid-tv
Read more
Android TV v0.12
September 30, 2021 · 6 min read
Niels van Velzen
Core Team, Android Lead

Today we're bringing the Android TV app to 2021 with a modern design and tons of other changes.

Tags:releaseandroid-tv
Read more
Regarding the Android betas
July 24, 2021 · 2 min read
Niels van Velzen
Core Team, Android Lead

With the release of the first Android TV 0.12 release beta, this is a good time to explain how our Android beta programs work and how to start using them. The mobile app has used a public beta channel for around a year now and with the Android TV app coming close to a new release we're adding a similar program for that as well.

Tags:android-tv
Read more
New Android TV Release - v0.11.0
February 4, 2020 · 2 min read
Niels van Velzen
Core Team, Android Lead

Thank you for using Jellyfin! This is a major update for the Android TV client.

Tags:releaseandroid-tv
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/testing

Skip to main content
One post tagged with "testing"
View All Tags
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

Tags:releasetesting
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/androidtv-v0.17.0

Skip to main content
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Notable changes​

This release comes with over 100 changes from 13 contributors. The complete list of changes, including their respective pull requests, can be found on GitHub. I've listed the most important/noticeable changes below.

Navigation​

It might seem like just one button, but it solves a significant issue. A new 'home' button in the top-right corner lets you return to the Jellyfin home screen easily, instead of pressing the back button repeatedly. Additionally, the layout of the item details has been slightly tweaked to fit more useful information.

Playback​

The current video player was improved by adding support for more audio codecs, including WAV, Vorbis and PCM. Additionally, timeouts for player errors were increased to give transcode and remux tasks more time to start. This improves playback for media stored on network drives and BDMV files that require unpacking.

Audio normalization support was added to automatically adjust volume levels for music playback. This feature prevents sudden volume changes between songs. To activate this feature, you'll need to enable the LUFS scan for your music library.

Screensaver​

The screensaver now includes a feature to filter items based on their age rating. By default, only items with an age rating up to 13 will be displayed, ensuring a family-friendly environment. Age rating options can be changed in the preferences under the customization tab.

Additionally, the screensaver has been enhanced to display a logo of the movie or series being shown.

Other changes​

Series and seasons now display their respective special features, which were previously available only for movies. Additionally, the search function has been improved to include results for Live TV channels, playlists, collections, photo albums, and individual photos.

Invisible but noteworthy, a significant amount of work was invested in reworking the communication between the app and the server. This has resulted in a faster and more reliable app, with improved performance and the groundwork laid for the development of exciting new features. As a consequence of these changes, the app now requires Jellyfin 10.9 or newer and older versions are no longer supported.

Contributors​

Jellyfin is completely developed by volunteers, and we couldn't do without their great skills and dedication. Consider donating if you appreciate their work. A big shout-out to all contributors that made this release possible:

Jellyfin Team

@nielsvanvelzen - Sponsor via GitHub sponsors
@Bond-009 - Sponsor via GitHub sponsors

Other contributors

@pascalwei
@haydenzeller
@DoggoOfSpeed
@bathompson
@VizuaaLOG
@3l0w
@mnsrulz
@MichaelRUSF
@efreet7
@ConnorS1110
@cbeyls

We'd also like to thank everyone who reported bugs, provided feedback and participated in beta testing!

Helping out​

If you have experience with Android TV development or with Kotlin and are interested in contributing yourself, feel free to dive into the source code and open a pull request.

Alternatively, you can help with translating the app into your language on our Weblate instance.

Downloads​

Update your app now to check out all these changes! The app stores will auto-update your Jellyfin app if you're already using the app. For new users, you can find the app here:

  

Direct downloads are available for sideloading at repo.jellyfin.org or in the GitHub release assets.

You can also join our beta program on Google Play and help test new versions before they're released to the public.

Tags:releaseandroid-tv
Newer post
Release Roadmap for 10.10.0
Older post
Jellyfin 10.9.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/jellyfin-release-10.9.0

Skip to main content
Jellyfin 10.9.0
May 11, 2024 · 9 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.9.0!

This major release brings many new features, improvements, and bugfixes to improve your Jellyfin experience.

You may upgrade your Jellyfin instances at any time now, however please read on for a complete detailing of what's new and changed, including some very important release notes. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version.

Happy watching!

- Joshua

Key Release Notes/Breaking Changes​

There are several key changes with 10.9.0 that administrative users should be aware of, before getting into the more specific changes.

As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Ubuntu users: We have dropped support for non-LTS Ubuntu releases with 10.9.0. That is, we have not built 10.9.0 packages for any releases except 20.04 LTS, 22.04 LTS, and 24.04 LTS, and we will not publish builds for any new non-LTS releases going forward. For an explanation of why, please see our previous blog post. If you use another release, please upgrade to 24.04 LTS or switch to the Docker container.

Fedora/CentOS/RHEL/etc. users: We have dropped our official RPM packages and suggest switching to the 3rd-party RPMFusion repository or the Docker container. Support for RHEL-like distributions has been a major pain point for us for a very long time, and we feel that letting the community over at RPMFusion handle this is in our best interest going forward, similar to how Arch, Gentoo, etc. packages are handled. For more details, please see our previous blog post.

Docker users: We now offer GitHub Container Registry (GHCR) as an alternative container registry in addition to Docker Hub. You can pull images from the new registry via URIs like ghcr.io/jellyfin/jellyfin:latest. Don't worry, we have no plans to drop Docker Hub as a container registry, but we feel providing both gives users more choice and flexibility.

Docker users: If you encounter problems loading your homepage, you may need to remove the DOTNET_SYSTEM_GLOBALIZATION_INVARIANT environment variable from your container, as this is no longer valid in Jellyfin 10.9.0. For more details please see these issues.

Nginx reverse proxy users: If you have a block in your nginx config that begins with location ~ ^/web/$ { and the comment # location block for /web - This is purely for aesthetics [...], please remove that block as it will cause occasional issues with 404's and/or slow performance on 10.9.z.

The Big Changes​

This release has been over two years in the making, so we're really glad to finally get it out to you. The long cycle does mean quite an extensive changelog however, with well over 1100 pull requests merged into our master branch since 10.8.0 first dropped back in 2022. This section will detail all the big changes, broken up by general function and area of the system. In addition to these big items, there are hundreds of smaller bugfixes, quality-of-life tweaks, and other minor changes that we won't touch on here, but if you want to see the full list, you can do so over on the GitHub releases for the core server and the Web UI.

General​

We now support "trickplay" a.k.a. live video scrubbing. When scrubbing through a video with this enabled, you will be able to see a live preview of the video at that timestamp. Note that this requires explicit client support, which may require some time to become available depending on your client.

Web redirections are now handled more reliably, reducing the likelihood of hitting dead or invalid pages in the UI. Please ensure you force-refresh or clear any browser cache for your Jellyfin instance to see the full benefits.

DLNA support is now provided by a plugin and has been removed from the core server. This has several major benefits: first, it can be updated independently of the server to some degree; second, it will not be enabled for anyone unless they want it and explicitly install the plugin; and third, it reduces the potential of security holes around DLNA due to both previous benefits. If you wish to use (or continue to use) DLNA, please install the plugin after upgrading.

We now support AVIF and WEBP images for Pictures libraries.

Tags are now accounted for during searches, allowing one to search by tag.

We now support multiple simultaneous subtitle tracks (maximum of two, a primary and secondary) in the web player.

We've revamped the administrative dashboard UI to help improve usability and ease of finding options.

API & Security​

All API endpoints now return proper return codes, ensuring that API endpoint results can be reliably interpreted without additional parsing.

Parental ratings are significantly improved, with better enforcement, inheritable ratings, and more.

LiveTV and Collection permissions are now discrete and configurable per-user.

The EasyPassword (PIN) feature has been removed as this was a big security risk especially for administrator accounts; QuickConnect login is still supported however.

User permission handling has been unified and numerous bugs fixed, ensuring a more secure server from untrusted users.

Core Server & Networking​

The .NET version has been upgraded to version 8, the latest major and LTS release. This brings us many under-the-hood improvements and changes to help with our ongoing effort to streamline the codebase and improve overall performance.

Our minimum FFmpeg version has been bumped from 4.0 to 4.4 to take advantage of many new features. For users of our Jellyfin FFmpeg build (Docker, .deb/Debuntu repo, and Windows installs), you're already on a newer version with FFmpeg 6.0.1, but this minimum change would affect any other platforms.

The server now supports in-process restarting, and removes the old hacky restart.sh method. This should make things like installing plugins much more robust and ensure a consistent restart experience regardless of platform or install method.

Uploaded images are now subject to much more verification, helping plug several security holes in this feature.

The backend SQLite database now supports connection pooling, which should improve performance for database operations.

Support for the HappyEyeballs engine improving dual-stack IPv4/IPV6 network support.

Improved handling of IP binding to fully respect these settings (including DLNA and SSDP).

Packaging​

The jellyfin service user is now automatically added to the render and video groups on Debian/Ubuntu systems for new installs, helping improve the onboarding for hardware acceleration.

Packaging is now unified with a new CI system, as outlined in our previous blog post. As a normal user you should see no change here, but this helps massively improve the build process, and if you are building your own packages please reference the new packaging repository for the updated process.

Transcoding & FFmpeg​

The --ffmpeg command-line flag is now the primary method of setting FFmpeg paths, and configuration of the FFmpeg paths via encoding.xml is now deprecated. All official packaging will revert to defaults unless explicitly set before upgrade.

Several audio improvements: support for Opus, FLAC, and ALAC codecs in the HLS engine; improved support and handling for transcoding DTS and TrueHD audio streams; new codec enforcement; better bitrate calculations; new audio normalization features; and stereo downmixing algorithm selection.

FFmpeg segments can now be automatically deleted after the client requests them, significantly reducing the space requirements of the transcoding temporary directory. This optional feature is disabled by default and can be enabled in the transcoding settings.

Support for direct stream playback of DVD and Blu-ray data folders, preferred over ISOs.

Support for AV1 hardware and software encoding.

Support for RK3588 hardware acceleration via MPP.

Support for Vulkan-based tonemapping with AMD VA-API.

Support for complete hardware acceleration on Apple systems (both Apple Silicon and Intel; previously was partial).

Support for Dolby Vision playback remuxing.

Scanning, Library & Playlist Management​

Support for scanning and displaying local lyric files (embedded or external files; Internet lyric provider searching is planned for 10.10).

Season names are now parsed from NFO files.

The MusicBrainz interface has been improved to better handle music libraries.

Support for hearing-impaired subtitles (sdh/hi./cc).

The visibility of playlists can now be made private

User playlists are now private by default
We're working on playlist sharing for a future release

Invalid items will be automatically removed from playlists.

Casting​
Better local network detection
Connectivity improvements
Ability to self-host cast receiver

We're looking for contributors for our cast receiver. This is the application that loads on a TV when using the "Google Cast" feature. Please reach out if you're interested.

The Next Version​

With our continuous integrations improvements outlined previously, we're quite confident that this will be our last "very long" release cycle. Our plan is for the next major version (10.10.0) to be released at most 6 months from now, some time in October. We hope this increased cadence will help alleviate the problems with large releases such as a very long time-to-stable for new features, translations, etc. and help lower the number of major bugs at each major release, streamlining the upgrade process. But this needs everyone's help. Back in October 2023, we made a call for developers, and we've gotten a lot of interest, but this is not a one-and-done event. We need contributions now more than ever, especially around the web frontend to help implement our planned design changes. If this interests you, please reach out and we can help get you set up.

Final Thoughts​

We want to thank everyone who contributed to the 10.9.0 release. According to GitHub over 100 people contributed across both repositories, and Jellyfin wouldn't be what it is without your help. We're really proud of this project we've built as a community, and hope to continue to be the go-to FLOSS media system solution for a long time to come. Happy watching!

Tags:release
Newer post
Android TV version 0.17
Older post
Testing 10.9.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/testing-10.9.0

Skip to main content
Testing 10.9.0
March 27, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now in our feature freeze window for the 10.9.0 release! That means that from now until the release, we'll be focusing only on merging bugfixes and other improvements, while all features will be on hold until the release is finalized.

That also means it's time to start testing. As outlined in our last blog post, we're doing things a bit differently this release, so this post will provide the steps one would need to take to help us test the new release.

If you want to help out, please read on!

- Joshua

What's Different and The Release Plan​

First, a quick rundown on what's different from our previous releases. The last few major releases, we went back and forth between various versions of -beta and -rc tags, but ultimately due to the complexity of 10.8.0 nearly two years ago, we've decided to abandon that idea going forward. As nice as it is to publish pre-release tags, we feel that doing so is not worth the burden and headache during this period and after, when we already have a better solution in our weekly unstable builds.

So, in effect, our weekly unstable builds are now working double-duty as our beta/release candidate versions. Here's how they map over the coming weeks:

20240325: The first "beta". Feature freeze has begun.
20240401: The second "beta". One week of freeze.
20240408: The third "beta". Two weeks of freeze, and we hope to have most glaring bugs fixed by this point.
20240415: The first "release candidate". We hope that by this point everything is in good shape for a release, with only a few lingering bugs.
20240422: The second and, ideally, final "release candidate".
10.9.0: The actual release, during the weekend of April 26th-28th.

All of this, of course, assumes a smooth window, we we are fairly hopeful of, but any number of things could throw a wrench in this plan, so we are continuing to play things by ear and see how each week turns out.

INFO

Update (2024-05-04): Due to some critical issues, we've decided to delay the release of 10.9.0 to ensure everything is working properly on release.

How You Can Test​

Testing this release should be very easy, in a way that our previous releases weren't. Since our pre-releases are "just" our unstable releases here, that means that following our normal "unstable" install process is all you need to do.

To find that, visit our main server downloads page, select the platform you require along the top centre, then on the top right, select "Unstable". The instructions and links will now be for the unstable release. You can also find additional testing documentation in the docs.

For Docker this simply means pulling the unstable tag on the image. For Debian and Ubuntu repositories, this means adding unstable to your existing jellyfin.sources entry. For other platforms, please review the provided instructions as not all platforms will support unstable.

Next, before installing an unstable release, ensure that you back up your existing server configuration. It is not possible to downgrade as there are a significant number of database changes. Just making a simple copy of your configuration directories is sufficient, and where those can be found depends on the platform.

Next, if you use plugins, install the unstable plugin repository. Due to compatibility issues, we distribute plugins for unstable in a separate manifest, so this must be added manually, and on first start all incompatible plugins (i.e. all existing plugins on an upgrade) will be upgraded. To add the repository, navigate to the Administration Dashboard, Advanced, Plugins, then click the Repositories tab at the top. Click the "+" Add button, and enter "Unstable" for the name and "https://repo.jellyfin.org/files/plugin-unstable/manifest.json" for the Repository URL. We also recommend that you disable/remove the Stable repository at this time, as it's possible they will conflict, and under 10.9.0 the repository URL will change. After the initial update you may need to manually restart your Jellyfin instance one further time to ensure all plugins are activated properly.

Finally, install the unstable version and run it. The upgrade should happen seamlessly in the background, and you'll be able to log in to your Jellyfin instance normally after this point. Ensure you perform a hard refresh in your browser, and restart all clients.

Once 10.9.0 is fully released, you can switch back easily by reinstalling the new stable version, and changing back to the stable plugin manifest (URL "https://repo.jellyfin.org/files/plugin/manifest.json").

How To Report Bugs​

While running the unstable prereleases, reporting bugs is important. After all, if we don't know about bugs, we can't work to fix them!

First, if you encounter a bug, ensure you're running the latest version, and try to reproduce it. If you can't, it's always possible it was a one-off occurrence, but if it happens again, definitely report it!

Bugs can be reported on our GitHub issues page or on our Forums.

You'll want to include two important pieces of information in your bug report, beyond the standard asks. First, ensure you include the "Build Version" as shown in the main dashboard page. This reports the exact unstable build you're using to help narrow down what might have caused the issue. This is doubly important if you see a new bug turn up in a future unstable build. Second, please make clear that you are running the unstable builds and not stable builds as well as if this is an upgrade or fresh install, as that can be an important piece of information.

Once your bug is reported, please check back diligently to see if any additional information has been requested, and we hope to get it fixed soon.

Information for 3rd Party Clients​

At this point, with our feature freeze our APIs should be stable, though do please expect bugfixes to make minor changes over the next few weeks. Please feel free to begin testing compatibility and report any issues to us.

Information for Contributors​

If you're contributing to Jellyfin and your existing feature PRs have not yet been merged, please don't fret. 10.9.0 was an abnormally long release cycle and something we do not wish to repeat, so your changes will get in soon for 10.10.0, which we expect to happen in about 6 months at most.

If you wish to help by submitting a bugfix, please do so as soon as you can, as we'd like to get as many fixes in and tested within the next ~3 weeks as possible, to give at least 2 weeks of final testing before the release. Ensure you clearly specify that it is a bugfix, and ensure you keep your changes to an absolute minimum needed to fix the bug. Bugfix PRs will target the master branch until the final release at which point they will target the release-10.9.z branch for upcoming point releases.

Tags:release
Newer post
Jellyfin 10.9.0
Older post
New CI, New Repo, A Renewed Push for 10.9.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/new-ci-new-repo

Skip to main content
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Why build a new CI?​

Our old CI was assembled way back in 2019 by a few dedicated team members (mostly @EraYan) using Azure DevOps. While it was a major improvement over my self-built pure-BASH build system that we had used for the first year or so, it still had a number of drawbacks:

It was a little difficult to understand, and relied on an external system (Microsoft Azure).
It still relied on a very complex, convoluted, and error prone BASH script to finalize the builds, because...
It built the Server and Web components of Jellyfin independently, triggered independently off the different repository tag events, and then had to rely on a whole lot of shenanigans to combine the results into unified, user-friendly packages.

There was also, though not a flaw with the CI system itself, the matter of Unstable builds. For a long time, they've been built on every merged PR, which was good for quickly seeing if things worked, but were effectively unusable for normal people as they changed so often. This was also something we wanted to fix.

At the time, GitHub Actions did not yet exist, and while we got everything to work, the CI as a whole was clunky and prone to failure. Major releases would often take me over 20 man-hours to prepare for and execute, while point releases would take at least 4-6 hours. It was a huge burden as a release manager, and also very cumbersome to fix if things broke in obscure ways, especially after the tag, because all the CI was in the code repos.

All this meant that our release velocity was extremely slow, as there was never a clear flow between master being tested and preparing for the next release.

Rather than continue incremental tweaking of this setup, about 2 years ago a project was started by @ferferga and @h1dden-da3m0n (who has since moved on) to move to GitHub Actions. While they did lay a lot of groundwork, that project ultimately stalled out and was effectively abandoned. Earlier this year, I took up the mantle to finally get this done in preparation for 10.9.0, and was able to get it working well, in a much easier to understand and hopefully much more consistent way.

More Automation​

The next part, besides just the CI itself, is an automation bot. As mentioned, releases took a long time, but only a fraction of that was spent actually dealing with Azure. The rest was administrative work: building changelogs, ensuring repos were in sync, running bump-version scripts, creating release drafts, checking them 3 times and still missing something, writing a release post for our Forum, etc. All of this added up to a significant time investment that I was rarely eager to do, which in turn trashed our velocity.

No project should be so dependent on one person, but we were, for a very long time. Part of the goal with this CI improvement is to streamline all these aspects as well using another piece of automation, a private chatbot.

The goal here is for us to tell our chatbot that we're ready for a release, for it to prepare all the text automatically, and then after review, tell it that it's ready to ship. Not only does this ease the process for myself, but it can easily be performed by others. And with the more reliable CI, this will hopefully mean a "set and forget" release process that helps us massively increase velocity.

While the bot isn't completely finished yet, the scaffolding is all there, and we definitely expect it to be ready to go in time for the actual 10.9.0 release.

Unifying packages​

One big drawback we mentioned of the previous CI was how it treated the server and web components of Jellyfin separately. It did this because these two components are indeed separate on the code side, in separate GitHub repositories and with different groups leading them. The problem is, that's not how Jellyfin is actually consumed by users. Users want just one package, installer, or archive to install and run out of the box. So we had to do a lot of complex shenanigans to combine the packages together.

No longer. With the updated CI, all our packaging is unified together, and split off into its own dedicated repository. This repository handles the two code repos via submodules and a simple Python script to synchronize what version is checked out of each before a build. Then, another Python script handles the actual building, which itself is then called from GitHub actions. It is still a little convoluted, but this is unavoidable for how complex our software ultimately is to package, and the hope is that having this in Python (a robust but easy-to-understand language) will help ensure this process isn't nearly as opaque as it previously was.

What this means depends on the different packaging types. For Debian and Ubuntu, it means that there is now one Debian source package for the three resulting binary packages (metapackage, web, and server) and thus all 3 can be built at once using a single dpkg-buildpackage command. For archives, this means that both the server and web components are built in sequence and then combined into one archive at build time, rather than haphazardly later, a process that failed more times than we could count. For installers, this means that the process is now simpler and can be automated. And lastly, for Docker, it means that we now provide just a single image, jellyfin/jellyfin, that was built all at once and does not rely on two intermediate images, another very error-prone process.

Related to this, and as part of the unified builds, each version of Debian and Ubuntu now has its own distinct package, with version suffixes like -deb12 or -ubu2204. This will help ensure smooth dependency handling for shared libraries like LibSSL. This should only matter if you're downloading .deb packages from the repo directly: ensure you download the right one for your release.

As a normal end user, you shouldn't see anything different because of this: you'll still install the packages the same way as always through our repositories. But for anyone building their own versions, you are now advised to use the above repository, as all non-development packaging (e.g. the debian/ and fedora/ folders, the deployment/ folder, etc.) will be removed from the main repositories, leaving just a simple Dockerfile for building testing and development images quickly.

A new repository master for a new CI system​

One thing the ground-up CI and unified packages enables is a much cleaner repository structure. Our previous structure was based around the combining requirements, full of strange quirks and nested directories to try to make that simpler. With those out of the picture, we were able to settle on a much nicer layout, and thus, a brand new master server to house them for an easier transition.

Part of this also includes a revamped browser page to easily facilitate getting to the files you need, descending through the tree of the new layout in a much more user-friendly way.

The new browser and repository master is now live as of posting at https://repo.jellyfin.org for perusal, and still includes the stable release packages in the new layout for your convenience until 10.9.0 is released. So, as mentioned in the preamble, please test it out and let us know if you run into any trouble with it, any broken links, or similar issues.

Unstable Releases​

As mentioned a bit above, our previous "build things on every pull request merge" was quite cumbersome to use, as things would change very rapidly, and keeping testers up-to-date was nearly impossible during fast-moving days. Way back in the early days, we had experimented with daily builds before moving to this model, but even those felt a little too quick for both our current development pace, and for users to keep adequetly up-to-date.

Instead, going forward we are moving to a Weekly cycle for Unstable releases. The builds will occur on Monday mornings around midnight Eastern time (UTC-5/4-with-DST), a time chosen farily arbitrarily but ensuring each week starts with a fresh Unstable build. This process is completely automated, and the resulting builds will be available soon thereafter in all our normal places.

We hope that this slower pace will help ensure that users running our Unstable builds have more of a chance to actually test the current state of Jellyfin and not be overwhelmed by the speed of releases, while also providing fast enough movement for people to truly test the latest and greatest features and bugfixes.

One final note, mentioned in more detail below, is that these Unstable Weekly builds will act as our pre-release testing for 10.9.0: there will be no tagged "beta" or "rc" releases for this cycle. This is being done to avoid the major burden we found with 10.8.0 of trying to continually backport the fixes for the upcoming stable release back into master, while also forward-porting bugfixes in the other direction when they were accidentally mis-targeted.

Cleaning up what we build​

As mentioned in the TL;DR, we are making three major changes to what we build, both for the Unstable releases and the upcoming 10.9.0 release:

We are dropping all non-LTS Ubuntu releases from our official APT package repository.

The reason is simple: it's a huge burden to keep up with Ubuntu's 6 month release schedule, just to support what are in practice minor versions with a 9 month lifespan. While we understand people might want to run Jellyfin on desktops or ensure their servers have "the latest" stuff, this just isn't tenable for us long term. So, going forward, our packages will only target the LTS releases, starting with 20.04 "Focal", and including 22.04 "Jammy" and the new 24.04 "Noble" due to release in April.

If you are using a non-LTS version of Ubuntu, you still have options. First, you can always upgrade to 24.04 and use that going forward. However do note that 24.04 will be the latest release that we build for until 26.04 comes out. Alternatively, if you still want to keep your system on the 6-month update path, you can migrate to our Docker images instead, and these have the added benefit of additional long-term stability even as your base OS changes.

We are dropping our own "official" RPM builds for Fedora and CentOS(-like) distributions in favour of RPMFusion:

These builds have always been a bit of a red-headed-stepchild for us. They were poorly maintained (despite some valiant efforts and community contributions), broke frequently, and this all came to a head when we started working on a combined spec.

Luckily, a community member (@mooninite) has already been maintaning a stable combined RPMFusion build of Jellyfin. This seemed like a perfect time to switch to that, reducing another bit of packaging burden away from us, as well as (finally) providing a "real" repository for our RPM-based users. The RPMFusion build is now the official Fedora/CentOS build listed on our downloads page and will be going forward. We're also taking steps to get a packaged FFmpeg build provided there too, so stay tuned.

Unstable users on Fedora/CentOS are recommended to stick with the Docker container instead, as this both bundles FFmpeg today and helps ensure speedy upgrades.

We are finaly adding GHCR (ghcr.io) support for our Docker images. This will help ensure that, even if something were to happen to Docker Hub, there is another source for our Docker images. If you wish to, you can use this source immediately for Unstable builds, and for 10.9.0 when it is released.

The 10.9.0 release cycle​

As we outlined over in this GitHub discussion, all these changes mean there will be some big changes for how we approach the 10.9.0 release cycle. To clarify things, the exact process will be as follows:

Starting now, and moving forward indefinitely for all future releases, the Weekly Unstable builds will act as the "beta" versions. That is to say, if you want to help us test, or just keep up with all the latest and greatest features, use the Unstable releases. The instructions found on our Downloads page still apply for enabling Unstable builds, as well as listing all of our supported Unstable platforms.

As we approach the planned release date, we will begin a feature freeze. While in the feature freeze, only bugfix PRs will be accepted. We expect this to last between 3 and 5 weeks. Currently, the tentative start is Monday, March 18th. During the freeze, the Unstable builds should be consistent and working, with only the minor fixes being merged.

As users, please be diligent about reporting bugs in the Unstable releases. Our Triage team has been very diligent these last few months at ensuring issues are triaged and looked at, so it is vitally important that anyone using the Unstable releases properly reports their bugs!

As we approach stability, i.e. after the 3-5 weeks of frozen bug-fixing, we will make the decision to cut the actual final release. I am personally hoping to get this done during the weekend of April 27-28, but that may change depending on how things go during the freeze.

The release will actually happen. We will cut a fresh release branch, tag the version, and - using the new CI above - perform the release. We do want to ensure that any 3rd parties who might trigger off of a Tag event on our repositories please turn this off for this release, as we fully expect to hit at least one or two roadblocks as we run through the process "for real". Once the dust settles, we can ensure that your releases get built, just in case we need to do anything drastic like re-tagging the release. Longer-term, we'll also come up with a better coordination process, so we'd like to ensure we work with any 3rd party maintainers to assist here - please reach out.

At that point, master will resume normal operation, and we will begin the stable point bugfix cycle for 10.9.0. We hope that with the improvements, 10.10.0 will not be a very long ways away after that, perhaps 3-6 months, after which this process will start anew.

We are very nearly there, over 2 years in the making, so we wanted to ensure we spread the word about this plan as far and wide as possible, especially to help get more people testing the new Unstable builds for bugs as we prepare for the final release!

Final thoughts​

That basically concludes my thoughts right now, both on the roadmap to 10.9.0 and the improvements we're making and have already made to the release process. Happy watching!

Tags:releaseinfrastructure
Newer post
Testing 10.9.0
Older post
Jellyfin Android 2.6
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/#the-tldr

Skip to main content
EFCore refactoring is here
January 25, 2025 · 3 min read
Jean-Pierre Bachmann
Server Team

EFCore has landed in unstable, and this will have consequences.

We have finally reached our first milestone in cleaning up the legacy database access code. This means that all SQL builders that targeted SQLite directly have been removed from code. This marks the first step towards a completely new database design, but we now need to take a quick look ahead and see what's next.

Unstable builds will be temporarily turned off this week, skipping the 20250127 unstable to provide a full week of in-master testing, and will be re-enabled for the 20250203 unstable next week, so ensure you have backups ready this week if you run unstable builds.

Otherwise please read on to see what exactly that means and what the future brings.

- JPVenson

Tags:unstablewarningefcore
Read more
Jellyfin for Android TV 0.18
November 30, 2024 · 6 min read
Niels van Velzen
Core Team, Android Lead

Version 0.18 of our Jellyfin for Android TV app is ready! Exciting features like lyrics and media segments are now available, along with significant improvements to subtitles and more.

Tags:releaseandroid-tv
Read more
Warning for Unstable - EFCore refactoring is coming
November 3, 2024 · 5 min read
Joshua Boniface
Project Leader

Unstable users: we are planning to merge our pending EFCore conversion of library.db in the next couple of weeks. It is imperative that all unstable users understand what is going on, what the plan is, and how to mitigate issues that will inevitably arise from this. Stable (10.y.z) users require no action.

Unstable builds are currently paused for roughly 4 weeks post-release of 10.10.0, and during this time, we plan to merge these extensive database changes. There will be breakage - bugs, fixes, and database migrations - during this time. This is your fair warning to either (a) prepare yourself with a good backup and recovery strategy and disable automatic upgrades; or (b) move off of unstable onto 10.10.0 stable until the dust settles (but, please don't, as we need your help to test!)

Please read on for a more detailed overview if you are interested.

- Joshua

Tags:unstablewarningefcore
Read more
Jellyfin 10.10.0
October 26, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.10.0!

This major release brings several new features, improvements, and bugfixes to improve your Jellyfin experience. With our faster release cadence between 10.9.0 and 10.10.0, this release should be far less daunting, so please read on for a quick peek at what's new and some important-to-know breaking changes!

You may upgrade your Jellyfin instances at any time now. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version. As always, ensure you back up your Jellyfin data and configuration directories before upgrading. With a major release, it's possible you will hit a bug and want to revert, and to do so, you will need to restore from a backup.

Happy watching!

- Joshua

Tags:release
Read more
Release Roadmap for 10.10.0
September 10, 2024 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now beginning the process for the 10.10.0 release, with a planned release date of Saturday, October 26th (updated - see below), 2024! We said 6 months in our 10.9.0 release posts, and we're sticking by that! The feature freeze proper starts next week, with a soft "new PR freeze" today, so here's what you need to know about the timeline and a recap of how to help us test 10.10.0 before release. Remember, the more people who help test it out before release, the less bugs we're likely to find after release, so fire up those secondary servers and warn your users: 10.10.0 is coming!

Developers/contributors, and those users who want a bit more information, please read on!

- Joshua

Tags:releasetesting
Read more
Android TV version 0.17
August 3, 2024 · 4 min read
Niels van Velzen
Core Team, Android Lead

The latest Android TV app release features enhanced stability, improved navigation with a new home button, and an updated screensaver with age rating filters. Check out the full blog post to see all the new features and update now!

Tags:releaseandroid-tv
Read more
Jellyfin 10.9.0
May 11, 2024 · 9 min read
Joshua Boniface
Project Leader

We are pleased to announce the latest stable release of Jellyfin, version 10.9.0!

This major release brings many new features, improvements, and bugfixes to improve your Jellyfin experience.

You may upgrade your Jellyfin instances at any time now, however please read on for a complete detailing of what's new and changed, including some very important release notes. For those who were running Unstable builds for testing, we thank you immensely, and you may now switch back to the Stable repository and forcibly reinstall/repull the latest version.

Happy watching!

- Joshua

Tags:release
Read more
Testing 10.9.0
March 27, 2024 · 6 min read
Joshua Boniface
Project Leader

We are pleased to announce that we are now in our feature freeze window for the 10.9.0 release! That means that from now until the release, we'll be focusing only on merging bugfixes and other improvements, while all features will be on hold until the release is finalized.

That also means it's time to start testing. As outlined in our last blog post, we're doing things a bit differently this release, so this post will provide the steps one would need to take to help us test the new release.

If you want to help out, please read on!

- Joshua

Tags:release
Read more
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Tags:releaseinfrastructure
Read more
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/infrastructure

Skip to main content
2 posts tagged with "infrastructure"
View All Tags
New CI, New Repo, A Renewed Push for 10.9.0
March 5, 2024 · 15 min read
Joshua Boniface
Project Leader

Over the last several weeks, I've been driving a major push to revamp and improve our CI, in an effort to improve our release workflow, our velocity of releases, and the burden they have on me as the release manager. This post will detail the changes we've made, how they might affect you as a user or contributor, and how we're planning to proceed with our 10.9.0 release cycle.

The TL;DR​

We have a new repository browser UI along with a new file layout, on a new master repository machine, built by new CI, that will hopefully make it nicer to look around and get right to what you need. This has now been cut over into production, but is still a bit of a work in progress, so please report any bugs you find to us! Note that quite a number of paths will have changed (anything under /server especially), but some will remain the same. If you get a 404 and can't find it through the browser UI, best to check in. 3rd party packagers downloading files manually from us are advised to contact us if needed.

We are dropping non-LTS Ubuntu packages, dropping our own Fedora/CentOS packages in favour of RPMFusion builds, and adding GHCR as a container repository for our Docker images.

For 10.9.0, we will not be producing explicit "beta" releases. Instead, we will test using our new Weekly Unstable builds. Once the master branch is sufficiently stable and good, we will release 10.9.0 directly from there (via our standard release branch process).

The 10.9.0 feature freeze (bugfix PRs only after this) will tentatively begin on Monday, March 18th. The hope is that all of the above will be ready by then so that obtaining Unstable builds for testing will be easy.

The 10.9.0 release itself is tentatively planned for the last weekend in April. To all 3rd parties who build packages of our releases, please read until the end for an important note about this release.

Read on for more details.

- Joshua

Tags:releaseinfrastructure
Read more
The New Jellyfin Forum
June 16, 2023 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we have created a new forum for the Jellyfin community:

https://forum.jellyfin.org

You can see the welcome message here and the forum rules here, or you can jump right to registering here, using either native forum registration or using an account from Discord, GitHub, Google, Reddit, StackExchange, or Twitter.

As part of this, we have also decided to close our Reddit community presence permanently. Please see the message there for details.

If you just want to get registered and start posting, this is all you need. But if you're interested in our motivations, choices, and technical implementation, please read on!

Tags:infrastructure
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/android-v2.6.0

Skip to main content
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

What's new​

The focus of this update is maintenance. We've fixed various bugs and made sure the app works on newer Android versions. Noticeable is the improved connection screen that now remembers your previously connected servers, making it a lot easier to switch between them.

Full release notes​

The complete list of changes for this release, including their respective pull requests, can be found on GitHub.

Contributors​

Jellyfin is developed by volunteer contributors, and we couldn't do without their great skills and dedication. They don't get paid by any organizations, so consider donating if you appreciate their work. A big shout-out to all contributors that made this release possible:

Jellyfin Team

@Maxr1998 - Sponsor via GitHub sponsors
@nielsvanvelzen - Sponsor via GitHub sponsors

Other contributors

@timm0e
@jmarcet

We'd also like to thank everyone who reported bugs, provided feedback and participated in beta testing! The feedback we received made this our most stable release to date.

Helping out​

If you have some experience with Android development or with Kotlin and are interested in contributing yourself, feel free to dive into the source code on GitHub and open pull requests.

Alternatively, you can help with translating the app into your language on our Weblate instance.

Downloads​

Update your app now to check out all these changes! The app stores will auto-update your Jellyfin app if you're already using the app. For new users, you can find the app here:

  

Direct downloads are available for sideloading at repo.jellyfin.org or in the GitHub release assets.

You can also join our beta program on Google Play and help test new versions before they're released to the public.

Tags:releaseandroid
Newer post
New CI, New Repo, A Renewed Push for 10.9.0
Older post
Roku Version 2.0.0
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/tags/android

Skip to main content
2 posts tagged with "android"
View All Tags
Jellyfin Android 2.6
December 12, 2023 · 2 min read
Niels van Velzen
Core Team, Android Lead
Max Rumpf
Android Mobile Lead

Improvements to the Jellyfin mobile experience are here. A new update for the Jellyfin Android app is ready! Read along to learn everything new in this update!

- Niels & Max

Tags:releaseandroid
Read more
Jellyfin Android 2.5.0
May 14, 2023 · 4 min read
Max Rumpf
Android Mobile Lead

It has been a long while since the last update, but after an extended beta testing period with plenty of bug reports (thanks, by the way!) and subsequent fixes, we're excited to finally announce a new major update to the Jellyfin app for Android.

Version 2.5.0 again focuses on improvements to the integrated player, and brings various new features, many bug fixes and a lot of technical maintenance and rewrites.

Read on to learn more!

Tags:releaseandroid
Read more
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/posts/page/2

Skip to main content
Roku Version 2.0.0
December 11, 2023 · 6 min read
1hitsong
Roku Team

When we say this 2.0.0 release is a major milestone, we honestly mean it. New features and bug fixes abound, but even behind the scenes the updates continue all the way to the foundation with us updating every single file in the app to support a new programming language. You can't get more monumental than that!

Read more to learn about some of the exciting new features.

- 1hitsong

Tags:releaseroku
Read more
Android TV version 0.16
December 10, 2023 · 4 min read
Niels van Velzen
Core Team, Android Lead

It has been a busy year with a lot of work on the Android TV app. After an extended beta period today is finally the day to share this work to the public. Read along to learn everything about improved music playback, the new screensaver and more!

- Niels

Tags:releaseandroid-tv
Read more
Jellyfin Security & You
November 26, 2023 · 3 min read
Joshua Boniface
Project Leader

We have just released our 10.8.13 stable version. This release fixes two serious security vulnerabilities, which will be detailed in full in approximately 1-2 weeks. Please be advised to update your Jellyfin instances as soon as possible before these vulnerabilities are released publicly.

Tags:security
Read more
A Call for Developers
October 1, 2023 · 5 min read
Joshua Boniface
Project Leader

This year, DigitalOcean's Hacktoberfest is in it's 10th year. In previous years, we haven't made too much of it, but within our project, this is our most important year yet.

We'd like to call on you, the wider community, to help make Jellyfin better! We need contributors, fresh ideas and blood to help the project move past our current funk and into something more.

Will you join us?

Tags:project
Read more
The New Jellyfin Forum
June 16, 2023 · 8 min read
Joshua Boniface
Project Leader

We are pleased to announce that we have created a new forum for the Jellyfin community:

https://forum.jellyfin.org

You can see the welcome message here and the forum rules here, or you can jump right to registering here, using either native forum registration or using an account from Discord, GitHub, Google, Reddit, StackExchange, or Twitter.

As part of this, we have also decided to close our Reddit community presence permanently. Please see the message there for details.

If you just want to get registered and start posting, this is all you need. But if you're interested in our motivations, choices, and technical implementation, please read on!

Tags:infrastructure
Read more
Jellyfin Android 2.5.0
May 14, 2023 · 4 min read
Max Rumpf
Android Mobile Lead

It has been a long while since the last update, but after an extended beta testing period with plenty of bug reports (thanks, by the way!) and subsequent fixes, we're excited to finally announce a new major update to the Jellyfin app for Android.

Version 2.5.0 again focuses on improvements to the integrated player, and brings various new features, many bug fixes and a lot of technical maintenance and rewrites.

Read on to learn more!

Tags:releaseandroid
Read more
Roku Version 1.6.4
April 5, 2023 · 3 min read
1hitsong
Roku Team

We are excited to announce the release of Jellyfin 1.6.4 for Roku! With so many new featues and bug fixes, you'll wonder how we crammed it all into one release. Keep reading to learn more.

- 1hitsong

Tags:releaseroku
Read more
A major milestone in the development of Jellyfin Vue
April 4, 2023 · 4 min read
Fernando Fernández
Vue Lead

280 commits, +28000 lines added, +43000 lines removed since November 2022: The results of the biggest refactor we ever tackled and an ecosystem upgrade we've been looking forward since we started working on this client on 2020.

Fernando
Tags:releasevue
Read more
Roku Version 1.6.3
January 13, 2023 · 3 min read
1hitsong
Roku Team

We are excited to announce the release of Jellyfin 1.6.3 for Roku! The primary goal of this release is resolving bugs & issues, but we still managed to add some new items too. Keep reading to learn more.

- 1hitsong

Tags:releaseroku
Read more
Swiftfin on the App Store
December 29, 2022 · 3 min read
Anthony Lavado
Core Team

As of today, Swiftfin, our native iOS/iPadOS/tvOS app is now on the Apple App Store. While this is still a work in progress, you can download it today and enjoy your media (including Live TV!) on the big (or small) screen.

- Anthony

Tags:releaseappleiosapple-tv
Read more
Newer entries
Older entries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/#__docusaurus_skipToContent_fallback

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients/all

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
Jellyfin MPV Shim
OfficialOpen Source

A cross-platform cast client for Jellyfin.

GitHub
Flathub (Linux)
GitHub Downloads
Jellyamp
Third PartyOpen Source

A desktop client for listening to music from a Jellyfin server.

GitHub
GitHub Downloads
Jellyfin Vue
Official BetaOpen Source

A modern web client for Jellyfin based on Vue

GitHub
Open in Browser
Docker
Preserve
Third PartyOpen Source

A music client inspired by players such as foobar2000 or Clementine.

GitLab
Open in Browser
GitLab Downloads
Sonixd
Third PartyOpen Source

A full-featured Subsonic/Jellyfin compatible desktop music player.

GitHub
Installation Guide
Supersonic
Third PartyOpen Source

A lightweight and full-featured desktop music player for self-hosted servers.

GitHub
Installation Guide
Feishin
Third PartyOpen Source

A full-featured Navidrome/Jellyfin compatible desktop music player.

GitHub
Open in Browser
GitHub Downloads
Tauon Music Box
Third PartyOpen Source

A modern streamlined music player for desktop with a minimal interface that's packed with features!

GitHub
Website
Flathub (Linux)
Installation Guide
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Kodi
OfficialOpen Source

A Kodi add-on that syncs metadata from selected Jellyfin libraries into the local Kodi database.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Swiftfin
Official BetaOpen Source

Swiftfin is a modern video client for Jellyfin. Redesigned in Swift to maximize direct play with the power of VLC and look native on all classes of Apple devices.

GitHub
App Store
Findroid
Third PartyOpen Source

A third-party Android application for Jellyfin that provides a native user interface to browse and play movies and series.

GitHub
IzzyOnDroid
Play Store
Gelli
Third PartyOpen Source

A native music player for Android devices with transcoding support, gapless playback, favorites, playlists, and many other features.

GitHub
GitHub Downloads
F-Droid
Finamp
Third PartyOpen Source

A third party app for music playback with support for offline mode/downloading songs.

GitHub
F-Droid
Play Store
App Store
Sailfin
Third PartyOpen Source

A Sailfish OS client for Jellyfin.

GitHub
OpenRepos
Yatse
Third PartyProprietary

A third party remote control for Jellyfin with support for Chromecast playback.

Website
Play Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Mopidy-Jellyfin
OfficialOpen Source

An official plugin for Mopidy that uses Jellyfin as a backend.

GitHub
Installation Guide
Jellyfin Plugin for Volumio
Third PartyOpen Source

A Volumio plugin for playing audio from one or more Jellyfin servers.

GitHub
Discord Music Bot for Jellyfin by manuel-rw
Third PartyOpen Source

A fork, based on the original bot by KGT1, that has been refactored and supports the Discord command system

GitHub
Installation Guide
Jellychord
Third PartyOpen Source

A modern Discord music bot for Jellyfin using slash commands, written in python.

GitHub
Jellycli
Third PartyOpen Source

A terminal player for Jellyfin, only for music at the moment.

GitHub
GitHub Downloads
jftui
Third PartyOpen Source

A terminal client for Jellyfin built as a REPL interface, that uses mpv for multimedia playback.

GitHub
Installation Guide
Web Scrobbler
Third PartyOpen Source

Web Scrobbler helps online music listeners to scrobble their playback history.

GitHub
Website
Installation Guide
JellyBook
Third PartyOpen Source

A cross platform mobile app for book & comic reading for Jellyfin.

GitHub
TestFlight
GitHub Downloads
Fintunes
Third PartyOpen Source

Mobile audio streaming app for Jellyfin

GitHub
Website
F-Droid
Play Store
App Store
Streamyfin
Third PartyOpen Source

A third-party client for iOS, iPadOS and Android with download capability

GitHub
Website
App Store
Play Store
Manet
Third PartyProprietary

A third-party music client for iOS and macOS

Website
App Store
Fladder
Third PartyOpen Source

A simple, cross-platform Jellyfin frontend built on top of Flutter.

GitHub
Play Store
Symfonium
Third PartyProprietary

An offline-first third-party music player that enhances your Jellyfin experience with streaming, syncing and full personalization

Website
Play Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/contribute/#__docusaurus_skipToContent_fallback

Skip to main content
How to Contribute

Jellyfin is a community project run by volunteers. We're always looking for additional help.

Find a way to contribute

If you are interested in helping the Jellyfin project, there are a few different ways to contribute depending on your skills and availability. Of course, simply using Jellyfin, finding issues, and reporting them, are a major help to our project, even if none of these apply to you!

Before contributing, please read over our Community Standards and Contributing Guide.

CodeTranslationsOther
Meet the people that bring you Jellyfin
Sponsors
DigitalOcean
JetBrains
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/contact/#__docusaurus_skipToContent_fallback

Skip to main content
Contact
Chat
Matrix
We primarily use Element to access the Matrix network. Find all the official rooms in the Jellyfin Space!
General Rooms
#jellyfin
#jellyfin-announce
#jellyfin-troubleshooting
#jellyfin-offtopic
#jellyfin-translate
Development Rooms
#jellyfin-dev
#jellyfin-dev-client
#jellyfin-dev-android
#jellyfin-dev-ios
#jellyfin-vue
#jellyfin-dev-roku
#jellyfin-dev-python
#jellyfin-ui-ux
#jellyfin-hwa-tool
Join the Jellyfin Space
Discord
The Jellyfin Discord server is bridged to the official Matrix rooms for convenience.
NOTE: Matrix is the preferred chat platform. Discord messages may be missed or delayed due to bridge instability.
Join the Discord Server
Other
Social
Forum
Join us on our Forum for release announcements, troubleshooting, and development discussions.
Jellyfin Forum
Mastodon
Follow us on Mastodon for release announcements and more, just like our Twitter account.
@jellyfin@mastodon.online
Twitter
Follow us on Twitter for release announcements and other updates, along with general musings.
@jellyfin
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/quick-start/#__docusaurus_skipToContent_fallback

Skip to main content
Quick Start
Quick Start

Install Jellyfin on your system with the installation method for your platform.

Edit the web configuration and adjust the options to fit your desired privacy level.

Our defaults sacrifice some absolute self-hosting for often requested features.
If this is concerning, please review the documentation and edit accordingly.

Browse to http://SERVER_IP:8096 to access the included web client.

Follow the initial setup wizard.

Libraries and users can always be added later from the dashboard.
Remember the username and password so you can login after the setup.

Secure the server with a method of your choice.

Create an SSL certificate and add it on the Networking page.
Put your server behind a reverse proxy.
Only allow local connections and refrain from forwarding any ports.

Enjoy your media!

Edit this page
Previous
Introduction
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/quick-start/windows

Skip to main content
Quick StartWindows
On this page
Windows Quick Start
Required Tools and Resources​
A Windows 10/11 PC
A user account with admin privileges
An internet connection
A public IP address
A text editor (Notepad will work but Notepad++ or VSCode is recommended)
A browser that isn't Internet Explorer
Before you begin​
Connect your PC with ethernet instead of Wi-Fi
Set your PC to never go to sleep automatically (Guide)
Show file extensions in Explorer (Guide)
Setup auto login for your user account if you haven't already (Guide)
Make your media files accessible on this computer by this user
Install latest updates (Guide)
Setup remote access (optional). Popular options include Teamviewer, AnyDesk, RustDesk, Google Remote Desktop and Parsec
Notes​
How to open a Terminal from current location in Explorer
Windows 10
Right click on blank space while holding down Shift
Click Open PowerShell window here
Windows 11
Right click on blank space
Click Open in Windows Terminal or Open in Terminal
Install Jellyfin​
Install​

Download installer exe and sha256sum from the official repo. The files to download are installer/jellyfin_x.y.z_windows-x64.exe.

Run and follow the installer. Select Basic Install when prompted. Do NOT select Install as a Service as it will break certain functions.

Close the installer after the install completes.

Installation Complete

Look for a Jellyfin icon in your system tray. If it isn't present, search for Jellyfin Tray App and run it. No windows will popup after running this application.

Jellyfin Tray App

Allow Firewall Access when Prompted

Windows Firewall Prompt

Open a browser and go to http://localhost:8096 to finish the setup process. Leave the Enable automatic port mapping option unchecked. Jellyfin's automatic port mapping feature uses UPnP, which can be a security risk and may not work on some networks. (Click here for more about UPnP and security)

Remote Access Setup Page

Hardware Acceleration​

Read the dedicated Hardware Acceleration page for how to configure hardware acceleration.

Reverse Proxy​

A reverse proxy is a server that sits in front of other services and forwards client requests to those services according to predefined rules. They are usually used to help increase security, performance and reliability. Some popular options are Apache, Caddy, Haproxy, Nginx and Traefik. We are using Caddy in this guide for its simplicity. Info on other reverse proxy solutions can be found at Running Jellyfin Behind a Reverse Proxy.

Router Settings​

Press Win + R, enter control and click OK to open Control Panel

Navigate to Network and Internet > Network and Sharing Center

Click on the Internet Connection under Connections

Click Details in the popup and note down the IPv4 Address and IPv4 Default Gateway values. The IPv4 Address is the LAN IP address of your Jellyfin server and the IPv4 Default Gateway is usually your Router.

go to https://ipv4.icanhazip.com and note down the IP address

Go to the IPv4 Default Gateway IP in a browser (for this example, http://192.168.50.1/) and Login to your router. If you do not have the credentials, look for them on the bottom of your router or online with the model number of your router

Most Routers will show a WAN IP in the index. Check if the WAN IP matches the IP you noted down in step 5. If it doesn't, you do not have a routable IP address. In this case, you should stop following this guide and look for other options for remote access.

ASUS Router Settings Page

Assign your Jellyfin host a static local IP. The option is usually under LAN and named DHCP Server or DHCP. If you assign a different IP than what it currently has, you may need to reconnect the internet of this PC for settings to apply properly. In this case, I am assigning 192.168.50.142 to my PC.

Find Port Forwarding settings in your router. This setting is usually under WAN, Firewall, Security or NATand usually named Port Forwarding or Virtual Server. Port Trigger is NOT the setting you are looking for.

Forward ports 80 and 443 to the IP you assigned previously

Install Caddy​

Go to the official Caddy server download page

Choose Windows amd64 for the platform and click download. Leave the standard features checkbox checked. You do NOT need any extra features.

Create a new folder under C:\Program Files and name it caddy. Confirm the operation if prompted.

move the downloaded exe file to the folder and rename it to caddy.exe. Confirm the operation if prompted.

go to This PC in Explorer, right click on blank space and click on properties

Click Advanced System Settings. it will be after Device Specifications on Windows 11, or in the left sidebar on Windows 10

Click on Environment Variables in the popup and doubleclick on Path under the User variables for user in the second popup

Click on New in the popup and enter C:\Program Files\caddy, then click OK on the bottom right. DO NOT change the other entries as messing with them can result in broken programs and/or a broken system.

Click on OK for the other 2 popups to save and apply settings

Reboot to make sure settings apply properly

Test if HTTP is routable​

Open a terminal and run caddy respond --body test --listen :80

Allow access if prompted by Windows Firewall

Your IP may have changed while making the changes in your router. Go to https://ipv4.icanhazip.com to get your current public IP address

Attempt to access http://<your IP here> using another internet connection on another device such as your mobile data. For this case, the IP has changed to 1.171.xxx.xxx so I will be accessing http://1.171.xxx.xxx using my mobile data on my phone.

The page should look like the picture below. If it doesn't look this way or fails to connect, your ISP may be blocking incoming http connections or your IP is not routable. In this case, you should stop following this guide and look for other remote access options.

Screenshot taken on iOS using Safari

Press Ctrl + C in the terminal to exit Caddy, then close the terminal.

DDNS​

Login to DuckDNS on the top right at the DuckDNS homepage

Add a new domain in the middle. I am using jellyfintest12345.duckdns.org for this example but you can use anything as long as it hasn't been taken

Download the latest Windows C# client zip from its Github releases page

Create a new subfolder under C:\Program Files and name it duckdns

Unzip the downloaded file and move the DuckDNS.exe into the folder. Confirm the operation if prompted.

Run DuckDNS.exe

Enter the Domain you just created and the Token from your DuckDNS dashboard, change interval to 5m and click on OK

Make sure that no errors appeared and there is a yellow duck in your system tray. If the duck is red, check your configuration.

hit Win + R, enter taskschd.msc and click OK

Click on Create basic task on the right panel.

Enter a descriptive Name and a description, one that you can identify in the future and click next

Choose When I log on for the Task Trigger and click Next

Choose Start a program for the Action

Enter C:\Program Files\duckdns\DuckDNS.exe in the Program/script field

Check Open the Properties dialog checkbox and click Finish

Go to the Settings Pane in the dialog and uncheck the Stop the task if it runs longer than checkbox, then click OK

Reverse Proxy with Caddy​

Create a text file named Caddyfile (Remove the .txt suffix) on your computer. This file is temporary and can be anywhere. You will be asked to confirm if you want to change the file extension, click Yes.

Open the file in a text editor and paste in config from below depending on your needs. Replace <your (sub)domain here> with the domain you just created with DuckDNS.

if you want your jellyfin instance behind the bare domain (subdomain.example.com / jellyfin.example.com):

<your (sub)domain here>

reverse_proxy 127.0.0.1:8096


if you want your jellyfin instance under a subpath (example.com/jellyfin):

<your (sub)domain here>

redir /jellyfin /jellyfin/
reverse_proxy /jellyfin/* 127.0.0.1:8096


Save the file and close the text editor

Copy this file to your caddy folder (the one you created in the Install Caddy section which should be C:\Program Files\caddy). Confirm the operation if prompted.

If you have chosen to use a subpath for Jellyfin, go to your Jellyfin dashboard (open http://localhost:8096 on your server, click the 3 bars on the top right then select Dashboard) and go to the Networking menu on the side bar. Then enter the subpath you have chosen to use and save. Then restart the Jellyfin server (Stop then start the server from the system tray icon)

Open a terminal in the caddy folder and run caddy run. If there are errors, check your configs and try again. Keep this window running.

Go to http://<your (sub)domain here> or http://<your (sub)domain here>/jellyfin in a browser to test if it is working. You should be able to see the Jellyfin Login Page.

hit Win + R, enter taskschd.msc and click OK

Click on Create basic task on the right panel.

Enter a descriptive Name and a description, one that you can identify in the future and click next

Choose When I log on for the Task Trigger and click Next

Choose Start a program for the Action

Enter "C:\Program Files\caddy\caddy.exe" in the Program/script field, run in the arguments field and "C:\Program Files\caddy" in the Start in field, then click Next. The parenthesis are required as the path contains a space.

Check Open the Properties dialog checkbox and click Finish

Go to the Settings Pane in the dialog and uncheck the Stop the task if it runs longer than checkbox, then click OK

Reboot to test configuration. There will be a Terminal window open after bootup. This is normal. Keep this window open.

External References​
Official Caddy Documentation
Edit this page
Previous
Quick Start
Next
Getting Help
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/quick-start/#

Skip to main content
Quick Start
Quick Start

Install Jellyfin on your system with the installation method for your platform.

Edit the web configuration and adjust the options to fit your desired privacy level.

Our defaults sacrifice some absolute self-hosting for often requested features.
If this is concerning, please review the documentation and edit accordingly.

Browse to http://SERVER_IP:8096 to access the included web client.

Follow the initial setup wizard.

Libraries and users can always be added later from the dashboard.
Remember the username and password so you can login after the setup.

Secure the server with a method of your choice.

Create an SSL certificate and add it on the Networking page.
Put your server behind a reverse proxy.
Only allow local connections and refrain from forwarding any ports.

Enjoy your media!

Edit this page
Previous
Introduction
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/web-config

Skip to main content
ClientsJellyfin Web Configuration
On this page
Jellyfin Web Configuration
Editing​

The Jellyfin Web default interface can be configured using the config.json file in the webroot. Where this is and how to edit it depends on the installation method.

We recommend obtaining the stable or the unstable default version of the file to pre-populate your configuration directory before starting Jellyfin for the first time; unlike most other components of this directory, it will not be created automatically.

Debian/Ubuntu/Fedora/CentOS Packages​

The configuration can be found at /usr/share/jellyfin/web/config.json. This file is registered as a configuration file by the Debian packages, and any changes to the defaults will be handled by apt on upgrade.

Docker​

Overriding the default config.json can be done with an additional volume parameter to your docker run command, e.g.

--volume /path/to/config/web-config.json:/jellyfin/jellyfin-web/config.json

CAUTION

If the config.json file doesn't exist on the first run, Docker will map it to a directory instead of a file, which won't work.

Customizations​
Custom Menu Links​

Jellyfin 10.8 adds the ability to specify custom links to be inserted in the navigation menu via the config.json file. Links are configured with a name, url, and optional icon property. The icon is specified using the name of an icon from the Material Design Icons used in Jellyfin Web. By default, the "link" icon will be used.

"menuLinks": [
    {
        "name": "Custom Link",
        "url": "https://jellyfin.org"
    },
    {
        "name": "Custom Link w. Custom Icon",
        "icon": "attach_money",
        "url": "https://demo.jellyfin.org/stable"
    }
]

Privacy-focused changes​

Our default settings for the Jellyfin Web config.json file include some features that privacy-focused or completely-offline users may want to disable. Each option is detailed below.

Google Chromecast​

By default, Jellyfin Web includes Chromecast-from-browser support. This requires downloading files from Google servers to support this functionality.

To disable it, edit config.json and remove the line:

"plugins/chromecastPlayer/plugin"


in the plugins section. Be sure to remove the last comma from the line above if this is the last line in the list.

YouTube Trailers​

By default, Jellyfin Web includes functionality to auto-load movie trailers from YouTube. This functionality is disabled within Jellyfin by default, but the resources are included in the Web config to make enabling the feature easy.

To disable it, edit config.json and remove the line:

"plugins/youtubePlayer/plugin"


in the plugins section.

Edit this page
Previous
Mopidy
Next
Testing
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#running-jellyfin-behind-a-reverse-proxy

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/getting-help/#__docusaurus_skipToContent_fallback

Skip to main content
Getting Help
Getting Help

If you are having trouble using or configuring Jellyfin, there are several ways to get help. Please ensure you read our Community Standards before interacting with the Jellyfin community. See the Contact page for a comprehensive list of places to find community discussion and support.

Edit this page
Previous
Windows
Next
FAQ
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/getting-help/#

Skip to main content
Getting Help
Getting Help

If you are having trouble using or configuring Jellyfin, there are several ways to get help. Please ensure you read our Community Standards before interacting with the Jellyfin community. See the Contact page for a comprehensive list of places to find community discussion and support.

Edit this page
Previous
Windows
Next
FAQ
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#__docusaurus_skipToContent_fallback

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#why-fork-emby-why-did-you-start-this-project

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#why-dont-you-support-my-favorite-client-or-feature

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#when-will-release-x-happen-when-will-feature-x-be-available

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#im-having-problems-with-jellyfin-how-do-i-get-help

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#why-is-my-media-not-showing-up-in-jellyfin

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/media/movies

Skip to main content
Server GuideMediaMovies
On this page
Movies

Movies must be in the library root directory or in a subfolder for the individual films. Not following this structure may lead to misidentification or missing media. Subfolders allow for organization of metadata and images. Adding the year at the end in parentheses will yield the best results when scraping metadata.

TIP

In order to help with identifying a movie, Jellyfin can make use of media provider identifiers. This can be specified in your movie's file or folder name, for example: Film (2010) [imdbid-tt0106145].mp4 or Film (2018) [tmdbid-65567]

Movies
├── Film (1990).mp4
├── Film (1994).mp4
├── Film (2008)
│   └── Film.mkv
└── Film (2010)
    ├── Film-cd1.avi
    └── Film-cd2.avi

ISO FILES AND OTHER DISC IMAGES

While Jellyfin should work with .iso files and other images, it is explicitly unsupported. It is recommended that those be extracted to BDMV or VIDEO_TS folders or remuxed to .mkv video files. Regardless of the source format, menus are not supported and only the main titles will be played.

Multiple Versions of a Movie​

Multiple versions of a movie can be stored together and presented as a single title. Place each movie version in the same folder and give each version a name with the folder name as a prefix as seen below.

NOTE

The prefix has to be an exact match of the folder name for the versioning to work, that includes any media provider identifiers such as [imdbid-tt12801262]

Movies
├── Best_Movie_Ever (2019)
│   ├── Best_Movie_Ever (2019) - 1080P.mp4
│   ├── Best_Movie_Ever (2019) - 720P.mp4
│   └── Best_Movie_Ever (2019) - Directors Cut.mp4
└── Movie (2021) [imdbid-tt12801262]
    ├── Movie (2021) [imdbid-tt12801262] - 2160p.mp4
    ├── Movie (2021) [imdbid-tt12801262] - 1080p.mp4
    └── Movie (2021) [imdbid-tt12801262] - Directors Cut.mp4


To distinguish between versions, each filename needs to have a space, hyphen, space, and then a label. Labels are not predetermined and can be made up by the user.

NOTE

The hyphen is required. Periods, commas and other characters are not supported.

Additionally, labels can be placed between brackets with the same result as seen below.

Movies
└── Best_Movie_Ever (2019)
    ├── Best_Movie_Ever (2019) - [1080P].mp4
    ├── Best_Movie_Ever (2019) - [720P].mp4
    └── Best_Movie_Ever (2019) - [Directors Cut].mp4


If labels are not added to the end of filenames, as shown above, each file will be treated as a unique movie and not a version of the same movie.

Order of Versions​

Movie versions are presented in an alphabetically sorted list. An exception applies to resolution names, which are sorted in descending order from highest to lowest resolution. A version name qualifies as a resolution name when ending with either a p or an i.

NOTE

The first movie version in the list is the one selected by default.

Examples of Sorting​
1080p, 2160p, 360p, 480p, 720p → 2160p, 1080p, 720p, 480p, 360p
Extended Cut, Cinematic Cut, Director's Cut → Cinematic Cut, Director's Cut, Extended Cut
NOTE

To group media manually, long-click or right-click media to highlight then select additional media to merge. Use the new bar that appears to 'Group Versions'.

Movies Split Across Multiple Parts​

Movies that are split into multiple files can be stacked together if named correctly. Files should be named as follows:

Movie Name (2010)/Movie Name<separator><parttype><separator><partnumber>.mkv

The separator is optional between <parttype> and <partnumber>. <partnumber> can be any number, or the letters a-d.

Supported part types are:

cd
dvd
part
pt
disc
disk

Supported separators are:

(space)
. (period)
- (dash)
_ (underscore)
NOTE

This does not work in conjunction with multiple versions or merging.

Movie Extras​

Movie extras can include deleted scenes, interviews, and other various things that you would want to include alongside your movie. Jellyfin supports several different methods of adding these files.

Extras Folders​

One of the cleanest ways of adding extras is to place them in subfolders within your movie folder.

Supported folder types are:

behind the scenes
deleted scenes
interviews
scenes
samples
shorts
featurettes
clips
other - Generic catch all for extras of an unknown type.
extras - Generic catch all for extras of an unknown type.
trailers
Movies
└── Best_Movie_Ever (2019)
    ├── Best_Movie_Ever (2019) - 1080P.mp4
    ├── Best_Movie_Ever (2019) - 720P.mp4
    ├── Best_Movie_Ever (2019) - Directors Cut.mp4
    ├── behind the scenes
    │   ├── Making of the Best Movie Ever.mp4
    │   └── Finding the right score.mp4
    ├── interviews
    │   └── Interview with the Director.mp4
    └── extras
        └── Home recreation.mp4

File Name​

Some types of extras support a special option if you only have a single of that type. These options are to name the filename a specific word when stored in the same folder as the movie.

Supported filenames are:

trailer
sample
theme - Audio file of the theme song
Movies
└── Best_Movie_Ever (2019)
    ├── Best_Movie_Ever (2019) - 1080P.mp4
    ├── sample.mp4
    ├── theme.mp3
    └── trailer.mp4

File Suffix​

If you would rather keep everything in a single folder, you can append special suffixes to the filename which Jellyfin picks up and uses to identify the file as an extra. Note that, with a few noted exceptions, these suffixes DO NOT contain any spaces.

-trailer
.trailer
_trailer
trailer - This is a space followed by the word trailer
-sample
.sample
_sample
sample - This is a space followed by the word sample
-scene
-clip
-interview
-behindthescenes
-deleted
-deletedscene
-featurette
-short
-other
-extra
Movies
└── Best_Movie_Ever (2019)
    ├── Best_Movie_Ever (2019) - 1080P.mp4
    ├── That clip that I want everyone to see-clip.mp4
    ├── Release Trailer-trailer.mp4
    ├── Preview Trailer.trailer.avi
    ├── Release Trailer 2_trailer.avi
    ├── Teaser.sample.mp4
    ├── Favorite Scene-scene.mp4
    ├── The Best Ever-clip.mp4
    ├── Making of The Best Movie Ever-behindthescenes.mp4
    ├── Not the best scene-deleted.mp4
    ├── Theme Song Music Video-featurette.mp4
    └── Art of the Best Movie Ever-short.mp4

3D Movies​

The parser can recognize 3D files automatically if the proper tags are added to the file name, or you can manually assign the 3D attribute to a file using Jellyfin's metadata editor to select the correct 3D format. The metadata editor is accessible from the context menu on each item.

To identify 3D content by filename, the first tag is 3D, which must be combined with one of the following tags to specify the specific 3D format:

hsbs = half side by side
fsbs = full side by side
htab = half top and bottom
ftab = full top and bottom
mvc = Multiview Video Coding

The tags are case-insensitive and must be surrounded by either a space, hyphen -, dot . or underscore _.

Awesome 3D Movie (2022).3D.FTAB.mp4

Awesome 3D Movie (2022)_3D_htab.mp4

Awesome 3D Movie (2022)-3d-hsbs.mp4


Additionally, 3D filename tags can be combined with the grouping functionality documented above. All text before the hyphen must match the folder name.

Movies
└── Awesome 3D Movie (2022)
    ├── Awesome 3D Movie (2022) - 3D_FTAB.mp4
    ├── Awesome 3D Movie (2022) - 3D.hsbs.mp4
    └── Awesome 3D Movie (2022) - 1080p.mp4

NOTE

There is no tag for anaglyph 3D content.

Images​

The following files may also be embedded into video containers that support it (such as mkv) and will be read out by the Embedded Image Extractor if enabled as an Image Extractor on the library configuration page.

Poster​
folder.ext
poster.ext
cover.ext
default.ext
movie.ext

Examples:

Movie (2010)/poster.jpg

Backdrop​
backdrop.ext
fanart.ext
background.ext
art.ext
extrafanart/*.ext

Examples:

Movie (2010)/fanart.jpg for the first backdrop image

Movie (2010)/extrafanart/fanart1.jpg, Movie (2010)/extrafanart/fanart2.jpg, etc for additional backdrop images

Logo​
logo.ext
clearlogo.ext

Example:

Movie (2010)/logo.png

Edit this page
Previous
Internet radio
Next
Music
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/media/shows

Skip to main content
Server GuideMediaShows
On this page
Shows

The most common naming scheme for shows is categorizing the files by series and then season. Another common method is simply using series folders, especially for shows that are organized by air date and those without seasons. Adding the year at the end in parentheses will yield the best results when scraping metadata.

TIP

In order to help with identifying a series, Jellyfin can make use of media provider identifiers. This can be specified in your show's folder name, for example: Series Name (2018) [tmdbid-65567] or Series Name (2018) [tvdbid-65567] (imdbid is not supported for shows)

Shows
├── Series Name A (2010)
│   ├── Season 00
│   │   ├── Some Special.mkv
│   │   ├── Series Name A S00E01.mkv
│   │   └── Series Name A S00E02.mkv
│   ├── Season 01
│   │   ├── Series Name A S01E01-E02.mkv
│   │   ├── Series Name A S01E03.mkv
│   │   └── Series Name A S01E04.mkv
│   └── Season 02
│       ├── Series Name A S02E01.mkv
│       ├── Series Name A S02E02.mkv
│       ├── Series Name A S02E03 Part 1.mkv
│       └── Series Name A S02E03 Part 2.mkv
└── Series Name B (2018)
    ├── Season 01
    |   ├── Series Name B S01E01.mkv
    |   └── Series Name B S01E02.mkv
    └── Season 02
        ├── Series Name B S02E01-E02.mkv
        └── Series Name B S02E03.mkv

NOTE

Avoid special characters such as * in M*A*S*H, use MASH instead.

NOTE

Do not mix episodes inside season folders and episodes on the Series root folder.

Do not abbreviate the Season folder with S01 or SE01 or alike.

NOTE

Season folders shouldn't contain the series name, otherwise Jellyfin can in certain cases (Stargate SG-1 due to the dash and one, for instance) misdetect your episodes and put them all under the same season.

Show Specials​

Show specials can be added in the Season 00 folder. If supported by your metadata provider those files will be matched. In case your metadata provider does not provide information about the special, it is recommended to use a name which describes the content of the special instead of naming it Series Name S00Exy.mkv. This is done to avoid wrong metadata being pulled for the special and to provide a proper presentation.

NOTE

Episode numbering for specials may vary from metadata provider to metadata provider.

Specials can also be shown within a season if so desired. This can be helpful when they are part of a continued storyline during the season. This requires 2 settings:

The option Display specials within their series they aired in under Dashboard -> Library -> Display must be enabled
The season and episode they aired before/after must be set within the metadata.
These can be set in the Metadata editor or in an NFO using the airsbefore_season, airsafter_season, and airsbefore_episode tags.
When the Airs before season field is set but Airs before episode is not set, the special will play at the start of the specified season, before the first episode.
The Airs before season can also be combined with the Airs before episode field to insert it as a mid-season special before the specified episode. For example, if Airs before season is set to 2 and Airs before episode is set to 7, the special will play between S02E06 and S02E07.
With Airs after series, set the Special will be shown (and played) at the end of the specified Season. This will take priority over the Airs before season/episode fields if they are set.
When multiple specials have the same position, they will play in the order in which they are stored in the specials season. For example, if S00E01 and S00E03 both have Airs before season set to 3 and Airs before episode set to 7, the order the content will play in is: S03E06 → S00E01 → S00E03 → S03E07.

Note that this will show them in both the Specials season, as well as the season specified.

Episodes Split Across Multiple Parts​

Episodes that are split into multiple files can be stacked together if named correctly. Files should be named as follows:

Series Name (2010)/Season 02/Series Name (2010) S02E01<separator><parttype><separator><partnumber>.mkv

The separator is optional between <parttype> and <partnumber>. <partnumber> can be any number, or the letters a-d.

Supported part types are:

cd
dvd
part
pt
disc
disk

Supported separators are:

(space)
. (period)
- (dash)
_ (underscore)
Show Extras​

Show extras can include deleted scenes, interviews, and other various things that you would want to include alongside your show. Extras can be added at both the series and season level. Jellyfin supports several different methods of adding these files.

NOTE

Season level extras are only supported when season folders are used.

Extras Folders​

One of the cleanest ways of adding extras is to place them in subfolders within your show or season folder.

Supported folder types are:

behind the scenes
deleted scenes
interviews
scenes
samples
shorts
featurettes
clips
other - Generic catch all for extras of an unknown type.
extras - Generic catch all for extras of an unknown type.
trailers
Shows
└── Series Name (2010)
    ├── Season 01
    │   ├── Series Name S01E01.mkv
    │   ├── Series Name S01E02.mkv
    │   ├── featurettes
    │   │   └── Some Featurette.mkv
    │   └── interviews
    │       └── Interview with the Director.mp4
    ├── Season 02
    │   ├── Series Name S02E01.mkv
    │   ├── Series Name S02E02.mkv
    │   └── behind the scenes
    │       └── Behind the Scenes.mp4
    └── extras
        └── Fantastic Extra.mkv

File Suffix​

If you would rather keep everything in a single folder, you can append special suffixes to the filename which Jellyfin picks up and uses to identify the file as an extra. Unless noted, these suffixes DO NOT contain any spaces.

-trailer
.trailer
_trailer
trailer - This is a space followed by the word trailer
-scene
-clip
-interview
-behindthescenes
-deleted
-deletedscene
-featurette
-short
-other
-extra
Shows
└── Series Name (2010)
    ├── Season 01
    │   ├── Series Name S01E01.mkv
    │   ├── Series Name S01E02.mkv
    │   ├── Alternate Ending-deleted.mkv
    │   └── Interview with the Director-interview.mp4
    └── Fantastic Extra-extra.mkv
    └── Making the Show-featurette.mp4

NOTE

Trailers support a special option if you only have a single file of that type per series/season. The option is to name the filename 'trailer.ext' when stored in the same folder as the series or season.

3D Videos​

Please refer to '3D Movies' in the movies section

Images​

Posters, Backdrops, and Logos may also be embedded into video containers that support it (such as mkv) and will be read out by the Embedded Image Extractor if enabled as an Image Extractor on the library configuration page.

Poster​
folder.ext
poster.ext
cover.ext
default.ext
show.ext

Examples:

Series Name:
Series Name (2010)/poster.jpg
Season posters:
Numbered seasons:
Series Name (2010)/Season 01/cover.jpg
Series Name (2010)/season1-poster.jpg
Specials:
Series Name (2010)/season-specials-poster.jpg
Backdrop​
backdrop.ext
fanart.ext
background.ext
art.ext
extrafanart/*.ext

Examples:

Series Name (2010)/fanart.jpg for the first backdrop image

Series Name (2010)/extrafanart/fanart1.jpg, Series Name (2010)/extrafanart/fanart2.jpg, etc for additional backdrop images

Banner​
banner.ext

Example:

Series Name (2010)/banner.jpg

Thumb​
thumb.ext
landscape.ext

Examples:

Series Name (2010)/landscape.jpg

Series Name (2010)/Season 01/episode filename-thumb.jpg for the thumbnail of an episode named "episode filename.mkv"

Logo​
logo.ext
clearlogo.ext

Example:

Series Name (2010)/logo.png

Other​
Theme Videos​
backdrops/*

Example:

Series Name (2010)/backdrops/S1Intro.ext

Theme Music​
theme.ext
theme-music/*

Examples:

Series Name (2010)/theme.ext

Series Name (2010)/theme-music/intro-song.ext

Edit this page
Previous
Music
Next
Metadata
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/media/music

Skip to main content
Server GuideMediaMusic
On this page
Music

Albums are organized in folders, with one folder containing one and only one album. Jellyfin does not care how you organize albums together, as long as each album is contained within one folder. Filenames generally do not matter since the info will be scraped from the embedded metadata of the tracks. If no other metadata was found, Jellyfin uses the file names as track titles.

Music
├── Some Artist
│   ├── Album A
│   │   ├── Song 1.flac
│   │   ├── Song 2.flac
│   │   └── Song 3.flac
│   └── Album B
│       ├── Track 1.m4a
│       ├── Track 2.m4a
│       └── Track 3.m4a
└── Album X
    ├── Whatever You.mp3
    ├── Like To.mp3
    ├── Name Your.mp3
    └── Music Files.mp3


While Jellyfin generally doesn't use the file names for identification, file names containing special characters can still cause problems. The following characters are known to cause issues: <, >, :, ", /, \, |, ?, *

Discs​

Albums with several discs are identified by the metadata tags with the disc number and total discs fields. Place the tracks for all discs in one folder.

Album
├── Disc 1 Track 1.ogg
├── Disc 1 Track 2.ogg
├── Disc 2 Track 1.ogg
├── Disc 3 Track 1.ogg
├── Disc 3 Track 2.ogg
└── Disc 3 Track 3.ogg

Lyrics​

Lyrics must be contained in the same folder and match the filename for their corresponding item. For example: The lyric file for 01 Death Eternal.mp3 must be 01 Death Eternal.lrc, 01 Death Eternal.elrc or 01 Death Eternal.txt.

Music
└── Some Artist
    └── Album A
        ├── Song 1.flac
        ├── Song 1.lrc
        ├── Song 2.flac
        ├── Song 2.lrc
        ├── Song 3.flac
        └── Song 3.lrc


Lyrics can be jumped to within Jellyfin's UI, meaning it's possible for a user to click on any line and jump straight to the corresponding timestamp where the line appears in the song. The lyrics file can be synchronised or unsynchronised. It can have some extra metadata, but won't be shown in the Jellyfin client.

Synchronized lyrics are interactive, enabling users to click on any line to jump directly to the corresponding timestamp in the song. You have the option to either manually synchronize the text, which can be time-consuming and may lack accuracy, or utilize lyrics synchronization software such as MiniLyrics. A synchronised lyrics file would likely look something like the following:
[ar: Some Artist]
[ti: Song 1]
[al: Album 1]
[by: Author]
[length: 2:57]
[00:10.89]Line 1
[00:14.58]Line 2
[00:16.78]Line 3
[00:21.03]Line 4
[00:24.86]Line 5
(...)

Unsynchronized lyrics are easier to implement, but will be harder for users to sing along. Such a file would look something like this:
Line 1
Line 2
Line 3
Line 4
Line 5
(...)

Images​

Images can come from a few different sources. For music, there are 3 image types, as shown in this image.

External images​

Images can be provided as external files within the media folders. When provided, they should be placed alongside the media files. In case they are provided, they will take precedence over other sources.

If a cover image is not provided, Jellyfin will fallback to the first track with an embedded album image. If no backdrop or logo types are available, Jellyfin will fallback to these images of the album artist instead.

Album
├── cover.jpg
├── backdrop.webp
├── logo.png
├── Track 1.wav
├── Track 2.wav
└── Track 3.wav

Type	Allowed Names
Primary	folder, poster, cover, default
Backdrop	backdrop, fanart, background, art, extrafanart
Logo	logo

Multiple backdrop images can be used to cycle through several over time. Simply append a number to the end of the filename directly after or after a hyphen.

File Extensions / Containers​

Jellyfin supports most common music formats, with some exceptions:

MP4 with only audio: .mp4 files won't be recognized as music. Please rename them to .m4a.
MKV / WebM with only audio: .mkv and .webm files won't be recognized as music. Please rename them to .mka.
WebA: .weba files aren't supported. Please rename them to .mka
.flac files with embedded WebP images or ID3 tags may fail to play in Chromium based browsers (Chrome, Edge, Opera, Brave etc.) or Firefox. Please enable Always remux FLAC audio files in the client settings if you encounter this issue.
Files with ID3v1 tags have a length limit of 30 bytes for most fields. Anything longer will be truncated. Please upgrade to ID3v2.4.
ALTERNATE CONTAINERS

Problematic files can be remuxed to .mka containers with ffmpeg with this command:

ffmpeg -i <Input File> -c:a copy <Output File>.mka


Do note that the metadata may be messed up and images might not carry over, so the metadata will have to be restored either manually or using another program.

Edit this page
Previous
Movies
Next
Shows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#how-can-i-contribute-to-this-project

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#how-do-i-request-a-new-feature

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/faq/#how-do-i-support-this-project

Skip to main content
FAQ
On this page
Frequently Asked Questions
Why fork Emby? Why did you start this project?​

We explain the rationale for our fork on our about page.

Why don't you support my favorite client or feature?​

Chances are, we would like to support it, but it has not been implemented yet. Jellyfin is an entirely volunteer-driven project, so until a developer is able and willing to implement a feature, it likely will not be done. We track community feature requests on our Fider instance, so please check that out, upvote the features you like, and add your own requests. Note that the Fider does not guarantee prioritization, but instead provides developers a way of seeing what features might be popular to decide whether to work on them or not. This does unfortunately mean that even highly-soughtafter features might not be implemented until someone both interested and able to work on them comes along. If you're a developer and are interested in helping out, please hack away and let us know on Matrix so we can help.

When will release {X} happen? When will feature {X} be available?​

We make releases only when the team feels that it is ready, to provide our users with the best and most stable experience we can. To that end, releases happen when we feel there has been sufficient testing without new issues being found. Releases are also subject to the availability of the people who manage the builds and publishes for different platforms. Please remember we are all volunteers and there are no fixed timelines to our releases.

I'm having problems with Jellyfin, how do I get help?​

Please see our getting help page for details on where to engage the community.

Why is my media not showing up in Jellyfin?​

This normally comes down to one of the following issues:

File permissions are not properly configured on your media.
Your media does not follow the organizational requirements for Jellyfin's scanner to properly identify media. (Valid organization schemes can be found in the documentation for Movies, Shows, Music, and others.) If it's not one of these, please consider asking for help as it might be a bug.
How can I contribute to this project?​

Please see our contributing guide page for details on how to get started. We are always looking for C# and frontend developers, mobile app developers, translators, and documentation writers to help!

How do I request a new feature?​

Please see our requesting features page for details in requesting a new feature in Jellyfin.

How do I support this project?​

All we can ask is you use Jellyfin, report any bugs, and tell your friends about us! Really, we're just people volunteering our time to help build a better media system, so joining the community is the best way to show your support. We do offer a donations page on OpenCollective, however please note that these funds are only used for infrastructure. All our developers are unpaid volunteers on principle.

Edit this page
Previous
Getting Help
Next
Installation
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/#__docusaurus_skipToContent_fallback

Skip to main content
Installation
Installation

The Jellyfin project and its contributors offer a number of pre-built binary packages to assist in getting Jellyfin up and running quickly on multiple systems.

CAUTION

FreeBSD and its derivatives, such as TrueNAS CORE, are NOT supported by Jellyfin due to .NET officially not being compatible with these platforms.

Even though there are builds available online for these platforms, they are unofficial and from a separate project. If you do encounter issues on these platforms, please ask for support in their respective support channels first.

TrueNAS SCALE is based on Linux and therefore officially supported. Please install the Jellyfin app from its app repository. This app is not officially maintained by the Jellyfin team, therefore please use the TrueNAS support channels for help first.

For info on selecting hardware for a Jellyfin server, please refer to the Hardware Selection Guide

📄️ Container

Install as a container using Docker, Podman and others.

📄️ Linux

Install on Linux.

📄️ Windows

Install on Windows.

📄️ TrueNAS SCALE

Install on TrueNAS SCALE.

📄️ Synology

Install on Synology NAS.

📄️ macOS

Install on macOS.

📄️ Building from source

Compile and run Jellyfin yourself.

Edit this page
Previous
FAQ
Next
Container
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/truenas

Skip to main content
InstallationTrueNAS SCALE
On this page
TrueNAS SCALE

Jellyfin can be installed on iX-systems' TrueNAS SCALE.

This document is written for TrueNAS SCALE v24.10.0 (Electric Eel) or higher.

Consider reviewing the TrueNAS Apps documentation if you have not previously configured applications on your system.

Note: TrueNAS CORE and TrueNAS SCALE are different. Jellyfin is not supported on TrueNAS CORE.
Introduction and Preparation​

TrueNAS SCALE lets you run apps using Docker.

There are two supported methods of installing Jellyfin on your TrueNAS SCALE server:

Custom App
Community 3rd Party App provided by ix-systems

Both methods use the official Jellyfin-provided Docker image. This document will cover both install methods.

You can configure environment variables at any time after deploying the application.

It is recommend to set the TrueNAS SCALE App system to a storage pool comprised of SSDs.

Datasets & Jellyfin​

The official Jellyfin Docker image internally creates the following necessary directories:

cache
config
cache/transcodes

If you use the community app, you can allow SCALE to create datasets for the directories Jellyfin requires automatically during app installation. You can also choose to create a static transcodes dataset or use temporary storage on the disk or in memory (system RAM) for transcoding.

Note that using RAM for transcodes can be a bad idea as transcodes can take up a lot of space. If there isn't enough memory available in RAM for a transcode, the transcode will fail. It is recommended that you place the transcode directory on a drive with a decent amount of free space to avoid this issue. Consider using an SSD instead of an HDD to avoid possible slowdowns.

You can also create your own custom datasets to use in the Storage Configuration section as host paths during installation.

You can organize datasets as one parent with two child datasets, for example /mnt/tank/jellyfin/config, /mnt/tank/jellyfin/cache, and so on. With Docker, you can organize these in any way as long as you mount them under the correct name to the Docker container.

It is recommended to set Jellyfin's config directory to an accessible dataset. This will make it easy to backup/restore your server.

It is also recommended to use datasets located on an SSD Storage Pool for Jellyfin's configuration and cache data.

Users & Permissions​

You can set the user and group that will run your container when setting up Jellyfin. If you want to run the application with a user or group other than the default apps (568) user and group, create them now.

Make sure your datasets have appropriate permissions set to allow the Jellyfin container user to access your datasets.

Installing as a Custom App​
Using YAML​

Go to SCALE's Apps section.

Click on the Discover Apps button on the top-right of the page. It will bring you to the community app store.

There, click on the 3-dot menu on the top-right and then on Install via YAML.

Note that you can also install a custom app using SCALE's guided app launcher GUI. Refer to the steps on installing the community app since the layout is largely the same.
If you go this route, your final Jellyfin container will only be editable through this GUI. If you want access to the Compose YAML editor afterwards, you need to launch your container with the YAML option.
You will need to pull Jellyfin's image onto your SCALE server depending on the setting you choose on the guided GUI.
For the Repository field, simply enter jellyfin/jellyfin. You then specify what Tag (version) you want to pull from the Docker Hub.
See this for more info on container images on SCALE

A tab will open from the right side of the page where you launch your custom app using a Docker Compose file.

Compose YAML File​

Here, give the custom app a name and write/paste the lines for your compose file.

See here for documentation on using Docker Compose with Jellyfin. Alternatively, here's a basic compose file where you should edit the volumes to use on your system, then copy & paste it into the editor to launch Jellyfin:

services:
  jellyfin:
    container_name: jellyfin
    image: ghcr.io/jellyfin/jellyfin:latest
    user: '568:568'
    # group_add:
    # - '107'
    # devices:
    # - /dev/dri/renderD128:/dev/dri/renderD128
    # - /dev/dri/card0:/dev/dri/card0
    environment:
      - TZ=America/Los_Angeles
    network_mode: bridge
    ports:
      - 8096:8096/tcp
    # cpus: '8' # optional
    # mem_limit: 16G # optional
    restart: unless-stopped
    volumes:
      - /mnt/path/to/config:/config:rw
      - /mnt/path/to/cache:/cache:rw
      # rw = read & write
      # ro = read only

Remember to add your media datasets as extra volumes on your compose file so that the container can access them.
The user & group you set are only to run the container. They are not used to create a Jellyfin account.
Make sure your spacing is correct for each option. Compose files use spacing to parse the options correctly.
You can determine the time zone identifier for you region here.
Note that lines with # in front indicate a comment. They will not apply until you remove it.
Uncomment the group_add and devices options if you have a GPU and want to use hardware acceleration.
If you have an NVIDIA GPU, please read this.
Unless you set the container to run as root, you need to add the render group ID to the container with group_add.
In case the render group's ID is not 107 on all SCALE servers by default, go to your system shell and run the following command to get your render group's ID: cat /etc/group | grep render
Jellyfin's auto discovery ports should also be configured if possible.
See more info here
Docker Compose Options

Once installed, you'll be taken back to the main application screen. Here, you can see the status of your Jellyfin container, as well as edit the existing compose file you used to launch it to add more to the container.

TrueNAS SCALE's YAML interface will re-arrange and remove any comments on your YAML file.

Once the status icon of your Jellyfin container turns to the green Running icon on the UI, your Jellyfin server is up and running.

You can now reach your Jellyfin server by going to a web browser on your local network and using your SCALE server's IP address along the port number you set for Jellyfin (default HTTP port is 8096). If you used the previous example compose file and your server's IP address is 192.168.1.10, you would use this URL on a browser: http://192.168.1.10:8096

Once you navigate to your server on a web browser, you're now in your Jellyfin server. Proceed with the first-time setup wizard to setup your Jellyfin server. You can also refer to the Jellyfin docs for further assistance.

Adding the Jellyfin Logo to Custom Apps​

When you install a custom app on SCALE, it will have a generic SCALE icon instead of the app's official logo.

You can add Jellyfin's logo back by doing the following:

Go to the system shell
Switch to root access with the following command (to gain access to the Docker App folder): sudo -i
Navigate to the location app config location. The directory should be under the name you gave the Jellyfin container when editing the YAML file: cd /mnt/.ix-apps/app_configs/jellyfin/
Open the metadata.yaml file with VIM to edit it: vim metadata.yaml
Enter Insert Mode by typing i, then go to the end of host_mounts: [] and hit the ENTER key to make a new line.
Add enough (two) spaces to get the text cursor in-line with the metadata options. Write or paste this new line there: icon: https://media.sys.truenas.net/apps/jellyfin/icons/icon.svg
Press ESC to exit Insert Mode, then type :wq and hit ENTER to save & quit.
Notes:
You can paste to the SCALE Shell using SHIFT + INSERT
You can force quit without saving in vim by hitting ESC, then typing :q!

The file should now look like this:

custom_app: true
human_version: 1.0.0_custom
metadata:
  app_version: custom
  capabilities: []
  description: This is a custom app where user can use his/her own docker compose
    file for deploying services
  home: ''
  host_mounts: []
  icon: https://media.sys.truenas.net/apps/jellyfin/icons/icon.svg
  maintainers: []
  name: custom-app
  run_as_context: []
  sources: []
  title: Custom App
  train: stable
  version: 1.0.0
migrated: false
notes: null
portals: {}
version: 1.0.0


After this, just go to the custom app in the Apps page. Open the Edit option in Application Info, then click on Save at the bottom. This will update the custom app's icon with Jellyfin's logo.

Installing with the SCALE Community App​

To install the Jellyfin application, go to Apps, click Discover Apps, either begin typing Jellyfin into the search field or scroll down to locate the Jellyfin application widget. You might need to click "Refresh Catalog" if no Jellyfin app is showing in the results.

Click on the widget to open the Jellyfin application details screen.

Click Install to open the Jellyfin application configuration screen.

Application configuration settings are presented in several sections, each explained below. To find specific fields, click in the Search Input Fields search field, scroll down to a particular section or click on the section heading on the navigation area in the upper-right corner.

Application Name Settings​

Accept the default value or enter a name in the Application Name field. In most cases, use the default name, but if adding a second deployment of the application you must change this name.

Accept the default version number in Version. When a new version becomes available, the application has an update badge. The Installed Applications screen shows the option to update applications.

Jellyfin Configuration Settings​

You can accept the defaults in the Jellyfin Configuration settings, or enter the settings you want to use.

You can enter a Published Server URL for use in UDP autodiscovery, or leave it blank.

If needed, click Add to define Additional Environment Variables, see Configuration for options.

User and Group Settings​

You can accept the default value of 568 (apps) in User ID and Group ID or define your own.

This user and group is used for running the Jellyfin container only and cannot be used to log in to the Jellyfin web interface. Create an admin user in the Jellyfin initial setup wizard to access the UI.

Networking Settings​

Select Host Network under Network Configuration if using DLNA, to bind network configuration to the host network settings. Otherwise, leave Host Network unselected.

You can accept the default port number in WebUI Port, which is 30013.

You can change this to port 8096. Most Jellyfin clients have built-in scanning features that look for port 8096 by default.

Refer to the TrueNAS default port list for a list of assigned port numbers.

Storage Settings​

Jellyfin requires three app storage datasets for:

Jellyfin Config Storage
Jellyfin Cache Storage
Jellyfin Transcodes Storage

Solid state storage is recommended for config, cache, and transcode storage. Do not use datasets located on spinning disks where your media storage/libraries are found for these datasets to avoid slowdowns.

You can install Jellyfin using the default setting ixVolume (dataset created automatically by the system) or use the host path option with datasets created before installing the app.

Select Host Path (Path that already exists on the system) to browse to and select the datasets.

For Jellyfin Transcodes Storage, in Type, select:

Host Path (Path that already exists on the system) to use an existing dataset created on the system
ixVolume (dataset created automatically by the system) to let SCALE create the dataset
Temporary (Temporary directory created on the disk) to use a temporary storage directory created somewhere on the storage pool you set for the Apps system
tmpfs (Temporary directory created on the RAM) to use a temporary storage directory created on the system RAM

It is recommended to link the transcode directory to a location with decent amount of available storage. Transcodes can take up a lot of space depending on the type of content that is being transcoded. If there's not enough storage here, you will run into playback issues when a transcode doesn't have space to continue being written out.

Mounting Additional Storage​

Click Add next to Additional Storage to add the media library storage path(s) on your system.

Select Host Path (Path that already exists on the system) or SMB/CIFS Share (Mounts a volume to a SMB share) in Type. You can select iXvolume (Dataset created automatically by the system) to create a new library dataset, but this is not recommended.

Mounting an SMB share allows data synchronization between the share and the app. The SMB share mount does not include ACL protections at this time. Permissions are currently limited to the permissions of the user that mounted the share. Alternate data streams (metadata), finder colors tags, previews, resource forks, and MacOS metadata are stripped from the share along with filesystem permissions, but this functionality is undergoing active development and implementation planned for a future TrueNAS SCALE release.

Note that if you want to take advantage of Jellyfin's built-in feature of real-time media scanning, you need to mount your media directly with a Host Path as SMB connections do not support this feature.

For all types, enter a Mount Path to be used within the Jellyfin container.

For example, the local Host Path /mnt/tank/video/movies could be assigned the Mount Path /media/movies.
With this example, you would browse to /media/movies in Jellyfin to see the contents of /mnt/tank/video/movies on your SCALE server.
Additional Storage Fields
Resource Configuration Settings​

You can customize limits on the CPU and memory allocated to the container Jellyfin will reside in.

CPUs expects a value in number of threads to assign as a max CPU thread limit.
You should set this option to the number of threads your CPU contains.
Refer here for reasonable CPU limits based on your SCALE server's CPU
Memory (in MB) expects a value in megabytes.
The default is 4096 which means the container will be limited to 4GB of RAM usage.
To calculate a value in gigabytes, use this formula where X is a number in MB: X * 1024
Refer here for sensible RAM limits for your Jellyfin server
The max limit you can assign to either limit depends on your SCALE server's specs.

For the GPU Configuration, check the Passthrough available (non-NVIDIA) GPUs option if you need to pass a GPU device for hardware acceleration use with Jellyfin.

If you have an NVIDIA GPU, please read this.
Finalizing Install​

Click Install.

A container launches with root privileges to apply the correct permissions to the Jellyfin directories. Afterward, the Jellyfin container runs as a non-root user (default: 568). Configured storage directory ownership is changed if the parent directory does not match the configured user.

The system opens the Installed Applications screen with the Jellyfin app in the Deploying state. When the installation completes, it changes to Running.

Click the Web UI button on the Application Info widget to open the Jellyfin web initial setup wizard to set up your admin account and begin administering libraries.

Editing the Jellyfin Application​

Go to the Installed Applications screen and select Jellyfin from the list of installed applications. Click Edit on the Application Info widget to open the Edit Jellyfin screen. The settings on the edit screen are the same as on the install screen.

You cannot edit Storage Configuration paths after the initial app install if they have been automatically created by the system (ixVolume).
You can still modify existing Host Paths storage mounts and paths.

Click Update to save changes. TrueNAS automatically updates, recreates, and redeploys the Jellyfin container with the updated environment variables.

Volume Mount Info & Real-Time Jellyfin Logs​

You can access Jellyfin's real-time logs by going to the Workloads widget and clicking on the logs icon on the bottom-right.

If you didn't specify an external location to mount your config & cache directories, they will be automatically created somewhere on your system. To see the current location of these (and other mounts to the container), click the folder icon on the bottom-right as well in the Workloads widget.

Once opened, you will see a list of all mounts and their paths. You can use this info to navigate to them on your system shell. Note that you will need root (sudo) access to reach Docker-related directories on SCALE.

Managing Container Images​

If you want to see the exact images installed on your TrueNAS SCALE server, go to the main Apps page, then click on the Configuration button. On the dropdown menu, click on Manage Container Images. You will be brought to a new page where you will see a list of all installed Docker images.

You can also pull new images to use in the future.

You can choose to pull from Jellyfin's Docker Hub or GitHub Container Registry.

To pull from Docker Hub, use: jellyfin/jellyin
To pull from from GHCR, use: ghcr.io/jellyfin/jellyfin
You can check this blog post for more info about GHCR:
"Docker users: We now offer GitHub Container Registry (GHCR) as an alternative container registry in addition to Docker Hub. You can pull images from the new registry via URIs like ghcr.io/jellyfin/jellyfin:latest. Don't worry, we have no plans to drop Docker Hub as a container registry, but we feel providing both gives users more choice and flexibility."
Also check out this forum post about how Docker image tags can be used.

If you have a container using any of your images, SCALE should notify you of an available update to the image through its GUI provided you used the latest tag, or one of the other tags that doesn't point to a single release.

NVIDIA GPUs on SCALE (v24.10+)​
For users with an NVIDIA GPU, read the v24.10 Electric Eel release notes regarding your GPU:
"Starting in 24.10, TrueNAS does not include a default NVIDIA GPU driver and instead provides a simple NVIDIA driver download option in the web interface. This allows for driver updates between TrueNAS release versions."
"Users can enable driver installation from the Installed applications screen. Click Configure > Settings and select Install NVIDIA Drivers. This option is only available for users with a compatible NVIDIA GPU and no drivers installed or for users who have previously enabled the setting."
Edit this page
Previous
Windows
Next
Synology
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/synology

Skip to main content
InstallationSynology
Synology

For Synology, Jellyfin is installed using Docker.

Create the container.

Use Advanced Settings to add mount points to your media and config.

Host Mode is required for HdHR and DLNA. Use bridge mode if running multiple instances.

Browse to http://SERVER_IP:8096 to access the web client.

Edit this page
Previous
TrueNAS SCALE
Next
macOS
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/#

Skip to main content
Installation
Installation

The Jellyfin project and its contributors offer a number of pre-built binary packages to assist in getting Jellyfin up and running quickly on multiple systems.

CAUTION

FreeBSD and its derivatives, such as TrueNAS CORE, are NOT supported by Jellyfin due to .NET officially not being compatible with these platforms.

Even though there are builds available online for these platforms, they are unofficial and from a separate project. If you do encounter issues on these platforms, please ask for support in their respective support channels first.

TrueNAS SCALE is based on Linux and therefore officially supported. Please install the Jellyfin app from its app repository. This app is not officially maintained by the Jellyfin team, therefore please use the TrueNAS support channels for help first.

For info on selecting hardware for a Jellyfin server, please refer to the Hardware Selection Guide

📄️ Container

Install as a container using Docker, Podman and others.

📄️ Linux

Install on Linux.

📄️ Windows

Install on Windows.

📄️ TrueNAS SCALE

Install on TrueNAS SCALE.

📄️ Synology

Install on Synology NAS.

📄️ macOS

Install on macOS.

📄️ Building from source

Compile and run Jellyfin yourself.

Edit this page
Previous
FAQ
Next
Container
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/hardware-selection

Skip to main content
AdministrationHardware Selection
On this page
Selecting Appropriate Hardware

This page covers what you need to know in order to select appropriate hardware for a Jellyfin server and take full advantage of its features (e. g. hardware acceleration).

TL;DR​

Below is a list of recommended specs to run Jellyfin. Even though Jellyfin will work on even lower end hardware, the following specs are recommended for a good experience.

Shared Items​

Some component recommendations do not change regardless of the hardware configuration:

Storage: 100GB SSD for your OS, Jellyfin files and transcoding cache.1 Consider adding more on Windows 11, or if you have many large media files that need transcoding.
Networking: Gigabit Ethernet Adapter or faster, WiFi or Powerline not recommended.
Internet Connection: At least 20mbps upload bandwidth for remote access.2

1Your largest media file times the max number of concurrent streams all your users will consume can be used as a rule of thumb for the transcoding file size.
2If you have less than 100mbps of total upload bandwidth, a bandwidth limit of 70% of your upload speed for Jellyfin is recommended to avoid affecting normal internet usage. This option can be found in the dashboard.

Hardware Encoder Quality​

Different vendors have different hardware encoder implementations and produce different results. Usually, newer generations within the same vendor will provide better results. The following is a quick comparison on the quality between vendors on modern products.

Apple ≥ Intel ≥ Nvidia >>> AMD*

* This only represents the default Jellyfin settings. The quality may be different depending on your exact configuration.

Server with Integrated Graphics​

If you are not planning to use a dedicated graphics card, the following specs are recommended:

CPU: Intel Core i5-11400, Intel Pentium Gold G7400, Intel N100, Apple M series or newer (excluding Intel J/M/N/Y series up to 11th gen)
RAM: 8GB System RAM (Consider adding more on Windows 11)
Graphics: Intel UHD 710, Apple M series or newer

AMD is NOT recommended if you plan to use integrated graphics for Jellyfin.

CAUTION

Intel 7-10th gen CPUs have been removed from this list, since the toolkit for these generations has been deprecated by Intel. If you own 7-10th gen CPUs with integrated graphics, please continue to use them for Jellyfin, as they are still perfectly capable of performing the task. If you are making a purchase decision, please consider something else instead.

Server with Dedicated Graphics​

If you are planning to use a dedicated graphics card (including upgrading an old system with a dedicated GPU), the following specs are recommended:

CPU: Intel Core i5-2300， AMD FX-8100 or better (Geekbench 6 Multicore 1500 or better), CPU Vendor / Performance will NOT affect hardware encode speed or quality
RAM: 8GB (4GB should be enough for a server running Linux without a GUI)
Graphics: Intel Arc A series or newer, Nvidia GTX16/RTX20 series or newer (Excluding GTX1650), AMD is NOT recommended.

Intel Drivers are much easier to install on Linux, with many distributions including them by default. If you do not need CUDA for other applications, it is highly recommended that you stick with Intel Graphics on Linux.

Servers without GPUs​

Not having a GPU is NOT recommended for Jellyfin, as video transcoding on the CPU is very performance demanding. HDR to SDR tone-mapping can make the situation even worse. Depending on your configuration, you may end up in situations where a Ryzen 9 5950X cannot handle even a single video stream. Please read the section below for more details

Low Power Servers​

For users with expensive power or running servers on battery power:

Intel 12th gen or above N series platforms
Apple M Series mac mini
Rockchip RK3588 / RK3588S SBC (Advanced Users Only)
Potentially Problematic Hardware​

These hardware platforms might lead to a poor Jellyfin experience. Please be careful to avoid them when shopping for hardware.

Intel "Atom" CPUs: Intel J/M/N/Y series low power CPUs up to 11th gen use a different architecture than higher end parts, leading to subpar performance despite what their names might suggest. Please be careful about these parts when shopping for a system to run Jellyfin.
Prebuilt NAS devices: The software environment on most Prebuilt NAS devices often causes 3rd party software to be hard to install and not work properly. They also often have low end processors that are too slow for a good Jellyfin experience (Intel Atom, Realtek ARM CPUs etc.).
Most Single Board Computers (SBC): Most SBCs (Including Raspberry Pis and especially the Pi 5) are too slow to provide a good Jellyfin experience since they often lack proper support for hardware acceleration. If You really want to run Jellyfin on an SBC, please look at models based on the following platforms: Rockchip RK3588 / RK3588S, Intel Core, Intel 12th gen N series
AMD Graphics: AMD Graphics have poor encoder quality and poor driver support. This applies even on Linux.
Low end GPUs: Certain low end GPUs (eg. GT1030, RX6400) don't have hardware encoding available. These models can't be used for Jellyfin hardware acceleration.
Detailed Guide​
CPU​

The CPU will be responsible for many tasks, notably:

Transcoding Audio
Decoding video in unsupported codecs

Audio codecs are very lightweight and most CPUs should be able to handle them without issues (Ryzen 5950X FLAC -> AAC transcoding runs at ~110x real time). Please note that they will only use one core.

Video in unsupported codecs are usually older formats that are easier to decode. Assuming hardware acceleration is properly configured, any modern CPU with 4 threads should be able to handle the workload.

However, newer codecs can also require software decoding if there are no available hardware decoders. HEVC, VP9 and AV1 can be VERY demanding even on modern CPUs if hardware acceleration isn't available. This is why a hardware platform capable of HEVC 10bit hardware decoding is strongly recommended.

In our custom jellyfin-ffmpeg fork, the dav1d decoder is enabled, leading to faster software decoding compared to HEVC or VP9. However, it will still use significantly more resources compared to software decoding H.264 or older codecs. Since we have a more efficient AV1 software decoder, and AV1 media isn't common yet, you shouldn't worry about AV1 when shopping for hardware.

Integrated Graphics​

Integrated graphics can be useful for transcoding video. Please refer to the GPU section for a guide.

Resizable BAR​

Resizable Bar (ReBAR) is a PCI Express feature that optimizes access to PCIe devices. This feature requires support from both the platform and the device. Intel 10th gen or above and AMD Ryzen 3000 Series or above have support for this feature.

In BIOS settings of motherboards, it may also be called Smart Access Memory or Clever Access Memory

When using Intel ARC Graphics, Resizable BAR is recommended. Disabling it will result in a 10% reduction in transcoding performance. However, given how fast the media engine on Intel ARC is, this will not be a problem for the vast majority of users.

Software HDR to SDR Tone-mapping​

If there is no GPU available, the CPU can also be used to tone-map HDR content to SDR. This can be very demanding on the CPU, therefore a GPU is ALWAYS recommended. When using software tone-mapping, a software encoder will always be used. Tone-mapping 4K 60fps Dolby Vision content to 4K 60fps H264 SDR requires a Ryzen 9 5950X for faster than real time transcoding. If you would like to output in H265 or AV1, you may end up in situations where no current desktop CPUs have enough performance.

System Memory (RAM)​

As a general rule of thumb, at least 8GB is recommended for most configurations. For a Linux server running without a GUI, 4GB should be enough.

It is recommended to add more memory on Windows 11 due to the OS being heavier.

Graphics Cards (GPUs)​

With modern systems, the media engines are usually located on the GPUs. Therefore, the available hardware acceleration options are determined by the choice of GPU.

Encoder Quality: Apple ≥ Intel ≥ Nvidia >>> AMD*

* This only represents the default Jellyfin settings. The quality may be different depending on your exact configuration.

Intel is always recommended on non-apple hardware for the following reasons:

Intel provides a good quality encoder, slightly better than Nvidia and significantly better than AMD.
Intel drivers and the compute environment is much easier to setup than both Nvidia and AMD

AMD is not recommended because of poor quality H.264 and H.265(HEVC) output, as well as being hard to setup the compute environment. While AMD has significantly improved AV1 encoder quality, you are still more likely to transcode to H.264 or H.265 than to AV1 due to compatibility.

A list of common codecs can be found here

The following is a list of video codecs Jellyfin supports transcoding to:

H.264 (Most common transcode target)
H.265 (Limited support by clients)
AV1 (New in 10.9, supported by most modern browsers)

For decoding support, the more codecs the better. However, there are only a few codecs that media is commonly available in. The most important one to look for is HEVC 10bit decoding support, as it can be very demanding on the CPU to decode.

Intel Graphics​

Please refer to this table for supported codecs.

Intel CPUs with a model description that ends with F don't have integrated graphics. These are intended to be used with a dedicated graphics card. Please beware if you intend to use Intel integrated graphics.

If you are planning to use Linux with Intel 12/13th Gen integrated graphics or ARC, these GPUs only work on Linux Kernel 6.2 or newer. Please check your distribution to make sure it has a supported Linux Kernel version. Please read Known Intel limitations on Linux for more info.

CAUTION

Intel 10th gen and older integrated graphics are losing support for QSV on Linux due to the SDK for these platforms being deprecated by Intel. If you own 7-10th gen CPUs with integrated graphics, please continue to use them for Jellyfin. If you are making a purchase decision, please choose a newer CPU if you plan on using Intel integrated graphics.

Nvidia Graphics​

Please refer to this table for supported codecs.

Certain low end cards (e.g. GT 1030) don't have encoding hardware. Please be careful when choosing a GPU.

AMD Graphics​

AMD graphics is not recommended for Jellyfin, but the information is still provided for convenience. Please refer to this article for supported codecs.

Certain low end cards (e.g. RX 6400, RX 6500) don't have encoding hardware. Please be careful when choosing a GPU.

Many AMD CPUs don't have integrated graphics. These are intended to be used with a dedicated graphics card.

For Ryzen 1000 ~ 5000 Series, desktop CPUs with a model description that ends with G have integrated graphics while other desktop CPUs do NOT. For Ryzen 7000 Series, desktop CPUs with a model description that ends with F do NOT have integrated graphics while others do.

Please check the product page of your CPU for more info.

Apple Silicon​

Supported codecs are listed below:

Codec	M1, M2 Family	M3 Family
H.264 8bit	✅	✅
H.264 10bit	🔶	🔶
H.265 8bit	✅	✅
H.265 10bit	✅	✅
VP9 8bit	🔶	🔶
VP9 10bit	🔶	🔶
AV1	❌	❌1

✅ = Encode + Decode, 🔶 = Decode Only, ❌ = Not Supported.

1 Although the hardware does support AV1 decoding, ffmpeg does not support it yet.

CAUTION

No Apple Silicon media engine drivers currently exist for non-macOS operating systems. You will NOT be able to use hardware acceleration if you are running Asahi Linux.

Rockchip VPU​

Currently only the VPU on RK3588/3588S SoC is recommended. It can handle most common video codecs, including AV1 decode.

Supported codecs are listed below:

Codec	RK3588/3588S
MPEG1/2/4 8bit	🔶
VC1 8bit	❌
H.264 8bit	✅
H.264 10bit	🔶
H.265 8bit	✅
H.265 10bit	🔶
VP8 8bit	🔶
VP9 8bit	🔶
VP9 10bit	🔶
AV1	🔶

✅ = Encode + Decode, 🔶 = Decode Only, ❌ = Not Supported.

Storage​

There are two general types of storage that can be used on a Jellyfin server. Media libraries and Jellyfin files require different performance characteristics.

Media Storage​

Anything with higher sequential access speed than bitrate of media will work. This storage can be a network share or a cloud storage service mounted on the Jellyfin host if desired.

Jellyfin Files​

Jellyfin files will see lots of random access, therefore SSDs are recommended for Jellyfin files. AVOID mechanical drives that use SMR (Shingled Magnetic Recording) as they will result in a VERY poor experience.

Networking​

Networking is for connecting your Jellyfin server to other devices. It is recommended that the server be connected to the internet via Ethernet cables. Wi-Fi or Powerline solutions are NOT recommended.

Edit this page
Previous
Rockchip VPU
Next
Migrating
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#__docusaurus_skipToContent_fallback

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/apache

Skip to main content
NetworkingApache
On this page
Apache
Apache HTTP Server Project​

"The Apache HTTP Server Project is an effort to develop and maintain an open-source HTTP server for modern operating systems including UNIX and Windows. The goal of this project is to provide a secure, efficient and extensible server that provides HTTP services in sync with the current HTTP standards."

<VirtualHost *:80>
    ServerName DOMAIN_NAME

    # Comment to prevent HTTP to HTTPS redirect
    Redirect permanent / https://DOMAIN_NAME/

    ErrorLog /var/log/apache2/DOMAIN_NAME-error.log
    CustomLog /var/log/apache2/DOMAIN_NAME-access.log combined
</VirtualHost>

# If you are not using a SSL certificate, replace the 'redirect'
# line above with all lines below starting with 'Proxy'
<IfModule mod_ssl.c>
<VirtualHost *:443>
    ServerName DOMAIN_NAME
    # This folder exists just for certbot (You may have to create it, chown and chmod it to give apache permission to read it)
    DocumentRoot /var/www/html/jellyfin/public_html

    ProxyPreserveHost On

    # Letsencrypt's certbot will place a file in this folder when updating/verifying certs
    # This line will tell apache to not to use the proxy for this folder.
    ProxyPass "/.well-known/" "!"

    # Tell Jellyfin to forward requests that came from TLS connections
    RequestHeader set X-Forwarded-Proto "https"
    RequestHeader set X-Forwarded-Port "443"

    ProxyPass "/socket" "ws://SERVER_IP_ADDRESS:8096/socket"
    ProxyPassReverse "/socket" "ws://SERVER_IP_ADDRESS:8096/socket"

    ProxyPass "/" "http://SERVER_IP_ADDRESS:8096/"
    ProxyPassReverse "/" "http://SERVER_IP_ADDRESS:8096/"

    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/DOMAIN_NAME/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/DOMAIN_NAME/privkey.pem
    Protocols h2 http/1.1

    # Enable only strong encryption ciphers and prefer versions with Forward Secrecy
    SSLCipherSuite HIGH:RC4-SHA:AES128-SHA:!aNULL:!MD5
    SSLHonorCipherOrder on

    # Disable insecure SSL and TLS versions
    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1

    ErrorLog /var/log/apache2/DOMAIN_NAME-error.log
    CustomLog /var/log/apache2/DOMAIN_NAME-access.log combined
</VirtualHost>
</IfModule>


If you encouter errors, you may have to enable mod_proxy, mod_ssl, proxy_wstunnel, http2, headers and remoteip support manually.

sudo a2enmod proxy proxy_http ssl proxy_wstunnel remoteip http2 headers

Apache with Subpath (example.org/jellyfin)​

When connecting to server from a client application, enter http(s)://DOMAIN_NAME/jellyfin in the address field.

Set the base URL field in the Jellyfin server. This can be done by navigating to the Admin Dashboard -> Networking -> Base URL in the web client. Fill in this box with /jellyfin and click Save. The server will need to be restarted before this change takes effect.

CAUTION

HTTP is insecure. The following configuration is provided for ease of use only. If you are planning on exposing your server over the Internet you should setup HTTPS. Let's Encrypt can provide free TLS certificates which can be installed easily via certbot.

The following configuration can be saved in /etc/httpd/conf/extra/jellyfin.conf and included in your vhost.

# Jellyfin hosted on http(s)://DOMAIN_NAME/jellyfin
<Location /jellyfin/socket>
    ProxyPreserveHost On
    ProxyPass "ws://127.0.0.1:8096/jellyfin/socket"
    ProxyPassReverse "ws://127.0.0.1:8096/jellyfin/socket"
</Location>
<Location /jellyfin>
    ProxyPass "http://127.0.0.1:8096/jellyfin"
    ProxyPassReverse "http://127.0.0.1:8096/jellyfin"
</Location>

Edit this page
Previous
Networking
Next
Caddy
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/caddy

Skip to main content
NetworkingCaddy
On this page
Caddy

"Caddy, sometimes clarified as the Caddy web server, is an open source, HTTP/2-enabled web server written in Go. It uses the Go standard library for its HTTP functionality." - Wikipedia

You can reverse proxy to Jellyfin either with or without a config file, and either method offers automatic HTTPS if you want to use your public domain name.

If you want HTTPS, make sure your domain name's A/AAAA records are pointed at your public IP address.

If you aren't familiar with Caddy yet, check out its Getting Started guide.

CAUTION

There are a some guides that have a Caddyfile which includes a tls section with the DNS provider's API key as shown in the following example.

example.com {
    reverse_proxy 127.0.0.1:8096

    tls {

        dns <DNS Provider> <API Token>

    }

}


Please proceed with caution when using this option:

This will NOT automatically update your DNS records if you have a dynamic IP.
This is NOT required for automatic HTTPS to work in most cases.
Misconfiguration can lead to compromised domains and/or accounts.
API keys should only be granted the least permissions required for the application to function.

Please read the Let's Encrypt documentation for more info.

One-liners​

The easiest way to reverse proxy to Jellyfin is with the reverse-proxy command:

caddy reverse-proxy --from :5001 --to 127.0.0.1:8096


That is a simple but production-ready plaintext HTTP reverse proxy.

If you have:

permission to bind to low ports, and
a public domain name's DNS records pointed at your machine,

then you can serve over HTTPS just as easily:

caddy reverse-proxy --from example.com --to 127.0.0.1:8096


You will see Caddy provision a TLS certificate for your site and if it succeeds, you can then access your Jellyfin server over HTTPS with your domain name.

Caddyfile​

If you want to use a config file, create a file called Caddyfile for the configuration. The first reverse-proxy command above is equivalent to the following options.

:5001

reverse_proxy 127.0.0.1:8096


To get HTTPS, simply change the first line to your domain name.

example.com

reverse_proxy 127.0.0.1:8096

Subpath​

You can serve Jellyfin only at a particular base path and not proxy all other requests.

To do this, first configure Jellyfin to use a base path. If you already have access to the web interface, go to Admin > Networking and enter a path like /jellyfin in the Base URL field. If not, you may instead go to <Configuration Directory>/network.xml and modify the value of <BaseUrl> according to your needs. For information on the directory location, please consult the configuration documentation. You might have to restart the Jellyfin server for this to take effect. Then simply give the reverse_proxy directive a path matcher. The path should be the same as the Base URL you entered into Jellyfin's settings. The following example is for a server that is accessible at example.com/jellyfin.

example.com

redir /jellyfin /jellyfin/
reverse_proxy /jellyfin/* 127.0.0.1:8096


With that config, Caddy will only proxy requests that start with /jellyfin/. Note the trailing slash - that is optional, but recommended.

Edit this page
Previous
Apache
Next
DLNA
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/dlna

Skip to main content
NetworkingDLNA
On this page
DLNA
DLNA​

DLNA is based on uPnP. DLNA will send a broadcast signal from Jellyfin. This broadcast is limited to Jellyfin's current subnet. If you are using docker, the network should use Host Mode, otherwise the broadcast signal will only be sent in the bridged network inside of docker.

If DLNA fails to bind properly, the message [ERR] Failed to bind to port 1900: "Address already in use". DLNA will be unavailable should appear in the logs.

Setting Alive message interval (seconds) to 30 seconds also appears to help discovery for some clients.

If a base URL is set, try removing it and restarting the server.

DLNA Logging​

Use these entries in logging.default.json to turn on DLNA debug logs.

{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Warning",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning",
        "Jellyfin.Plugin.Dlna": "Debug"
      }
    }
  }
}

Edit this page
Previous
Caddy
Next
fail2ban
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/fail2ban

Skip to main content
Networkingfail2ban
On this page
fail2ban
Fail2ban​

Fail2ban is an intrusion prevention software framework that protects computer servers from brute-force attacks. Fail2ban operates by monitoring log files (e.g. /var/log/auth.log, /var/log/apache/access.log, etc.) for selected entries and running scripts based on their content.

Jellyfin produces logs that can be monitored by Fail2ban to prevent brute-force attacks on your machine.

Requirements​
Jellyfin remotely accessible
Fail2ban installed and running
Knowing where the logs for Jellyfin are stored: by default /var/log/jellyfin/ for desktop and /config/log/ for docker containers.
Step one: create the jail​

You need to create a jail for Fail2ban. If you're on Ubuntu and use nano as editor, run:

sudoedit /etc/fail2ban/jail.d/jellyfin.local


Add this to the new file, replacing /path_to_logs with the path to the log files above, e.g. /var/log/jellyfin/:

[jellyfin]

backend = auto
enabled = true
port = 80,443
protocol = tcp
filter = jellyfin
maxretry = 3
bantime = 86400
findtime = 43200
logpath = /path_to_logs/jellyfin*.log


Save and exit nano.

Note:

If Jellyfin is running in a docker container, add the following to the jellyfin.local file:

action = iptables-allports[name=jellyfin, chain=DOCKER-USER]


If you're running Jellyfin on a non-standard port, then change the port from 80,443 to the relevant port say 8096,8920

Step two: create the filter​

The filter contains a set of rules which Fail2ban will use to identify a failed authentication attempt. Create the filter by running:

sudoedit /etc/fail2ban/filter.d/jellyfin.conf


Paste:

[Definition]
failregex = ^.*Authentication request for .* has been denied \(IP: "<ADDR>"\)\.


Save and exit, then reload Fail2ban:

sudo systemctl restart fail2ban


Check fail2ban is running:

sudo systemctl status fail2ban

Step three: test​

Assuming you've at least one failed authentication attempt, you can test this new jail with fail2ban-regex:

sudo fail2ban-regex /path_to_logs/*.log /etc/fail2ban/filter.d/jellyfin.conf --print-all-matched

Advanced Fail2Ban Setup: Forwarding and Managing Bans on an Upstream Proxy Server​

To enhance security, Fail2Ban can manage IP bans on an upstream reverse proxy server instead of directly on the Jellyfin server. This setup allows you to block malicious IPs closer to your network’s entry point, potentially benefiting other services using the same proxy.

This guide offers a configuration for setting up Fail2Ban to manage IP bans on an upstream reverse proxy server using Dynamic Chains, where each Fail2Ban jail creates and manages its own iptables chain on the upstream server.

Assumptions​
Fail2Ban is installed on your local server (where Jellyfin is running).
iptables is configured on the upstream server.
Step one: Set Up SSH Key-Based Authentication​

Ensure the Fail2Ban server can SSH into the upstream server without needing a password. This is crucial for automating the IP ban/unban process.

Replace <upstream-server-ip> with the actual IP address of your upstream server.

Generate SSH Key (if not already done):

ssh-keygen -t rsa -b 4096 -f /root/.ssh/id_rsa


Copy the SSH Key to the Upstream Server:

ssh-copy-id -i /root/.ssh/id_rsa.pub root@<upstream-server-ip>


Test SSH Access:

Ensure the SSH connection works without needing a password:

ssh -i /root/.ssh/id_rsa root@<upstream-server-ip>

Step two: Configure Fail2Ban for Dynamic Chains​

Create the Fail2Ban Action File:

On the Fail2Ban server, create a new action file:

sudo nano /etc/fail2ban/action.d/proxy-iptables-dynamic.conf


And add the Following Configuration, which will dynamically create, manage, and remove iptables chains on the upstream server per jail:

Remember to replace <upstream-server-ip> with the actual IP address of your upstream server.

[Definition]

# Option: actionban
# 1. Create the chain if it doesn't exist
# 2. Add the banned IP to the dynamic chain based on the jail name
# 3. Log the event
actionban = ssh -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@<upstream-server-ip> \
                'iptables -N f2b-<name> 2>/dev/null || true; \
                 iptables -C INPUT -j f2b-<name> 2>/dev/null || iptables -I INPUT -j f2b-<name>; \
                 iptables -I f2b-<name> 1 -s <ip> -j DROP' && \
                 echo "Banned <ip> from jail <name> via upstream proxy" >> /var/log/fail2ban.log

# Option: actionunban
# 1. Remove the banned IP from the dynamic chain
# 2. Remove the chain if it becomes empty (cleanup)
# 3. Log the event
actionunban = ssh -i /root/.ssh/id_rsa -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@<upstream-server-ip> \
                'iptables -D f2b-<name> -s <ip> -j DROP; \
                 if ! iptables -L f2b-<name> | grep -q "DROP"; then \
                     iptables -D INPUT -j f2b-<name>; \
                     iptables -F f2b-<name>; \
                     iptables -X f2b-<name>; \
                 fi' && \
                 echo "Unbanned <ip> from jail <name> via upstream proxy and cleaned up chain if empty" >> /var/log/fail2ban.log


After making chaneges, save and close the file.

Update Fail2Ban Jails to Use the Dynamic Chain Action:

Open your jail configuration file, usually located at /etc/fail2ban/jail.local:

sudo nano /etc/fail2ban/jail.local


And for each jail you want to manage via the upstream proxy, add or modify the action line to use the proxy-iptables-dynamic action. Here’s an example configuration for two jails:

[jellyfin]
enabled  = true
filter   = jellyfin
logpath  = /path/to/jellyfin/log
maxretry = 3
bantime  = 3600
action   = proxy-iptables-dynamic

[nginx-http-auth]
enabled  = true
filter   = nginx-http-auth
logpath  = /var/log/nginx/error.log
maxretry = 5
bantime  = 3600
action   = proxy-iptables-dynamic


After making chaneges, save and close the file.

Step three: Add proxy IPs to Jellyfin​

Get Proxy IPs

Since you're using a proxy server, we need Jellyfin to output the correct IPs in logs for fail2ban to read.

Depending on your hosting setup, these IP ranges could be from internal Docker IPs, haproxy, or some other service.

Jellyfin accepts IPs with subnet masks such as 172.18.0.1/24. You'll need a comma-separated list of these.

Add Proxies to Jellyfin

Open your Jellyfin server's dashboard, go to Advanced -> Networking, and then scroll down to Known proxies.

Enter your comma-seperated list of proxy IP ranges. You'll need to reboot the Jellyfin server as indicated.

Step four: Restart Fail2Ban and Test the Setup​

Restart Fail2Ban:

After making the configuration changes, restart Fail2Ban to apply the new settings:

sudo systemctl restart fail2ban


Check Jail Status:

Verify the status of your jails to ensure they are running correctly:

sudo fail2ban-client status jellyfin


Test a Ban:

Trigger a ban by performing invalid login attempts or by manually banning an IP. For example:

sudo fail2ban-client set jellyfin banip 192.168.1.100


Verify on Upstream Server:

Check if the IP is banned in the corresponding jail's chain on the upstream server ('f2b-jail-name'):

ssh root@<upstream-server-ip> "iptables -L f2b-jellyfin"


Test Unbanning:

To test unbanning, manually unban the IP:

sudo fail2ban-client set jellyfin unbanip 192.168.1.100


Verify Unban:

Verify that the IP is removed from the corresponding jail's chain ('f2b-jail-name'):

ssh root@<upstream-server-ip> "iptables -L f2b-jellyfin"

Step four: Monitor Logs​

Monitor the Fail2Ban log to ensure that actions are being executed properly:

tail -f /var/log/fail2ban.log


This log will display messages whenever an IP is banned or unbanned, helping you confirm that the configuration is working as expected.

Edit this page
Previous
DLNA
Next
HAProxy
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/haproxy

Skip to main content
NetworkingHAProxy
On this page
HAProxy
HAProxy​

"Haproxy is a free, open source software that provides a high availability load balancer and proxy server for TCP and HTTP-based applications that spreads requests across multiple servers.[1] It is written in C[2] and has a reputation for being fast and efficient (in terms of processor and memory usage)." - Wikipedia

frontend jellyfin_proxy
    bind *:80

# Note that haproxy requires you to concatenate the certificate and key into a single file
# Uncomment the appropriate lines after you have acquired a SSL Certificate
#
#  HAProxy <1.7
#    bind *:443 ssl crt /etc/ssl/DOMAIN_NAME.pem
#
#  HAProxy >1.8
#    bind *:443 ssl crt /etc/ssl/DOMAIN_NAME.pem alpn h2,http/1.1
#    redirect scheme https if !{ ssl_fc }
#
# Uncomment these lines to allow LetsEncrypt authentication
#    acl letsencrypt_auth path_beg /.well-known/acme-challenge/
#    use_backend letsencrypt if letsencrypt_auth

    acl jellyfin_server hdr(host) -i DOMAIN_NAME
    use_backend jellyfin if jellyfin_server

backend jellyfin
    option httpchk
    option forwardfor
    http-check send meth GET uri /health
    http-check expect string Healthy
    server jellyfin SERVER_IP_ADDRESS:8096

# Uncomment these lines to allow LetsEncrypt authentication
#
#backend letsencrypt
#    server letsencrypt 127.0.0.1:8888

Edit this page
Previous
fail2ban
Next
IPBan
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/ipban

Skip to main content
NetworkingIPBan
On this page
IPBan
IPBan​

IPBan is an intrusion prevention much like fail2ban, but multi-platform

Install with one command on windows (elevated powershell prompt)

[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/DigitalRuby/IPBan/master/IPBanCore/Windows/Scripts/install_latest.ps1'))


Config

<LogFile>

        <Source>Jellyfin</Source>
        <PathAndMask>
          C:/ProgramData/Jellyfin/Server/log/log_{year-local}{month-local}{day-local}.log
        </PathAndMask>
        <FailedLoginRegex>
          <![CDATA[
              Authentication\s+request\s+for\s+\S+?(?<username>[^\s]+)\S+\s+has\s+been\s+(?<log>denied)\s+\(IP:\s+"(?<ipaddress>[^,"\s]+)"\)
          ]]>
        </FailedLoginRegex>
        <SuccessfulLoginRegex>
          <![CDATA[
              Authentication\s+request\s+for\s+\S+?(?<username>[^\s]+)\S+\s+has\s+succeeded
          ]]>
        </SuccessfulLoginRegex>
        <PlatformRegex>Windows</PlatformRegex>
        <PingInterval>10000</PingInterval>
        <MaxFileSize>16777216</MaxFileSize>
        <FailedLoginThreshold>0</FailedLoginThreshold>

</LogFile>

Edit this page
Previous
HAProxy
Next
Let's Encrypt
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/letsencrypt

Skip to main content
NetworkingLet's Encrypt
On this page
Let's Encrypt
LetsEncrypt with Certbot​

LetsEncrypt is a service that provides free SSL/TLS certificates to users. Certbot is a client that makes this easy to accomplish and automate. In addition, it has plugins for Apache and Nginx that make automating certificate generation even easier.

Installation instructions for most Linux distributions can be found on the Certbot website.

Once the packages are installed, you're ready to generate a new certificate.

Apache​
Certbot Apache Plugin​

After installing Certbot and the Apache plugin, certificate generation is accomplished by with the following command.

certbot certonly --apache --noninteractive --agree-tos --email YOUR_EMAIL -d DOMAIN_NAME


Update the 'SSLCertificateFile' and 'SSLCertificateKeyFile' sections, then restart the service.

Add a job to cron so the certificate will be renewed automatically.

echo "0 0 * * *  root  certbot renew --quiet --no-self-upgrade --post-hook 'systemctl reload apache2'" | sudo tee -a /etc/cron.d/renew_certbot

Certbot Webroot​
Debian​

If the certbot apache plugin doesn't work with your config, use webroot instead.

Add the following to your <VirtualHost> section after configuring it a reverse proxy:

DocumentRoot /var/www/html/
#Do not pass the .well-known directory when using certbot and webroot
ProxyPass /.well-known !


Run the certbot command as root:

sudo certbot certonly --webroot -w /var/www/html --agree-tos --email YOUR_EMAIL -d DOMAIN_NAME

HAProxy​

HAProxy doesn't currently have a Certbot plugin. To get around this, run Certbot in standalone mode and proxy traffic through your network.

Enable the frontend and backend in the config above, and then run Certbot.

certbot certonly --standalone --preferred-challenges http-01 --http-01-port 8888 --noninteractive --agree-tos --email YOUR_EMAIL -d DOMAIN_NAME


The port can be changed to anything you like, but be sure that the HAProxy config and your Certbot command match.

HAProxy needs to have the certificate and key files concatenated into the same file to read it correctly. This can be accomplished with the following command.

cat /etc/letsencrypt/live/DOMAIN_NAME/fullchain.pem /etc/letsencrypt/live/DOMAIN_NAME/privkey.pem > /etc/ssl/DOMAIN_NAME.pem


Uncomment bind *:443 and the redirect section in the configuration, then reload the service.

Automatic Certificate Renewal​

Place the following script in /usr/local/bin/ to automatically update your SSL certificate.

SITE=DOMAIN_NAME

# move to the correct let's encrypt directory
cd /etc/letsencrypt/live/$SITE

# cat files to make combined .pem for haproxy
cat fullchain.pem privkey.pem > /etc/ssl/$SITE.pem

# reload haproxy
service haproxy reload


Make sure the script is executable.

chmod u+x /usr/local/bin/letsencrypt-renew.sh


Add a job to cron so the certificate will be renewed automatically.

@monthly /usr/bin/certbot renew --renew-hook "/usr/local/bin/letsencrypt-renew.sh" >> /var/log/letsencrypt-renewal.log

Nginx​

After installing Certbot and the Nginx plugin with sudo apt install certbot python3-certbot-nginx, generate the certificate.

Note: For Fedora Linux distributions (e.g. CentOS 8) use sudo dnf install python3-certbot-nginx to install the Nginx plugin.

sudo certbot --nginx --agree-tos --redirect --hsts --staple-ocsp --email YOUR_EMAIL -d DOMAIN_NAME


Add the --rsa-key-size 4096 parameter if you want a 4096 bit key instead.

Copy and paste the whole Nginx sample configuration file from above, changing the parameters according to your setup and uncommenting the lines.

Add a job to cron so the certificate will be renewed automatically.

echo "0 0 * * *  root  certbot renew --quiet --no-self-upgrade --post-hook 'systemctl reload nginx'" | sudo tee -a /etc/cron.d/renew_certbot

Let's Encrypt and Docker​

This section assumes that Jellyfin is running in a Docker container (on Linux). This section also assumes that you wish to run Let's Encrypt in a Docker container as well. The Linuxserver/swag Docker container has a built-in nginx webserver to handle the reverse proxy.

Linuxserver/letsencrypt is deprecated in favor of linuxserver/swag, see here for information on how to migrate if needed.

First, you need to determine a few things.

MAKE SURE YOU HAVE A CNAME FOR JELLYFIN WITH YOUR DNS PROVIDER BEFORE PROCEEDING
Where you wish to store information regarding Let's Encrypt (docker calls these "volumes")
What subdomain or subfolder you wish to use with Let's Encrypt (ex. jellyfin.example.com)
What timezone you wish to use
If you'll be using either HTTP-01 or DNS-01 for challenges.
What network you'll be running on (I'd recommend the default macvlan network called "br0")
What IP you want your container running on
What ports you'll be using (ex. 180 for port 80, and 1443 for 443)
Make sure ports 80 (if using http validation) and 443 are forwarded to the docker container from your router (instructions vary upon manufacturer)
What user will the container be running as (you can determine the PUID and PGID by running id (replacing "user" with the username of the user the container will be running as)

List of DNS Plugins here if using DNS-01 challenge.

Then, depending on what those settings are, you'll need to adjust the values below as needed.

For example, the docker create command from the LinuxServer team for the Swag Docker container:

docker create \
  --name=swag \
  --cap-add=NET_ADMIN \
  -e PUID=1000 \
  -e PGID=1000 \
  -e TZ=Europe/London \
  -e URL=example.com \
  -e SUBDOMAINS=www, \
  -e VALIDATION=http \
  -e DNSPLUGIN=cloudflare `#optional` \
  -e DUCKDNSTOKEN=<token> `#optional` \
  -e EMAIL=<e-mail> `#optional` \
  -e DHLEVEL=2048 `#optional` \
  -e ONLY_SUBDOMAINS=false `#optional` \
  -e EXTRA_DOMAINS=<extradomains> `#optional` \
  -e STAGING=false `#optional` \
  -p 443:443 \
  -p 80:80 `#optional` \
  -v </path/to/appdata/config>:/config \
  --restart unless-stopped \
  linuxserver/swag


Assuming I follow this template and adjust for my region, ports, and path, it would look like this (with personal information redacted):

docker create --name=swag --cap-add=NET_ADMIN -e PUID=1000 -e PGID=1000 -e TZ=America/Chicago -e URL=example.com -e SUBDOMAINS=jellyfin -e VALIDATION=http -e EMAIL=email@email.com -e DHLEVEL=2048 -e ONLY_SUBDOMAINS=false -e STAGING=false -p 443:443 -p 80:80 -v /path/to/appdata/swag/:/config --restart unless-stopped linuxserver/swag


This will pull down the linuxserver/letsencrypt container, and then create it with the variables specified. You'll then want to start the docker container with docker start swag. You can verify this is started by running docker ps, which will produce an output like this:

CONTAINER ID        IMAGE                     COMMAND             CREATED             STATUS              PORTS                                      NAMES
09346434b8ea        linuxserver/swag          "/init"             2 minutes ago       Up 5 seconds        0.0.0.0:80->80/tcp, 0.0.0.0:443->443/tcp   swag


At this point, navigate to what volume you selected (in my example, it's /mnt/swag). You'll then need to navigate to nginx/proxy-confs within that directory. If you list the contents of that directory, you'll see a lot of files.

The one we're interested in for jellyfin is jellyfin.subdomain.conf.sample (if using a subdomain) or jellyfin.subfolder.conf.sample (if using a subfolder). You'll want to copy the file needed, removing the .sample (ex. cp jellyfin.subdomain.conf.sample jellyfin.subdomain.conf). Open the file in your text editor of choice.

It should look like this (this file is jellyfin.subdomain.conf, although jellyfin.subfolder.conf looks very similar):

server {
    listen 443 ssl;
    listen [::]:443 ssl;

    server_name jellyfin.*;

    include /config/nginx/ssl.conf;

    client_max_body_size 0;

    location / {
        include /config/nginx/proxy.conf;
        resolver 127.0.0.11 valid=30s;
        set $upstream_app jellyfin;
        set $upstream_port 8096;
        set $upstream_proto http;
        proxy_pass $upstream_proto://$upstream_app:$upstream_port;

        proxy_set_header Range $http_range;
        proxy_set_header If-Range $http_if_range;
    }

    location ~ (/jellyfin)?/socket/ {
        include /config/nginx/proxy.conf;
        resolver 127.0.0.11 valid=30s;
        set $upstream_app jellyfin;
        set $upstream_port 8096;
        set $upstream_proto http;
        proxy_pass $upstream_proto://$upstream_app:$upstream_port;

        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $http_connection;
   }
}


The lines we're interested in is set $upstream_app jellyfin. Now, assuming Jellyfin and Let's Encrypt are on the same network within Docker, it should see it and start handling reverse proxy without much issue. If it doesn't however, you'll just need to change jellyfin in that line to whatever the IP of your Jellyfin server is. We'll also look at the line location ~ (/jellyfin)?/socket and add a slash after socket, so the line should look like this location ~ (/jellyfin)?/socket/.

Then, within Jellyfin settings (Dashboard -> Networking), scroll down to "Public HTTP port number" and "Public HTTPS port number", and make sure HTTP Port number is 8096, while HTTPS port number is 8920.

Restart your Let's Encrypt docker container by running docker restart swag, and then you can follow the logs with docker logs -f swag. Assuming everything works, you should see Server Ready at the very end of the logs. This tells you Lets Encrypt is running without issue.

Edit this page
Previous
IPBan
Next
Monitoring
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/nginx

Skip to main content
NetworkingNginx
On this page
Nginx
Nginx​

"Nginx (pronounced "engine X") is a web server which can also be used as a reverse proxy, load balancer, mail proxy and HTTP cache. The software was created by Igor Sysoev and first publicly released in 2004.[9] A company of the same name was founded in 2011 to provide support and Nginx plus paid software." - Wikipedia

Nginx from a subdomain (jellyfin.example.org)​

Create the file /etc/nginx/sites-available/jellyfin which will forward requests to Jellyfin. After you've finished, you will need to symlink this file to /etc/nginx/sites-enabled and then reload nginx. This example assumes you've already acquired certifications as documented in our Let's Encrypt guide.

Note that a server listening on http port 80 is required for the Certbot / Let's Encrypt certificate renewal process.

HTTPS config example​
server {
    listen 80;
    listen [::]:80;
    server_name jellyfin.example.org;

    # Uncomment to redirect HTTP to HTTPS
    return 301 https://$host$request_uri;
}

server {
    # Nginx versions prior to 1.25
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    # Nginx versions 1.25+
    #listen 443 ssl;
    #listen [::]:443 ssl;
    #http2 on;

    server_name jellyfin.example.org;

    ## The default `client_max_body_size` is 1M, this might not be enough for some posters, etc.
    client_max_body_size 20M;

    # Comment next line to allow TLSv1.0 and TLSv1.1 if you have very old clients
    ssl_protocols TLSv1.3 TLSv1.2;

    ssl_certificate /etc/letsencrypt/live/example.org/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.org/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/example.org/chain.pem;

    # use a variable to store the upstream proxy
    set $jellyfin 127.0.0.1;

    # Security / XSS Mitigation Headers
    add_header X-Content-Type-Options "nosniff";

    # Permissions policy. May cause issues with some clients
    add_header Permissions-Policy "accelerometer=(), ambient-light-sensor=(), battery=(), bluetooth=(), camera=(), clipboard-read=(), display-capture=(), document-domain=(), encrypted-media=(), gamepad=(), geolocation=(), gyroscope=(), hid=(), idle-detection=(), interest-cohort=(), keyboard-map=(), local-fonts=(), magnetometer=(), microphone=(), payment=(), publickey-credentials-get=(), serial=(), sync-xhr=(), usb=(), xr-spatial-tracking=()" always;

    # Content Security Policy
    # See: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP
    # Enforces https content and restricts JS/CSS to origin
    # External Javascript (such as cast_sender.js for Chromecast) must be whitelisted.
    add_header Content-Security-Policy "default-src https: data: blob: ; img-src 'self' https://* ; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' https://www.gstatic.com https://www.youtube.com blob:; worker-src 'self' blob:; connect-src 'self'; object-src 'none'; frame-ancestors 'self'; font-src 'self'";

    location / {
        # Proxy main Jellyfin traffic
        proxy_pass http://$jellyfin:8096;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Protocol $scheme;
        proxy_set_header X-Forwarded-Host $http_host;

        # Disable buffering when the nginx proxy gets very resource heavy upon streaming
        proxy_buffering off;
    }

    location /socket {
        # Proxy Jellyfin Websockets traffic
        proxy_pass http://$jellyfin:8096;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Protocol $scheme;
        proxy_set_header X-Forwarded-Host $http_host;
    }
}

Extra Nginx Configurations​
Censor sensitive information in logs​

This censors any api_key URL parameter from the logfile.

#Must be in HTTP block
log_format stripsecrets '$remote_addr $host - $remote_user [$time_local] '
                    '"$secretfilter" $status $body_bytes_sent '
                    '$request_length $request_time $upstream_response_time '
                    '"$http_referer" "$http_user_agent"';

map $request $secretfilter {
    ~*^(?<prefix1>.*[\?&]api_key=)([^&]*)(?<suffix1>.*)$  "${prefix1}***$suffix1";
    default                                               $request;
}

#Must be inside server block
#Insert into all servers where you want filtering (e.g HTTP + HTTPS block)
access_log /var/log/nginx/access.log stripsecrets;

Nginx Proxy Manager​

Nginx Proxy Manager provides an easy-to-use web GUI for Nginx.

Create a proxy host and point it to your Jellyfin server's IP address and http port (usually 8096)

Enable "Block Common Exploits", and "Websockets Support". Configure the access list if you intend to use them. Otherwise leave it on "publicly accessible".

In the "Advanced" tab, enter the following in "Custom Nginx Configuration". This is optional, but recommended if you intend to make Jellyfin accessible outside of your home.

    # Disable buffering when the nginx proxy gets very resource heavy upon streaming
    proxy_buffering off;


In the "SSL" tab, use the jellyfin.example.org certificate that you created with Nginx Proxy Manager and enable "Force SSL", "HTTP/2 Support", "HSTS Enabled", "HSTS Subdomains".

Edit this page
Previous
Monitoring
Next
Traefik v2.x
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/traefik

Skip to main content
NetworkingTraefik v2.x
On this page
Traefik v2.x
Traefik v2.x​

Traefik is a modern HTTP reverse proxy and load balancer that makes deploying microservices easy. Traefik integrates with your existing infrastructure components (ie: Docker) and generally configures itself dynamically as services are added or removed.

This document provides a complete configuration of Traefik v2.x and Jellyfin. It uses a number of files including a docker-compose.yml file, traefik.toml (your Traefik static configuration), traefik-provider.toml (a file-based provider for Traefik), traefik.log (an optional log file), .env (the environment which may be needed for your ACME/LetsEncrypt providers), and acme.json (the state data for your ACME/LetsEncrypt certificate). The files should all be created in the same directory. Alternately, alter the paths in the volume section of the traefik service in docker-compose.yml. You can optionally jam some of the traefik.toml file into labels for the traefik service in docker-compose.yml, however this method is much clearer and easier to comment.

NOTE

Ensure you enable some basic firewall or auth protection for Traefik or disable its dashboard. If you do not, your dashboard may be accessible from the internet. Pay attention to accessibility via IPv6, as even systems on an internal home network may be directly accessible over IPv6. See api-insecure for more details on securing the dashboard.

NOTE

Traefik has many options for the configuration of LetsEncrypt using your choice of challenges. If your server is accessible from the Internet via port 80 or 443, you can use the HTTP-01 or TLS-ALPN-01 challenges. If so, the certificatesresolvers.leresolver.acme.httpchallenge.entrypoint must be reachable by Let's Encrypt through port 80/443. You can also use a DNS-01 challenge via one of the available providers. Configuration is beyond the scope of this guide. This guide can use both HTTP-01 and DNS-01 by commenting or uncommenting the various blocks. You are most likely to use HTTP-01 unless you have full access to your DNS configuration. The configuration below uses RFC2136 (as set by certificatesresolvers.leresolver.acme.dnsChallenge of traefik.toml) and the variables for that provider are shown in the .env file as a formatting guide. See provider documentation and comments about configuration of your ACME provider of choice, or change the configuration to HTTP-01 in traefik.toml's comments.

The configuration below creates a Traefik v2.x installation with access at entryPoint ports 80 (labelled 'http'), 443 (labeled 'https'), and 9999 (labeled 'secure'). Unrelated to this Jellyfin configuration, it redirects all traffic from http (port 80) to https (port 443) to ensure all data is encrypted. As for Jellyfin, it makes the service accessible without a path on the secure entry point. This configuration is intended to be used as a starting point and some adaptation is likely required for your configuration. If you want Jellyfin to be accessible without using a port (using the default https port), simply change 'secure' to 'https' in docker-compose.yml where indicated and remove the ':9999' from the SSLHost parameter. If you want Jellyfin to be accessible with a path, simply add the PathPrefix (i.e. '/jellyfin') and see the note near the end of this document about configuring Jellyfin.

docker-compose.yml​
services:
  traefik:
    container_name: traefik
    image: traefik:chevrotin # the chevrotin tag refers to v2.2.x
    restart: unless-stopped
    volumes:
      # So that Traefik can listen to the Docker events (read-only)
      - /var/run/docker.sock:/var/run/docker.sock:ro
      # TOML Configuration with global options
      - /srv/traefik.toml:/traefik.toml
      # Configuration for the file provider (needed for host networking and default TLS Options)
      - /srv/traefik-provider.toml:/traefik-provider.toml
      # LetsEncrypt ACME Configuration
      - /srv/acme.json:/acme.json
      # Log File (optional)
      - /srv/traefik.log:/traefik.log
    ports:
      # The Web UI (enabled by --api.insecure=true in traefik.toml)
      - 8080:8080
      # The Available Ports (forward your router's incoming ports to the ports on the host)
      - 80:80
      - 443:443
      - 9999:9999
    env_file: .env

  jellyfin:
    image: jellyfin/jellyfin
    container_name: 'jellyfin'
    user: 1000:1000
    group_add: # by id as these may not exist within the container. Needed to provide permissions to the VAAPI Devices
      - '107' #render
      - '44' #video
    # Network mode of 'host' exposes the ports on the host. This is needed for DLNA access.
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      # Update this configuration as desired
      - /path/to/media:/media
    restart: always
    devices:
      # VAAPI Devices
      - /dev/dri/renderD128:/dev/dri/renderD128
      - /dev/dri/card0:/dev/dri/card0
    labels:
      - 'traefik.enable=true'
      ## HTTP Router
      #### Entry point where Jellyfin is accessible via
      #### Change secure to https in the line below to have accessible without needing to specify a port and change the SSLHost option below
      - 'traefik.http.routers.jellyfin.entryPoints=secure'
      #### Host or Path where Jellyfin is accessible
      #### Remove (or change) this rule if you'd rather have Jellyfin accessible at a PathPrefix URI
      - 'traefik.http.routers.jellyfin.rule=Host(`HOST_NAME.DOMAIN_NAME`)' # OPTIONAL: && PathPrefix(`/jellyfin`)
      #### Enable TLS with the ACME/LetsEncrypt resolver for HOSTNAME.DOMAIN_NAME
      - 'traefik.http.routers.jellyfin.tls=true'
      - 'traefik.http.routers.jellyfin.tls.certResolver=leresolver'
      - 'traefik.http.routers.jellyfin.tls.domains=HOSTNAME.DOMAIN_NAME'
      ## Middleware
      - 'traefik.http.routers.jellyfin.middlewares=jellyfin-mw'
      #### The customResponseHeaders option lists the Header names and values to apply to the response.
      - 'traefik.http.middlewares.jellyfin-mw.headers.customResponseHeaders.X-Robots-Tag=noindex,nofollow,nosnippet,noarchive,notranslate,noimageindex'
      #### The sslRedirect is set to true, then only allow https requests.
      - 'traefik.http.middlewares.jellyfin-mw.headers.SSLRedirect=true'
      #### The sslHost option is the host name that is used to redirect http requests to https.
      #### This is the exact URL that will be redirected to, so you can remove the :9999 port if using default SSL port
      - 'traefik.http.middlewares.jellyfin-mw.headers.SSLHost=HOST_NAME.DOMAIN_NAME:9999'
      #### Set sslForceHost to true and set SSLHost to forced requests to use SSLHost even the ones that are already using SSL.
      #### Note that this uses SSLHost verbatim, so add the port to SSLHost if you are using an alternate port.
      - 'traefik.http.middlewares.jellyfin-mw.headers.SSLForceHost=true'
      #### The stsSeconds is the max-age of the Strict-Transport-Security header. If set to 0, would NOT include the header.
      - 'traefik.http.middlewares.jellyfin-mw.headers.STSSeconds=315360000'
      #### The stsIncludeSubdomains is set to true, the includeSubDomains directive will be
      #### appended to the Strict-Transport-Security header.
      - 'traefik.http.middlewares.jellyfin-mw.headers.STSIncludeSubdomains=true'
      #### Set stsPreload to true to have the preload flag appended to the Strict-Transport-Security header.
      - 'traefik.http.middlewares.jellyfin-mw.headers.STSPreload=true'
      #### Set forceSTSHeader to true, to add the STS header even when the connection is HTTP.
      - 'traefik.http.middlewares.jellyfin-mw.headers.forceSTSHeader=true'
      #### Set frameDeny to true to add the X-Frame-Options header with the value of DENY.
      - 'traefik.http.middlewares.jellyfin-mw.headers.frameDeny=true'
      #### Set contentTypeNosniff to true to add the X-Content-Type-Options header with the value nosniff.
      - 'traefik.http.middlewares.jellyfin-mw.headers.contentTypeNosniff=true'
      #### Set browserXssFilter to true to add the X-XSS-Protection header with the value 1; mode=block.
      - 'traefik.http.middlewares.jellyfin-mw.headers.customresponseheaders.X-XSS-PROTECTION=1'
      #### The customFrameOptionsValue allows the X-Frame-Options header value to be set with a custom value. This
      #### overrides the FrameDeny option.
      - "traefik.http.middlewares.jellyfin-mw.headers.customFrameOptionsValue='allow-from https://DOMAIN_NAME'"
      ## HTTP Service
      # We define the port here as a port is required, but note that the service is pointing to the service defined in @file
      - 'traefik.http.routers.jellyfin.service=jellyfin-svc@file'
      - 'traefik.http.services.jellyfin-svc.loadBalancer.server.port=8096'
      - 'traefik.http.services.jellyfin-svc.loadBalancer.passHostHeader=true'
      ## Redirection of HTTP on port 9999 to HTTPS on port 9999 (consistent protocol)
      - 'traefik.http.routers.jellyfin-insecure.entryPoints=secure'
      - 'traefik.http.routers.jellyfin-insecure.rule=Host(`HOST_NAME.DOMAIN_NAME`)' # OPTIONAL: && PathPrefix(`/jellyfin`)
      - 'traefik.http.routers.jellyfin-insecure.middlewares=jellyfin-insecure-mw'
      - 'traefik.http.middlewares.jellyfin-insecure-mw.redirectscheme.scheme=https'
      - 'traefik.http.middlewares.jellyfin-insecure-mw.redirectscheme.port=9999' # remove if you are using a default port
      - 'traefik.http.middlewares.jellyfin-insecure-mw.redirectscheme.permanent=false'
      - 'traefik.http.routers.jellyfin-insecure.service=noop@internal'

CAUTION

TOML files can't support environment variables, so all values must be hard coded.

traefik.toml​
[log]
  # By default, the level is set to ERROR. Alternative logging levels
  # are DEBUG, PANIC, FATAL, ERROR, WARN, and INFO.
  level = "DEBUG"
  filePath = "/traefik.log"

[docker]
  # Defines a default docker network to use for connections to all
  # containers.  This option can be overridden on a container basis
  # with the traefik.docker.network label.
  network = "traefik"

  # Expose containers by default through Traefik. If set to false,
  # containers that don't have a traefik.enable=true label will be
  # ignored from the resulting routing configuration.
  exposedbydefault = false

[api]
  # Enable the API in insecure mode, which means that the API will be
  # available directly on the entryPoint named traefik. If the entryPoint
  # named traefik is not configured, it will be automatically created on
  # port 8080.
  insecure = true

[providers]
  # Connection to docker host system (docker.sock)
  # Attach labels to your containers and let Traefik do the rest!
  # Traefik works with both Docker (standalone) Engine and Docker Swarm Mode.
  # See: https://docs.traefik.io/providers/docker/
  [providers.docker]
    # Traefik requires access to the docker socket to get its dynamic
    # configuration.
    endpoint = "unix:///var/run/docker.sock"
  [providers.file]
    filename = "/traefik-provider.toml"


# EntryPoints are the network entry points into Traefik. They define
# the port which will receive the packets, and whether to listen for
# TCP or UDP.
# See: https://docs.traefik.io/routing/entrypoints/
# NOTE: If a TLS section (i.e. any of its fields) is defined in your docker-compose.yml file,
# then the default configuration does not apply at all.
[entryPoints]
  # Standard HTTP redirects to HTTPS
  [entryPoints.http]
    address = ":80"
    [entryPoints.http.http]
      [entryPoints.http.http.redirections]
        [entryPoints.http.http.redirections.entrypoint]
          to = "https"
          scheme = "https"
  # Standard HTTPS
  [entryPoints.https]
    address = ":443"
    [entryPoints.https.http.tls]
      certResolver = "leresolver"
      [[entryPoints.https.http.tls.domains]]
        main = "HOST_NAME.DOMAIN_NAME"
        # SANS are any other hostnames which Traefik should obtain a certificate for.
        # If you are using DNS for LetsEncrypt, you can set a wildcard.
        # Include all possible hostnames of this server.
        #sans = ["*.DOMAIN_NAME"]
  # Alternate HTTPS Port (for services - accepts both HTTP and HTTP by not defining a TLS configuration here)
  [entryPoints.secure]
    address = ":9999"

# Enable ACME (Let's Encrypt): automatic SSL.
[certificatesresolvers.leresolver.acme]
  email = "YOU@DOMAIN_NAME"
  storage = "acme.json"
  # Use HTTP-01 ACME challenge
  #[certificateresolvers.leresolver.acme.httpChallenge]
  #  entryPoint = "http"
  # Use a DNS-01 ACME challenge rather than HTTP-01 challenge.
  # Mandatory for wildcard certificate generation.
  [certificatesresolvers.leresolver.acme.dnsChallenge]
    # Update this to your provider of choice and then ensure necessary variables are in the .env file to support it.
    provider = "rfc2136"
    delayBeforeCheck = 0
    # A DNS server used to check whether the DNS is set up correctly before
    # making the ACME request. Ideally a DNS server that isn't going to cache an old entry.
    resolvers = ["8.8.8.8:53"]

[retry]


Due to a quirk in Traefik, you cannot dynamically route to containers when network_mode=host. We have created a static route to the docker host (192.168.1.xx:8096) in traefik-provider.toml. The use of host networking (as in this doc) or macvlan are required to use DLNA or an HdHomeRun so it can utilize the multicast network. traefik-provider.toml defines the jellyfin-svc@file service which we are pointing the router to in the docker-compose.yml file. You can not set a URL in docker-compose.yml which is why we set up this service externally. Be sure to update the IP address below to the IP address of the host on the local network (in this case, 192.168.1.xx).

traefik-provider.toml​
[http]
  [http.services]
    [http.services.jellyfin-svc]
      [[http.services.jellyfin-svc.loadBalancer.servers]]
        url = "http://192.168.1.xx:8096"
# Set secure options by disabling insecure older TLS/SSL versions
# and insecure ciphers. SNIStrict disabled leaves TLS1.0 open.
# If you have problems with older clients, you can may need to relax
# these minimums. This configuration will give you an A+ SSL security
# score supporting TLS1.2 and TLS1.3
[tls.options]
  [tls.options.default]
    sniStrict = true
    minVersion = "VersionTLS12"
    curvePreferences = [
      "secp521r1",
      "secp384r1"
    ]
    cipherSuites = [
      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
      "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
      "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
    ]
    [tls.options.mintls13]
      minVersion = "VersionTLS13"

.env​
RFC2136_NAMESERVER=...
RFC2136_TSIG_ALGORITHM=hmac-sha512.
RFC2136_TSIG_KEY=...
RFC2136_TSIG_SECRET=...


Finally, create an empty acme.json and traefik.log file to handle the certificate and log file for any logging

touch acme.json traefik.log
chmod 600 acme.json traefik.log

CAUTION

These configurations use DOMAIN_NAME (i.e.: example.com) and HOST_NAME (i.e.: servername) throughout it. You should replace these with your server's name. HOST_NAME.DOMAIN_NAME refers to the machine itself (ie: servername.example.com). Don't forget to update traefik.toml's YOU@DOMAIN_NAME with your email address. Let's Encrypt does not require a valid email but invalid e-mails may be flagged as fake.

Launch the Traefik and Jellyfin services.

docker compose up -d


If you set a PathPrefix (i.e. /jellyfin), you need to configure Jellyfin to expect it. After starting the service, access Jellyfin directly (via the host's IP at port 8096) and change the 'Base URL' in Dashboard / Advanced / Networking to match the '/jellyfin' path (if you used one in this configuration). Afterward, you may wish to create a firewall rule to prevent direct access to Jellyfin at port 8096 on the host, or simply ensure the port is not accessible via the Internet.

Congratulations, your stack with Traefik 2.x and Jellyfin is (hopefully) running! Check the log file or run without the '-d' parameter to review any errors that may come up, particularly with respect to the LetsEncrypt configuration.

Edit this page
Previous
Nginx
Next
Devices
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#connectivity

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#port-bindings

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#static-ports

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#dynamic-ports

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#monitoring-endpoints

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#self-signed-certificate

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#known-proxies

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#base-url

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/networking/#final-steps

Skip to main content
Networking
On this page
Networking

This section describes how to get basic connectivity to a Jellyfin server, and also some more advanced networking scenarios.

Connectivity​

Many clients will automatically discover servers running on the same LAN and display them on login. If you are outside the network when you connect you can type in the complete IP address or domain name in the server field with the correct port to continue to the login page. You can find the default ports below to access the web frontend.

HTTP and HTTPS are the primary means of connecting to the server. If using a self-signed certificate for HTTPS, some clients may not work such as Chromecast or Roku.

CAUTION

In order for Chromecast to work on your local LAN, the easiest solution is to use IPv6 instead of IPv4. For IPv4, you need to use NAT reflection to redirect to your local LAN IPv4 or add a override rules to your local DNS server to point to your local LAN IPv4 (for example 192.168.1.10) of Jellyfin.
Because Chromecasts have hardcoded Google DNS servers, you need to block Chromecast from reaching these servers (8.8.8.8) so it makes use of your local DNS server instead.
For a public routable IPv6 (not a link-local or ULA) there is no difference between public or local. Such IPv6 address is simultaneously publicly routable and accessible from the local LAN.
Because of that, there is no blocking, redirecting or DNS override needed.

Port Bindings​

This document aims to provide an administrator with knowledge on what ports Jellyfin binds to and what purpose they serve.

Static Ports​
8096/tcp is used by default for HTTP traffic. You can change this in the dashboard.
8920/tcp is used by default for HTTPS traffic. You can change this in the dashboard.
1900/udp is used for service auto-discovery. This is not configurable.
7359/udp is also used for auto-discovery. This is not configurable.

HTTP Traffic: 8096

The web frontend can be accessed here for debugging SSL certificate issues on your local network. You can modify this setting from the Networking page in the settings.

HTTPS Traffic: 8920

This setting can also be modified from the Networking page to use a different port.

Service Discovery: 1900

Since client auto-discover would break if this option were configurable, you cannot change this in the settings at this time. DLNA also uses this port and is required to be in the local subnet.

Client Discovery: 7359 UDP

Allows clients to discover Jellyfin on the local network. A broadcast message to this port with Who is JellyfinServer? will get a JSON response that includes the server address, ID, and name.

Dynamic Ports​

Live TV devices will often use a random UDP port for HDHomeRun devices. The server will select an unused port on startup to connect to these tuner devices.

Monitoring Endpoints​

See monitoring for details on the monitoring endpoints that Jellyfin provides.

Self-Signed Certificate​

See here for more information.

Create a private key.

openssl req -x509 -newkey rsa:4096 -keyout ./privkey.pem -out cert.pem -days 365 -nodes -subj '/CN=jellyfin.lan'


Omit -nodes to set a password interactively.

Remove -days 365 to make it 'permanent'.

Add -subj '/CN=localhost' to make it not ask interactive questions about content of certificate.

The above command creates ./privkey.pem which will require one more step before use in Jellyfin.

openssl pkcs12 -export -out jellyfin.pfx -inkey privkey.pem -in cert.pem -passout pass:

Running Jellyfin Behind a Reverse Proxy​

It's possible to run Jellyfin behind another server acting as a reverse proxy. With a reverse proxy setup, this server handles all network traffic and proxies it back to Jellyfin. This provides the benefits of using DNS names and not having to remember port numbers, as well as easier integration and management of SSL certificates.

In cases when you would like to not use host networking with docker, you may use the gateway ip as a known proxy to fix ip resolution for clients logging in.

CAUTION

In order for a reverse proxy to have the maximum benefit, you should have a publicly routable IP address and a domain with DNS set up correctly. These examples assume you want to run Jellyfin under a sub-domain (e.g. jellyfin.example.com), but are easily adapted for the root domain if desired.

CAUTION

Be careful when logging requests with your reverse proxy. Jellyfin sometimes sends authentication information as part of the URL (e.g api_key parameter), so logging the full request path can expose secrets to your logfile. We recommend that you either protect your logfiles or do not log full request URLs or censor sensitive data from the logfile. The nginx documentation below includes an example how to censor sensitive information from a logfile.

Some popular options for reverse proxy systems are Apache, Caddy, Haproxy, Nginx and Traefik.

Apache
Caddy
HAProxy
Nginx
Traefik

While not a reverse proxy, Let's Encrypt can be used independently or with a reverse proxy to provide SSL certificates.

Let's Encrypt

When following this guide, be sure to replace the following variables with your information.

DOMAIN_NAME: Your public domain name to access Jellyfin on (e.g. jellyfin.example.com)
example.com: The domain name Jellyfin services will run under (e.g. example.com)
SERVER_IP_ADDRESS: The IP address of your Jellyfin server (if the reverse proxy is on the same server use 127.0.0.1)

In addition, the examples are configured for use with Let's Encrypt certificates. If you have a certificate from another source, change the SSL configuration from /etc/letsencrypt/DOMAIN_NAME/ to the location of your certificate and key.

Ports 80 and 443 (pointing to the proxy server) need to be opened on your router and firewall.

Known Proxies​

Add the IP address/hostname of your reverse proxy to the Known Proxies (under Admin Dashboard -> Networking). This is a comma separated list of IP addresses/hostnames of known proxies used when connecting to your Jellyfin instance and is required to make proper use of X-Forwarded-For headers. Requires a server restart after saving.

Base URL​

Running Jellyfin with a path (e.g. https://example.com/jellyfin) is supported by the Android and web clients.

CAUTION

Base URL is known to break HDHomeRun, DLNA, Sonarr, Radarr, Chromecast, and MrMC.

The Base URL setting in the Networking page is an advanced setting used to specify the URL prefix that your Jellyfin instance can be accessed at. In effect, it adds this URL fragment to the start of any URL path. For instance, if you have a Jellyfin server at http://myserver and access its main page http://myserver/web/index.html, setting a Base URL of /jellyfin will alter this main page to http://myserver/jellyfin/web/index.html. This can be useful if administrators want to access multiple Jellyfin instances under a single domain name, or if the Jellyfin instance lives only at a subpath to another domain with other services listening on /.

The entered value on the configuration page will be normalized to include a leading / if this is missing.

This setting requires a server restart to change, in order to avoid invalidating existing paths until the administrator is ready.

There are three main caveats to this setting.

When setting a new Base URL (i.e. from / to /baseurl) or changing a Base URL (i.e. from /baseurl to /newbaseurl), the Jellyfin web server will automatically handle redirects to avoid displaying users invalid pages. For instance, accessing a server with a Base URL of /jellyfin on the / path will automatically append the /jellyfin Base URL. However, entirely removing a Base URL (i.e. from /baseurl to /, an empty value in the configuration) will not - all URLs with the old Base URL path will become invalid and throw 404 errors. This should be kept in mind when removing an existing Base URL.

Client applications generally, for now, do not handle the Base URL redirects implicitly. Therefore, for instance in the Android app, the Host setting must include the BaseURL as well (e.g. http://myserver:8096/baseurl), or the connection will fail.

Any reverse proxy configurations must be updated to handle a new Base URL. Generally, passing / back to the Jellyfin instance will work fine in all cases and the paths will be normalized, and this is the standard configuration in our examples. Keep this in mind however when doing more advanced routing.

Final Steps​

It's strongly recommend that you check your SSL strength and server security at SSLLabs if you are exposing these services to the internet.

Edit this page
Previous
Troubleshooting
Next
Apache
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/troubleshooting

Skip to main content
AdministrationTroubleshooting
On this page
Troubleshooting

This page outlines some solutions to common issues beginners may encounter when running a Jellyfin server.

Playback Issues​

The easiest way to check for issues is by checking the logs, which can be accessed through the console for the web client or in the log directory on your server.

If media is unable to transcode, first check the ffmpeg logs.

Networking Issues​

If you can access the web interface over HTTP but not HTTPS, then you likely have an error with the certificate. Jellyfin uses a PFX file to handle HTTPS traffic. If you created the file with a password, then you will have to enter that value on the Networking page in the settings.

If you can access the server locally but not outside of your LAN, then you likely have an issue with the router configuration. Check the port forwarding settings on your router to ensure the server is visible from outside your local network. You can also enable the "Enable automatic port mapping" option on the Networking page of the server settings to have the server attempt to configure port forwarding on the router automatically if your router supports it.

If there are no logs at all relating to web traffic, even over a LAN connection, then the server hasn't been reached at all yet. This would indicate either an incorrect address or an issue somewhere else on the network.

Debug Logging​

Debug logging can be very useful when troubleshooting issues. To enable debug logging, manually editing a configuration file is required as Jellyfin does not control this from the frontend UI.

Logging options can be configured in the file logging.json in the Jellyfin configuration directory. On some platforms, there is also logging.default.json which provides default values which can then be overridden by a custom logging.json.

CAUTION

Enabling debug logging will create a very large amount of output; as an example, simply loading the homepage will generate over 4000 lines of logs with the debug configuration below. Leaving debug logging enabled on a productive Jellyfin instance for a long period of time is not recommended, and it should be enabled only during troubleshooting.

NOTE

If you are requested to provide extensive debug logs in an issue or during troubleshooting (e.g. more than just a few lines), please compress the resulting log files if possible as they will be very large otherwise.

To enable debug logging, create the logging.json file and add the following contents to it:

{
    "Serilog": {
        "MinimumLevel": {
            "Default": "Debug",
            "Override": {
                "": "Debug"
            }
        }
    }
}


If a logging.json file already exists, edit the Serilog MinimumLevel section to match the above but do not change any other values in the file.

Debug messages will appear in the log with the DBG tag prefixed to each line, though some components will also log additional details at INF with this configuration.

NOTE

If the logging.json file existed before the last server start, Jellyfin will automatically reload the new configuration, once the change is made, without needing to restart. If the logging.json file was created after the last server start, a server restart will be required before the changes enabling debug logging will take effect.

To restore normal logging, you can remove the override logging.json (if you created a new file above) or restore the logging.json Serilog MinimumLevel section to its default values of:

{
    "Serilog": {
        "MinimumLevel": {
            "Default": "Information",
            "Override": {
                "Microsoft": "Warning",
                "System": "Warning"
            }
        }
    }
}

Real Time Monitoring​

This will let Jellyfin automatically update libraries when files are added or modified. Unfortunately, this feature is only supported on certain filesystems.

For Linux systems, this is performed by inotify. NFS and rclone do not support inotify, but support can be provided by using a union file system such as mergerfs with your networked file systems.

Due to the library size, you can receive an error such as this:

[2019-12-31 09:11:36.652 -05:00]  [ERR] Error in Directory watcher for: "/media/movies"  System.IO.IOException: The configured user limit (8192) on the number of inotify watches has been reached.


If you are running Debian, RedHat, or another similar Linux distribution, run the following in a terminal:

echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.d/40-max-user-watches.conf && sudo sysctl -p


If you are running ArchLinux, run the following command instead:

echo fs.inotify.max_user_watches=524288 | sudo tee /etc/sysctl.d/40-max-user-watches.conf && sudo sysctl --system


Then paste it in your terminal and press on enter to run it. For Docker, this needs to be done on the host, not the container. See here for more information.

Uninstalling Jellyfin on MacOS​

To fully remove all data of Jellyfin from MacOS, run these commands:

rm -Rfv ~/.config/jellyfin
rm -Rfv ~/.cache/jellyfin
rm -Rfv ~/.local/share/jellyfin

Unlock locked user account​

When the admin account is locked out and the Forgot Password feature is not working, you have to unlock the user manually. To do that, you need to find the jellyfin.db file on your system. The default location on Linux is: /var/lib/jellyfin/data/. For paths in other environments, see server paths.

Linux CLI​

Before continuing, make sure that you have sqlite3 installed. When sqlite3 is not installed, you can install it under Debian based systems with apt install sqlite3. After that do the following commands/SQL query:

sqlite3 /PATH/TO/JELLYFIN/DB/jellyfin.db

UPDATE Users SET InvalidLoginAttemptCount = 0 WHERE Username = 'LockedUserName';
UPDATE Permissions SET Value = 0 WHERE Kind = 2 AND UserId IN (SELECT Id FROM Users WHERE Username = 'LockedUserName');
.exit

SQLiteBrowser​

It is also possible to use SQLiteBrowser on systems with a desktop environment. Start by opening the database inside the SQLite Browser. After opening the database, navigate to the Execute SQL Tab and execute the following query:

UPDATE Users SET InvalidLoginAttemptCount = 0 WHERE Username = 'LockedUserName';
UPDATE Permissions SET Value = 0 WHERE Kind = 2 AND UserId IN (SELECT Id FROM Users WHERE Username = 'LockedUserName');

Fix Admin User Permissions​

If the permissions for your admin account break, you can restore them using simple SQL queries.

CAUTION

Manual changes to the database can destroy your instance beyond repair. to prevent this create a copy of your database before executing: cp /PATH/TO/JELLYFIN/DB/jellyfin.db /PATH/TO/JELLYFIN/DB/jellyfin.db.bck

Before continuing, make sure that you have sqlite3 installed. When sqlite3 is not installed, you can install it under Debian based systems with apt install sqlite3. After that do the following commands/SQL query:
You can find a list of default Paths here

sqlite3 /PATH/TO/JELLYFIN/DB/jellyfin.db

Get an Overview​

To see the current permissions for all users, you can run the following query:

SELECT Permissions.Value,Permissions.Kind,Users.Username  FROM Permissions INNER JOIN Users ON Permissions.UserID = Users.Id;


To just check permissions on your admin account, run the following query:
Please change AdminUsername to the username of your admin account

SELECT Value,Kind FROM Permissions WHERE UserId IN (SELECT Id FROM Users WHERE Username = 'AdminUsername');




The first row with an value of 1 or 0 shows if the permission is assigned or not. The second row displays the kind of permission. To get a summary for every permission you can look here

Repair Permissions​
NOTE

Not all permissions are needed, you can remove the unnecessary ones later in the Web UI.

UPDATE Permissions SET Value = 1 WHERE (Kind = 0 OR Kind = 3 OR Kind = 4 OR Kind = 5 OR Kind = 6 OR Kind = 7 OR Kind = 8 OR Kind = 9 OR Kind = 10 OR Kind = 11 OR Kind = 12 OR Kind = 13 OR Kind = 14 OR Kind = 15 OR Kind = 16 OR Kind = 17 OR Kind = 18 OR Kind = 19 OR Kind = 20 OR Kind = 21) AND UserId IN (SELECT Id FROM Users WHERE Username = 'AdminUsername');

.exit

Text Not Rendering Properly​

Text may show up as boxes ☐☐☐☐☐☐ if fonts for the characters are not available. Installing fonts for the affected languages can solve the problem. For library cover images, please install system fonts on the server system. For subtitles, the source of fonts depends on the client. Please refer to Fonts on where to install them.

Not Showing Active Devices​

If your active devices section in the dashboard is not showing progress of the content being played by any devices, this may be because your system clock is out of sync. To resolve this on systemd based Linux systems, you can run the following command to enable syncing with an online NTP server (which in turn will start and enable either the chronyd or ntpd service). Make sure to restart Jellyfin afterwards.

timedatectl set-ntp true

Edit this page
Previous
Storage
Next
Networking
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#__docusaurus_skipToContent_fallback

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/codec-support

Skip to main content
ClientsCodec Support
On this page
Codec Tables

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

Video Compatibility​

Breakdown of video codecs.

Test your browser's compatibility for any codec profile.

Sorted by efficency (excluding bit depth)	Chrome	Edge	Firefox	Safari	Android	Android TV	iOS	SwiftFin (iOS)	Roku	Kodi	Desktop
MPEG-4 Part 2/SP	❌	❌	❌	❌	❌	❌	❌	✅	✅	✅	✅
MPEG-4 Part 2/ASP	❌	❌	❌	❌	❌	❌	❌	✅		✅	✅
H.264 8Bit	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅
H.264 10Bit	✅	✅	❌	🔶12	✅	✅	❌	✅	❌	✅	✅
H.265 8Bit	🔶8	✅7	❌	🔶1	🔶2	✅5	🔶1	✅6	🔶9	✅	✅
H.265 10Bit	🔶8	✅7	❌	🔶1	🔶2	🔶5	🔶1	✅6	🔶9	✅	✅
VP9	✅	✅	✅	✅10	✅3	🔶3	❌	❌	✅	✅	✅
AV1	✅	✅	✅	🔶11	✅	🔶4	❌	❌	✅	✅	✅

1HEVC is only supported in MP4, M4V, and MOV containers.




2Android playback is currently broken. Client reports that HEVC is supported and attempts to Direct Stream.




3May be (partially) dependent on Hardware support (can be compensated with CPU decoding on Android). Most new Android phones in the higher price range and many "4K" Android TV devices have VP9 hardware decoding support. Refer to you manufacturer for supported codecs.




4Needs atleast Android TV 10.




5As of version 0.12, HEVC is enabled on all devices running Android 5.0+, but early generations of the Amazon Fire may not work yet. 10Bit may be supported depending on your device. Before Client 0.12, HEVC support was enabled on specific devices.




6HEVC decoding is supported on Apple devices with the A8X chip or newer and at least iOS 14.




7HEVC decoding is only supported on Windows 10 with the HEVC Video Extension from the Microsoft store.




8Chromium 107 does support HEVC decoding when HEVC hardware decoding is available.




9HEVC decoding is only supported on 4K devices.




10VP9 decoding on Safari requires at least Safari 14.




11AV1 decoding is only available on devices with A17 or M3 series chips or newer and requires at least Safari 17.




12Need to be manually enabled in Settings > Playback > Enable H.264 High 10 Profile. Playback on Apple Silicon Macs with macOS version < 14 and Intel Macs with all macOS versions may result in blank frames if this is enabled.

Format Cheatsheet:

MPEG-2
Part 2	MPEG-4
Part-21	MPEG-4
Part-10	MPEG-4
Part-14	MPEG-H
Part 2
H.262	MPEG-4 SP/ASP	H.264	MP4 Container2	H.265
MPEG-2 Video	DivX	MPEG-4 AVC		HEVC
DVD-Video	DX50			
1 MPEG-4 Part-2 vs Part-10
2 MPEG-4 Part 17: MP4TT Subtitles
Audio Compatibility​

If the audio codec is unsupported or incompatible (such as playing a 5.1 channel stream on a stereo device), the audio codec must be transcoded. This is not nearly as intensive as video transcoding.

	Chrome	Edge	Firefox	Safari	Android	Android TV	iOS	SwiftFin (iOS)	Roku	Kodi	Desktop
FLAC	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅
MP3	🔶1	✅	🔶	✅	✅	✅	✅	✅	✅	✅	✅
AAC	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅	✅
AC3	✅	✅	❌	✅	✅	✅	✅	✅		✅	✅
EAC32	✅	✅	✅	✅	✅	✅	✅	✅		✅	✅
VORBIS3	✅	✅	✅	❌	✅	❌	❌	✅	✅	✅	✅
DTS4	❌	❌	❌	❌	✅	✅	❌	✅	✅6	✅	✅
OPUS	✅	✅	✅	🔶5	✅	✅	🔶5	✅	✅	✅	✅
ALAC	❌	❌	❌	✅	❌	❌	✅				✅

Format Cheatsheet:

MPEG-1	MPEG-2
MP2 (layer 2)	AAC (Part 7)
MP3 (layer 3)	

1MP3 Mono is incorrectly reported as unsupported and will transcode to AAC.




2Only EAC3 2.0 has been tested.




3OGG containers are not supported and will cause VORBIS to convert.




4Only DTS Mono has been tested.




5Safari only supports opus in .caf files




6Supported via passthrough on all devices. Native support for AC3 & E-AC3 on Roku TVs & Ultra.

ATSC Standard for AC-3 and EAC-3.

Subtitle Compatibility​

Subtitles can be a subtle issue for transcoding. Containers have a limited number of subtitles that are supported. If subtitles need to be transcoded, it will happen one of two ways: they can be converted into another format that is supported, or burned into the video due to the subtitle transcoding not being supported. Burning in subtitles is the most intensive method of transcoding. This is due to two transcodings happening at once; applying the subtitle layer on top of the video layer.

Here is a breakdown of common subtitle formats.

	Format	TS	MP4	MKV	AVI
SubRip Text (SRT)	Text	❌	🔶	✅	🔶
WebVTT (VTT)1	Text	❌	❌	✅	🔶
ASS/SSA	Formatted Text	❌	❌	✅	🔶
VobSub2	Picture	✅	✅	✅	🔶
MP4TT/TXTT	XML	❌	✅	❌	❌
PGSSUB	Picture	❌	❌	✅	❌
EIA-608/7083	Embedded	✅	✅	✅	❌

1VTT are supported in an HLS Stream.




2DVB-SUB (SUB + IDX) is another name for VobSub files.




3EIA-608/708 subtitles are embedded in private channels (channel 21) in a MPEG video codec. EIA-608 are standard CC subtitles with the black bar background, while EIA-708 are typically SDH.

Types of Subtitles​

There are many variations of subtitles. Closed, open, burned-in, forced, SDH, and CC are among the common types of subtitles. The format (such as SubRIP or VobSUB) does not matter for the type of subtitle.

Closed Subtitles​

This is the generic name for subtitles that can be turned on or off. This can be Forced, SDH, CC or normal subtitles.

Burned-in​

Open subtitles (also known as burned-in subtitles) are subtitles that have been permanently placed in the video and cannot be turned off. Open subtitles are the most common type of subtitles, where the subtitles are part of the video stream and cannot be toggled on or off.

SDH and Closed Captioning​

SDH and CC are subtitles for the Deaf and Hard of Hearing. They include extra content such as background noises. SDH and CC are not defined by a specific type of subtitle, just by their intent. If using an OTA Tuner and DVR, the subtitles will be embedded into the video and transcoding them before extracting the subtitles will destroy the subtitles.

Forced​

"Forced subtitles are common on movies and only provide subtitles when the characters speak a foreign or alien language, or a sign, flag, or other text in a scene is not translated in the localization and dubbing process. In some cases, foreign dialogue may be left untranslated if the movie is meant to be seen from the point of view of a particular character who does not speak the language in question." - Wikipedia

Extracting Subtitles​

To extract subtitles, the following commands can be used. The section 0:s:0 means the first subtitle, so 0:s:1 would be the second subtitle.

SSA/ASS Subtitles​
ffmpeg -dump_attachment:t "" -i file.mkv -map 0:s:1 -c:s ass extracted-subtitle.ass

Recorded OTA Content​

Content recorded OTA will typically have subtitles embedded into the video codec itself. These subtitles are typically EIA-608 for analog and EIA-708 for digital.

ffmpeg -f lavfi -i "movie=Ronin (1998).ts[out+subcc]" -map 0:1  "Ronin (1998).srt"

Fonts​

Text-based subtitle formats require fonts to render properly. Please refer to Fonts for how to install them.

Container Compatibility​

If the container is unsupported, this will result in remuxing. The video and audio codec will remain intact but wrapped in a supported container. This is the least intensive process. Most video containers will be remuxed to use the HLS streaming protocol and TS containers. Remuxing shouldn't be a concern even for an RPi3.

	Chrome	Edge	Firefox	Safari	Android	Android TV	Kodi	Roku
MP41	✅	✅	✅	✅	✅	✅	✅	✅
MKV2, 3	❌	✅	❌	❌	✅	✅	✅	✅
WebM3, 5, 6	✅	✅	✅	✅	✅	✅	✅	✅
TS4	✅	✅	✅	✅	✅	✅	✅	✅
OGG5	✅	✅	✅	❌	✅	✅	✅	✅

1MP4 containers are one of the few containers that will not remux.




2MKV containers can hold nearly any codec, but are not compatible with streaming in Firefox and will remux.




3MKV containers are improperly labeled as WebM in Firefox during playback.




4TS is one of the primary containers for streaming for Jellyfin.




5WebM and OGG have limited codec support (by design), refer to this for WebM and this for OGG.




6WebM on Safari requires at least Safari 14.

Edit this page
Previous
Clients
Next
CSS Customization
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/css-customization

Skip to main content
ClientsCSS Customization
On this page
CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

Custom CSS provides customization such as changing colors, changing layouts, and item size and behavior. Below is a list of various tweaks that can be applied. The CSS tweaks work on both the web client, and the Android application. The code will apply in the order that it is written, however !important will overrule everything. To learn more about !important and more, see CSS Specificity or specifishity. To implement these changes, go to Dashboard > General > Custom CSS to start.

If you have little or no experience with CSS, various resources and tutorials can be found online. Using the tweaks and examples below makes it quite easy to get started with making your own changes to your Jellyfin instance.

General Information About CSS​

You can learn more about CSS using sites like w3schools and MDN. Below are some very basic CSS knowledge that will let you do rough edits to the pre-made tweaks below.

Colors​

CSS supports multiple color formats, but typically the hex color codes are used for specific colors. To get a specific color, exact color data such as the hex codes below have to be used.

Some examples of hex color codes:

Green: #5dd000
Blue: #0000d0
Red: #d00000
Transparent Black: #00000058

Go here for a hex color chart to get a code for any given color.

If you are looking for a more standard and less specific color, typing the literal name of colors suits that purpose well. For example, to get the color "yellow" you can simply write "yellow", this will use a preset yellow color.

yellow Yellow
red Red
aquamarine Aquamarine
lightseagreen Light Sea Green

Go here for a list of color names supported.

Comments​

A section of code or text in-between /* and */ indicates a comment, and will be ignored. This allows you to add descriptions for any particular section of code. It can also be used to disable code without deleting it.

/* This might be added above code to tell you what it does */

CSS Chaining​

CSS can be "chained" together to modify different sections together at the same time. An example of this is the "Border Color" tweak. It lists the elements to be modified, and performs a change that is applied to all of them.

"Border Color" tweak:

.emby-input,
.emby-textarea,
.emby-select {
  border-color: #d00000;
}

Tweak List​

To apply any one of these tweaks, copy and paste the CSS code from the example into the "Custom CSS" field. To use multiple tweaks, simply add them one after another into the field. Any applied code will remain in the field. To remove a tweak, delete or comment out the code for it from the field. Changes apply immediately when the settings page is saved and does not require restarting your Jellyfin server.

Played Indicator​

This will affect the played/watched indicator. Replace the hex color with any value you like.

Indicators Without Tweak​

Green Indicators​
.playedIndicator {
  background: #5dd000;
}


Transparent And Dark Indicators​
/* Make watched icon dark and transparent */
.indicator { background: #00000058 !important; }


Transparant count indicators (eg. Series)​
/* Make count indicator icon dark and transparent */
.countIndicator {background: #00000058;}

Display external links in mobile layout​

The mobile app disables display of external links to IMDb, TheMovieDB, Trakt, etc by default. To enable the external links again, add the following snippet:

.layout-mobile .itemExternalLinks {
  display: block !important;
}

Hide Home Icon from Header​
.headerHomeButton {
  display: none;
}

.headerButton.headerButtonRight.headerUserButton.paper-icon-button-light {
  display: none;
}

Hide Cast Icon from Header​
.headerCastButton {
  display: none;
}

Hide Sync Icon from Header​
.headerSyncButton {
  display: none;
}

Hide User Settings from Header​
.material-icons.person {
  display: none;
}

Hide Live TV Channel Listings​
.guideChannelNumber {
  display: none;
}

Reduce Live TV Channel Width​
.channelsContainer {
  max-width: 8em;
}

Hide Cast & Crew​
#castCollapsible {
  display: none;
}

Hide More Like This​
#similarCollapsible {
  display: none;
}

Hide Next Up​
div.nextUpSection {
  display: none;
}

Hide Star Ratings​
div.starRatingContainer {
  display: none;
}

Replace "Latest Movies" text with Custom Text such as "Recently Added Movies"​
#homeTab
  > div
  > div.section2
  > div:nth-child(1)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a
  > h2 {
  display: none;
}
#homeTab
  > div
  > div.section2
  > div:nth-child(1)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a
  > span {
  display: none;
}
#homeTab
  > div
  > div.section2
  > div:nth-child(1)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a:after {
  content: 'Recently Added Movies ›';
  font-size: 24px;
  font-weight: normal;
}

Replace Latest TV Shows text with Custom Text such as "Recently Added TV Shows"​
#homeTab
  > div
  > div.section2
  > div:nth-child(2)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a
  > h2 {
  display: none;
}
#homeTab
  > div
  > div.section2
  > div:nth-child(2)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a
  > span {
  display: none;
}
#homeTab
  > div
  > div.section2
  > div:nth-child(2)
  > div.sectionTitleContainer.sectionTitleContainer-cards.padded-left
  > a:after {
  content: 'Recently Added TV Shows ›';
  font-size: 24px;
  font-weight: normal;
}

Background Image on Login Page​
#loginPage {
  background: url('https://i.ytimg.com/vi/avCWDDox1nE/maxresdefault.jpg');
  background-size: cover;
}

Background Image on Homepage​
.backdropImage {
  display: none;
}

.backgroundContainer {
  background-color: rgba(0, 0, 0, 0);
  background-image: url('https://i.ytimg.com/vi/avCWDDox1nE/maxresdefault.jpg');
  filter: blur(10px);
  background-size: cover;
}


Additional MDN Documentation

Transparent Top Menu​
.skinHeader.focuscontainer-x.skinHeader-withBackground.skinHeader-blurred {
  background: none;
  background-color: rgba(0, 0, 0, 0);
}
.skinHeader.focuscontainer-x.skinHeader-withBackground.skinHeader-blurred.noHomeButtonHeader {
  background: none;
  background-color: rgba(0, 0, 0, 0);
}

Image Edge Rounded​
.cardContent-button,
.itemDetailImage {
  border-radius: 0.25em;
}

Enlarge Tab Buttons​

Enlarges the tab buttons, suggested, genres, etc. By default they are really tiny, especially on mobile.

/* Adjust both "size-adjust" and "size" to modify size */
.headerTabs.sectionTabs {
  text-size-adjust: 110%;
  font-size: 110%;
}
.pageTitle {
  margin-top: auto;
  margin-bottom: auto;
}
.emby-tab-button {
  padding: 1.75em 1.7em;
}


The enlarged tab buttons and transparent menu look like this:

Minimalistic Login Page​

This looks even better together with the transparent top menu!

/* Narrow the login form */
#loginPage .readOnlyContent,
#loginPage form {
  max-width: 22em;
}

/* Hide "please login" text, margin is to prevent login form moving too far up */
#loginPage h1 {
  display: none;
}
#loginPage .padded-left.padded-right.padded-bottom-page {
  margin-top: 50px;
}

/* Hide "manual" and "forgot" buttons */
#loginPage .raised.cancel.block.btnManual.emby-button {
  display: none;
}
#loginPage .raised.cancel.block.btnForgotPassword.emby-button {
  display: none;
}


Stylized Episode Previews​

The episode previews in season view are sized based on horizontal resolution. This leads to a lot of wasted space on the episode summary and a high vertical page, which requires a lot of scrolling. This code reduces the height of episode entries, which solves both problems.

/* Size episode preview images in a more compact way */
.listItemImage.listItemImage-large.itemAction.lazy {
  height: 110px;
}
.listItem-content {
  height: 115px;
}
.secondary.listItem-overview.listItemBodyText {
  height: 61px;
  margin: 0;
}


Stylized and Smaller Cast & Crew Info​

This will drastically change the style of cast info into something very similar to how Plex approaches it. This override will lead to somewhat smaller thumbnails, and also works with all themes.

/* Shrink and square (or round) cast thumnails */
#castContent .card.overflowPortraitCard.personCard.card-hoverable.card-withuserdata {width: 4.2cm !important; font-size: 90% !important;}
#castContent .card.overflowPortraitCard.personCard.card-withuserdata {width: 4.2cm !important; font-size: 90% !important;}

/* Correct image aspect ratio behaviour, set border-radius to zero for square tiles */
#castContent .cardContent-button.cardImageContainer.coveredImage.cardContent.cardContent-shadow.itemAction.lazy {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardContent-button.cardImageContainer.coveredImage.defaultCardBackground.defaultCardBackground1.cardContent.cardContent-shadow.itemAction {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardContent-button.cardImageContainer.coveredImage.defaultCardBackground.defaultCardBackground2.cardContent.cardContent-shadow.itemAction {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardContent-button.cardImageContainer.coveredImage.defaultCardBackground.defaultCardBackground3.cardContent.cardContent-shadow.itemAction {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardContent-button.cardImageContainer.coveredImage.defaultCardBackground.defaultCardBackground4.cardContent.cardContent-shadow.itemAction {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardContent-button.cardImageContainer.coveredImage.defaultCardBackground.defaultCardBackground5.cardContent.cardContent-shadow.itemAction {background-size: cover; !important; border-radius: 2.5cm;}
#castContent .cardScalable {width: 3.8cm !important; height: 3.8cm !important; border-radius: 2.5cm;}
#castContent .cardOverlayContainer.itemAction {border-radius: 2.5cm;}

/* Center the mouseover buttons */
#castContent .cardOverlayButton-br {bottom: 4%; right: 15%; width: 70%;}
#castContent .cardOverlayButton.cardOverlayButton-hover.itemAction.paper-icon-button-light {margin:auto;}


Pictureless Cast & Crew​
#castContent .card.overflowPortraitCard {
  width: 4.2cm;
  font-size: 90%;
}

#castContent .personCard {
  width: auto;
}

#castContent .personCard .cardBox {
  margin-bottom: 0px;
  margin-right: 0px;
}

#castContent {
  flex-wrap: wrap;
  max-height: 9.75em;
}

div.personCard > :first-child > :first-child {
  display: none;
}

.itemDetailPage .cardText {
  text-align: left;
}

.itemDetailPage .textActionButton {
  text-align: left;
}


Custom Background Color​
.backgroundContainer,
.dialog,
html {
  background-color: #0fd0d0;
}

Darken the Background​

This darkens the background on Blue Radiance and Purple Haze, edit the percentage depending how dark you want it. Lower is darker.

/* Darken background, only works with blue radiance */
.backgroundContainer {
  background-color: #000000;
  filter: brightness(50%);
}

Right Header Color​

This modifies the colors of the cast, search and user buttons in the top right.

.headerRight {
  color: yellow;
}


Console Panel Custom Color​

Modifies the color of the left menu panel.

.mainDrawer-scrollContainer {
  color: yellow;
}


General Page Custom Color​
.dashboardGeneralForm {
  color: yellow;
}


Custom Border Color​

This will change the border color for text fields and drop-down menus.

.emby-input,
.emby-textarea,
.emby-select {
  border-color: #d00000;
}


This will affect the border color of highlighted (selected) text fields and drop-down menus.

.emby-input:focus,
.emby-textarea:focus,
.emby-select-withcolor {
  border-color: #ffffff !important;
}


Full Header Tweak​
.skinHeader,
.mainDrawer,
.emby-input,
.emby-textarea,
.emby-select,
.navMenuOption-selected,
.cardBox,
.paperList {
  background: #ff9475;
}


Disable Image Carousel for Libraries​

This will make it so libraries and media fit neatly onto the homepage with no left to right scrolling required.

@media all and (min-width: 50em) {
  .homePage .emby-scroller {
    margin-right: 0;
  }
  .homePage .emby-scrollbuttons {
    display: none;
  }
  .homePage .itemsContainer {
    flex-wrap: wrap;
  }
}

Shift Scroller Buttons​
.emby-scrollbuttons {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  padding: 0;
  justify-content: space-between;
  pointer-events: none;
}

.emby-scrollbuttons-button {
  pointer-events: initial;
}

"Hotdogs and Catsup" Color Theme Example​

An example of a color theme.

.skinHeader,
.mainDrawer,
.emby-input,
.emby-textarea,
.emby-select,
.navMenuOption-selected,
.cardBox,
.paperList {
  background: #ff9475;
}

.emby-input,
.emby-textarea,
.emby-select {
  border-color: #fdbe7d;
}

.backgroundContainer.withBackdrop,
.backdropContainer,
.backgroundContainer {
  background: #fdbe7d;
}

#myPreferencesMenuPage .listItemBodyText,
.emby-tab-button[data-index='0'],
#myPreferencesMenuPage > div > div > div > a:nth-child(odd),
.button-submit,
.mainAnimatedPage *:nth-child(odd),
.dashboardGeneralForm *:nth-child(odd),
.mainDrawer-scrollContainer *:nth-child(odd),
.headerRight *:nth-child(odd) {
  color: red;
}

#myPreferencesMenuPage .listItemIcon,
.emby-tab-button[data-index='1'],
#myPreferencesMenuPage > div > div > div > a:nth-child(even),
.mainAnimatedPage *:nth-child(even),
.dashboardGeneralForm *:nth-child(even),
.mainDrawer-scrollContainer *:nth-child(even),
.headerRight *:nth-child(even) .cancel {
  color: yellow;
}

Floating Now Playing Controls​

/* fixed height for the bottom row */
:root {
  --element-fixed-top: 95px;
}

/* Now playing bar in the footer */
.nowPlayingBar {
       width: 650px;
       z-index: 10;
       position: fixed;
       top: 300px;
       height: 120px;
      border-style: solid;
      border-color: white;
      background-color: black;
      margin-left: 50%;
}

/* Only child of nowPlayingBar */
.nowPlayingBarTop {
     height: 5px !important;
     max-width: 500px
     top: 10px;
}

/* Song progress seekbar */
.nowPlayingBarPositionContainer {
     position: relative;
     top: 1.0em !important;
}

/* Container that holds album thumbnail, artist and album name */
.nowPlayingBarInfoContainer {
     position: fixed !important;
     left: 12px;
     top: 34px;
     height: 60px;
     width: 1100px;
}

/* Holds the next, previous track, play/pause, next and time elements */
.nowPlayingBarCenter {
     position: relative !important;
     left: 32px;
     top: var(--element-fixed-top);
     min-width: 500px;
}

/* Hold mute, volume slider container, repeat, favorite and remote control buttons */
.nowPlayingBarRight {
     width: 402px !important;
     left: -60px;
}

/* Mute button */
.muteButton {
    position: relative;
    top: var(--element-fixed-top);
}

/* Volume slider */
.nowPlayingBarVolumeSliderContainer {
     position: relative;
     left: -4px;
     top: var(--element-fixed-top);
}

/* Toggle repeat */
.toggleRepeatButton {
     position: relative !important;
     left: -20px;
     top: var(--element-fixed-top);
}

/* Favorite */
.nowPlayingBarUserDataButtons {
     position: relative;
     left: -4px;
     top: var(--element-fixed-top);
}

/* Remote control */
.remoteControlButton {
     left: -110px;
     top: var(--element-fixed-top);
}

Change Icon Pack​

You can choose between Material Icons (Icon Pack used by Jellyfin) and Fontawesome icons. Material Icons:

Outlined:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Outline.css");


Rounded:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/round.css");


Sharp:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Sharp.css");


Fontawesome Icons:

Solid:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Font%20Awesome/solid.css");


Regular:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Font%20Awesome/regular.css");


Light:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Font%20Awesome/light.css");


duotone:

@import url("https://cdn.jsdelivr.net/gh/prayag17/Jellyfin-Icons/Font%20Awesome/duotone.css");

Community Links​

Some links to places where custom CSS has been discussed and shared!

Community Posts​

Keep in mind that these posts may have been made under previous versions of Jellyfin. Some of these tweaks listed in these guides may not work anymore!

Custom CSS Guide
"But wait, there is more Custom CSS!"
Customizable Plug n' Play CSS for Jellyfin
Easy Jellyfin custom CSS
Custom CSS - updated for 10.5.0
Sharing even more custom CSS (and some fixes to previous stuff)
Posting my Jellyfin Custom CSS
Community Themes​
Ultrachromic - A custom theme for Jellyfin mediaserver created using CSS overrides
JellySkin - Vibrant Jellyfin theme with a lot a animations
JellyFlix - The Best Netflix Clone for Jellyfin
Jellyfin Netflix Dark - The Best Netflix Dark Theme for Jellyfin Around!
Dark and Green - A Emby like night mode skin
Hint of Green
Scyfin - A modern Jellyfin theme
Edit this page
Previous
Codec Support
Next
Jellyfin Vue
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/jellyfin-vue

Skip to main content
ClientsJellyfin Vue
On this page
Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

NOTE

Jellyfin Vue is not planned or targeted to replace the main Jellyfin Web client, and is not feature-complete.

Below are concise instructions to get your own instance of Jellyfin Vue up and running. If you identify with at least one of the following options:

Want to try it quickly for the first time
Are not sure whether you want to deploy your own instance
Don't need to go beyond user customization to change app-wide behaviour.
Have a working HTTPS setup.

You're probably better using our hosted instance. More info at Jellyfin Vue's repository.

Deployment
CAUTION

Since Jellyfin Vue is just an interface for a Jellyfin server, all of these instructions assume that you already have a server up and running. Set it up now if you haven't already.

RECOMMENDED: Using Docker​
In case you don't have Docker, follow the official installation guide first. Learning about Compose is also recommended.
Docker Compose is now shipped with Docker, so you don't need to install it. It's recommended that you uninstall the old docker-compose.
version key is deprecated in Docker Compose, hence not included below.

We're going to use the following docker-compose.yml as a starting point:

services:
  jellyfin_vue:
    container_name: jellyfin_vue
    image: ghcr.io/jellyfin/jellyfin-vue:unstable
    restart: always
    ports:
      - 8080:80
    labels:
      - "com.centurylinklabs.watchtower.enable=true"

  watchtower:
    container_name: watchtower
    image: ghcr.io/containrrr/watchtower
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      TZ: Europe/Madrid
      WATCHTOWER_CLEANUP: 1
      WATCHTOWER_INCLUDE_RESTARTING: 1
      WATCHTOWER_POLL_INTERVAL: 60
      WATCHTOWER_LABEL_ENABLE: 1
    # Needed so watchtower doesn't restart-loop when updating itself
    restart: on-failure

SUCCESS

Getting things up and running is as easy as doing docker compose up -d with your terminal located where the docker-compose.yml file is.

With this compose file:

Jellyfin Vue will be accessible on 8080 port of the machine that's running the containers
Watchtower takes care of updating the container to the latest commit available on the repository. This is a good idea because:
As of now, stable releases don't exist and there have only been prereleases that don't necessarily meet a quality criteria, but major development milestones.
Only the latest unstable image is supported.

After accessing the instance in your browser of choice, you'll be prompted to add a server. You can use your own server or our demo instance, located at https://demo.jellyfin.org/stable

NOTE

The server address you need to type is relative to the device you're accessing Jellyfin Vue. For instance, if your Jellyfin Server is located at 192.168.0.10 and you have deployed Jellyfin Vue to that same server, and your client is 192.168.0.20, the address you need to input is http://192.168.0.10, not http://127.0.0.1 or http://localhost.

You can learn more about how the connection to your server works in Jellyfin's Vue repository privacy disclaimer

Using environment variables​

This is an example of how environment variables are set in the container by adding the following keys to the jellyfin_vue definition in the above docker-compose.yml:

environment:
  HISTORY_ROUTER_MODE: 1


See the complete reference of environment variables available to further customize Jellyfin Vue to your liking at Jellyfin Vue's wiki.

Using your own webserver​

Since Jellyfin Vue is an SPA web application, you can use any web server to serve it: Apache, nginx (the one used in Jellyfin's Vue docker image), Traefik, etc...

If you already have a reverse proxy set up, do you want to do more complex stuff that it's out of the scope of this documentation like serving at a subpath, in another subdomain, etc..., you might want to have Jellyfin Vue served by your own webserver instead of the nginx instance shipped with the Docker image.

To achieve that, in the jellyfin_vue service definition of the docker-compose.yml shown above:

Remove the ports key.
Add the following keys, replacing _path_ with the folder where your web server expects Jellyfin Vue's assets:
network_mode: none
volumes:
  - _𝘱𝘢𝘵𝘩_:/dest
# This makes the container do nothing and sleep forever,
# frontend will be copied to _𝘱𝘢𝘵𝘩_ and will be served by your web server
command: /bin/sh -c 'rm -rf /dest/* && cp -r . /dest && sleep infinity'



This approach:

Keeps the client always updated in a hassle-free way, as explained above.
In case you use environment variables, they will still be applied.
Manually​
CAUTION

Make sure you understand the implications before using these methods first. None of them are supported by Jellyfin Vue.

docker run​

In case you don't want to use Docker Compose or automated updates, but still use Docker, this command is enough:

docker run -d -p 8080:80 ghcr.io/jellyfin/jellyfin-vue:unstable

From source / build output​
INFO

This might not be necessary if you just want to test a Pull Request. Check these instructions instead

DANGER

By default, never trust any assets given by anyone outside the official channels if you can't inspect the source code first. They might compromise your system or track your activity!

Since Jellyfin Vue is a web application, using it it's a matter of setting up your own web server and pointing it to Jellyfin Vue's assets. You can get them:

By building your own version from our source. The repository's wiki has instructions for setting up the development environment.
By getting them from GitHub's Actions artifacts.
Although those artifacts are built in our repository's CI/CD, some runs are sourced from Pull Requests created by external contributors that might not be good actors!
All artifacts generated by GitHub Actions are built with provenances.
Our official Docker image is built from GitHub Actions and all the process is transparent and can be audited.
Other documentation​

The rest of the documentation about Jellyfin Vue can be found on it's wiki.

You can check GitHub Packages (GHCR) (recommended) or DockerHub for all the tagged Docker images.

Edit this page
Previous
CSS Customization
Next
Kodi
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/kodi

Skip to main content
ClientsKodi
On this page
Kodi
Add-on Repository​

There are two different Kodi add-ons that serve slightly different use cases.

Jellyfin for Kodi - This add-on syncs metadata from selected Jellyfin libraries into the local Kodi database. This has the effect of making interacting with it feel very much like vanilla Kodi with local media (shows up under Movies/TV Shows on the home screen by default, virtually no delay, etc). However, it also tends to consume the database and not share well, so if you have local media or something else that interacts with the database directly, you will have conflicts and it will not be happy. The sync process can take some extra time on Kodi startup if you do not leave it running 24/7, but it is mostly in the background while Kodi is running.
JellyCon - Behaves more like a standard Kodi streaming add-on. Media is accessed primarily by going through the Add-ons -> JellyCon menu, however you can set up menu options to link to it and show info on the home screen. It also allows easier switching between multiple Jellyfin servers or users since it doesn't have to rely on syncing all the metadata down. By not having metadata synced, it has to request info from the server which can take a bit more time when you are browsing (typically only a second or two in my testing), but you don't have to wait for the database to sync or keep it up to date.
Install Add-on Repository​

The most convenient install method of our Jellyfin add-ons is to use the official Kodi Jellyfin Repository. Using this repository allows for easy install of our add-ons, as well as automatically keeping the add-ons up to date with the latest version. Any other Jellyfin related add-ons that may be built in the future will also be available here.

The installation method for the repository varies depending on what kind of device you're using, outlined below.

General Use Devices (PCs and Tablets)​
Download the repository installer found here.
It will be saved as repository.jellyfin.kodi.zip
Install the Jellyfin repository.
Open Kodi, go to the settings menu, and navigate to "Add-on Browser"
Select "Install from Zip File"
If prompted, enter settings and enable "Unknown Sources", then go back to the Add-on Browser
Select the newly downloaded file and it will be installed
"Embedded" Devices (Android TV, Firestick, and other TV Boxes)​
Open Kodi, go to the settings menu, and navigate to "File manager"
Select "Add source"
In the text box, enter https://kodi.jellyfin.org
Enter a name for the data source, such as "Jellyfin Repo" and select Ok
From the settings menu, navigate to "Add-on Browser"
Select "Install from Zip File"
If prompted, enter settings and enable "Unknown Sources", then go back to the Add-on Browser
Select the data source you just added
Install repository.jellyfin.kodi.zip
Jellyfin for Kodi​
TIP

It is highly recommended to install the Kodi Sync Queue plugin into the Jellyfin server as well. This will keep your media libraries up to date without waiting for a periodic re-sync from Kodi.

CAUTION

Remote Kodi databases, like MySQL, are not supported. A local SQLite database is required (this is the default).

Jellyfin for Kodi Overview​

This add-on syncs metadata from selected Jellyfin libraries into the local Kodi database. This has the effect of making interacting with it feel very much like vanilla Kodi with local media (shows up under Movies/TV Shows on the home screen by default, virtually no delay, etc). However, it also tends to consume the database and not share well, so if you have local media or something else that interacts with the database directly, you will have conflicts and it will not be happy. The sync process can take some extra time on Kodi startup if you do not leave it running 24/7, but it is mostly in the background while Kodi is running.

Media in Kodi's database is automatically kept in sync with the server in one of several ways:

Startup sync - Each time Kodi starts, it will reach out to the Kodi Sync Queue plugin in the server and request all updated media since its last check-in time (when Kodi was last shut down).
Live sync - This happens while Kodi is running. When the server updates an item, it will send a notification to Kodi over a websocket connection that it has new media that needs to be updated.
Install Jellyfin for Kodi Add-on​
Install Jellyfin for Kodi.
From within Kodi, navigate to "Add-on Browser"
Select "Install from Repository"
Choose "Kodi Jellyfin Add-ons", followed by "Video Add-ons"
Select the Jellyfin add-on and choose install
Within a few seconds you should be prompted for your server details.
If a Jellyfin server is detected on your local network, it will displayed in a dialog
If a Jellyfin server is not detected on your local network, select "Manually Add Server". Enter your server info into the text field.
Enter the server name or IP address and the port number (default value is 8096)
Host: 192.168.1.10:8096
If using SSL and a reverse proxy, enter the full URL in the "Host" field
Host: https://jellyfin.example.com
Note that if you have a baseurl set, you should append that value to the end of the host field.
Host: 192.168.0.10:8096/jellyfin
Select user account and input password, or select "Manual Login" and fill in your user information
Once you are successfully authenticated with the server, you'll be asked about which mode you'd like to use, Add-on vs Native, which are outlined below.
Add-on Mode​

Add-on mode uses the Jellyfin server to translate media files from the filesystem to Kodi. This is the default setting for the add-on, and is sufficient for most use cases. It will work both on the local network and over the Internet through a reverse proxy or VPN connection. Providing network speed is sufficient, Kodi will direct play nearly all files and put little overhead on the Jellyfin server.

To use Add-on mode, simply choose "Add-on" at the dialog and proceed to Library Syncing

Native Mode​
CAUTION

Do not use Native mode! Use Addon-mode instead.

Jellyfin 10.10 no longer provides the shared network folder via the API, and as such native mode does not get the required information to function.

Native mode accesses your media files directly from the filesystem, bypassing the Jellyfin server during playback. Native mode needs more setup and configuration, but it can, on rare occasions, lead to better performance where network bandwidth is a limitation. It requires your media to be available to the device Kodi is running on over either NFS or Samba, and therefore should only be used on a LAN or over a VPN connection.

To use Native mode, first set up your libraries in Jellyfin with a remote path.

CAUTION

Starting from Jellyfin 10.9 it is no longer possible to set the shared network folder.

In the Jellyfin server, navigate to the Libraries section of the admin dashboard.
Select an existing library (or create a new one)
Select the media folder
Enter the path to your network share in the "Shared network folder" textbox
Possible formats:
NFS
nfs://192.168.0.10:/path/to/media
Samba
Guest User - \\192.168.0.10\share_name
Custom User (Not Recommended) - \\user:password@192.168.0.10\share_name
It's more secure to use the generic Guest mapping here and specify credentials from within Kodi
Mounted share
If you have mounted your network share, you can reference the local mount point. This can be more performant but generally means it only works for one type of operating system, given the difference between the file systems
/mnt/media (Linux)
Z:\media (Windows)
/Volumes/media (Mac OS)
Configure libraries in Kodi
Skip the initial library selection. We need to add file shares to Kodi first
Within Kodi, navigate to the settings menu and select "File manager"
Select "Add source"
Select "Browse" and "Add network location"
Create either a NFS or SMB location from the selection box and fill in the necessary information about your network share
If you are using a mounted share, browse to the mount point on your file system rather than the network share
Select your newly created location and choose "Ok"
Give your media source a name and choose "Ok"
Go to Add-ons -> Jellyfin -> Manage Libraries -> Add Libraries
Proceed to Library Syncing
Library Syncing​

This screen allows you to choose which libraries to sync to your Kodi install. This process will copy metadata for your media into the local Kodi database, allowing you to browse through your media libraries as if they were native to your device.

Either choose "All" or select individual libraries you would like synced and select OK. Syncing the metadata will start automatically. The duration of this process varies greatly depending on the size of your library, the power of your local device, and the connection speed to the server.

You can still access any libraries that have not been synced by going through the Jellyfin add-on menu. These unsynced libraries will be labeled as "dynamic."

If an error occurs during syncing, enable debug logging in the Jellyfin add-on in Kodi and if in a Unix-like OS, set the log level of Samba to 2 to see if there are issues authenticating.

Multiple User Accounts​

The Jellyfin for Kodi add-on doesn't natively handle multiple user accounts. Fortunately, Kodi has a built-in method of handling this called profiles. Information about this can be found on the Profiles page of the Kodi Wiki. Once profiles have been created, you must install the Jellyfin add-on and go through the installation steps above for each user profile. When you switch Kodi profiles, you will also switch Jellyfin users. You can tell Kodi to bring you to a profile login screen during startup by going to the Profiles section inside of the Settings page and checking the box for "Show login screen on startup."

TIP

Kodi's default skin does not display all unicode characters. To display unicode characters the skin's font must be changed.

Multiple Clients​

When using multiple Kodi clients do not copy Kodi's database (i.e. myvideosXYZ.db, jellyfin.db) files from one client to the other to try and reduce initial syncing time. This will partially work, but it will cause conflicts between clients and the sync process from the server will not work properly.

JellyCon​
JellyCon Overview​

JellyCon behaves more like a standard Kodi streaming add-on. Media is accessed primarily by going through the Add-ons -> JellyCon menu, however depending on what skin is being used custom shortcuts and widgets can be added to the home menu. It also allows easier switching between multiple Jellyfin servers or users since it doesn't have to rely on syncing all the metadata down. By not having metadata synced, it has to request info from the server which can take a bit more time when you're browsing, but you don't have to wait for the database to sync or keep it up to date. It is also compatible with other media sources and can be used with other add-ons without issue.

Install JellyCon Add-on​
Install JellyCon Add-on
From within Kodi, navigate to "Add-on Browser"
Select "Install from Repository"
Choose "Kodi Jellyfin Add-ons", followed by "Video Add-ons"
Select the JellyCon add-on and choose install
Within a few seconds you should be prompted for your server details.
If a Jellyfin server is detected on your local network, it will be displayed in a dialog. Otherwise, you will be prompted for a URL
Select a user from the list, or Manual Login to type in a username/password
Configuring Home​

Many Kodi skins allow for customizing of the home menu with custom nodes and widgets. However, all of these use slightly different layouts and terminology. Rather than a step-by-step guide, this section serves as an barebones introduction to customizing a skin.

Examples​

If you would like a link on the home screen to open a library in your Jellyfin server called "Kid's Movies", you would point the menu item to the path: Add-On -> Video Add-On -> JellyCon -> Jellyfin Libraries -> Kid's Movies -> Create menu item to here.

Beyond just modifying where the home menu headers go, many skins also allow you to use widgets. Widgets help populate the home screen with data, often the posters of media in the selected image. If you would like to display the most recent movies across all of your Jellyfin libraries on the home screen, the path would be: Add-On -> Video Add-On -> JellyCon -> Global Lists -> Movies -> Movies - Recently Added (20) -> Use as widget

Another common use case of widgets would be to display the next available episodes of shows that you may be watching. As above, this can be done both with individual libraries or with all libraries combined:

Add-On -> Video Add-On -> JellyCon -> Jellyfin Libraries -> Anime -> Anime - Next Up (20) -> Use as widget
Add-On -> Video Add-On -> JellyCon -> Global Lists -> TV Shows -> TV Shows - Next Up (20) -> Use as widget
Edit this page
Previous
Jellyfin Vue
Next
Mopidy
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/mopidy

Skip to main content
ClientsMopidy
On this page
Installing Mopidy Extension

The Mopidy Jellyfin extension is available to install from PyPi using pip.

General​

For general use computers, such as workstations or laptops, it's recommended to install Mopidy extensions in user mode. Installing python packages from pip using sudo or root permissions can lead to conflicts with your package manager in the future.

Install Mopidy using your method of choice using the official documentation

Install the Jellyfin extension for Mopidy:

pip3 install --user mopidy-jellyfin


(Optional) Install other mopidy related packages:

pip3 install --user mopidy-mpd mopidy-musicbox-webclient


Configure your mopidy.conf located at $HOME/.config/mopidy/mopidy.conf See Config File

There may be a need to install extra gstreamer codecs if they're not already on your system, but these are highly variable and depend on your hardware and distro

Start the program by running mopidy from a terminal

See Usage

Raspberry Pi (Remote Controlled Speakers)​

Utilizing a Raspberry Pi (or other small form factor computer) it's possible to use Mopidy to build a set of standalone smart speakers connected to your Jellyfin server.

Grab the latest raspbian image. Unless you have a need for a GUI, the 'Lite' image is plenty for this project.

Install the image to the SD card (See the official documentation)

Install Mopidy from their apt repo to ensure we get the latest version

Install required OS packages:

sudo apt install mopidy mopidy-mpd gstreamer1.0-plugins-bad python3-pip


Install the Jellyfin extension and any other Mopidy related packages you may want:

sudo pip3 install mopidy-jellyfin mopidy-musicbox-webclient


Configure your mopidy.conf located at /etc/mopidy/mopidy.conf: See Config File

Enable and start the mopidy service:

sudo systemctl enable --now mopidy


See Usage

Config File​

The config file for Mopidy is divided into sections in an INI format. An example for Jellyfin is shown here.

[jellyfin]
hostname = Jellyfin server hostname
username = username
password = password
libraries = Library1, Library2 (Optional: will default to "Music" if left undefined)
albumartistsort = False (Optional: will default to True if left undefined)
album_format = {ProductionYear} - {Name} (Optional: will default to "{Name}" if left undefined)

libraries determines what is populated into Mopidy's internal library (view by Artists/Album/etc). Using the file browser will show all music or book libraries in the Jellyfin server
albumartistsort changes whether the media library populates based on "Artist" or "Album Artist" metadata
album_format can be used to change the display format of music albums when using the file browser view. Currently the only really usable fields are ProductionYear and Name

Other options that may be useful to include:

[mpd]
enabled = true
# Useful if you want to control this instance from a remote MPD client
hostname = 0.0.0.0
port = 6600
# This will help avoid timeout errors for  artists or folders with large amounts of files
connection_timeout = 300

# Used in the event you want to control this system from a web browser
[http]
hostname = 0.0.0.0
port = 6680


Be aware that Mopidy provides no security on open ports, so if you'll be running this in a public place you'll likely want to change 0.0.0.0 to 127.0.0.1 to prevent somebody else from hijacking your listening session.

Usage​

Once Mopidy is running, you can connect and control it with your client of choice. MPD clients will connect using port 6600 by default. Tested MPD clients include ncmpcpp and M.A.L.P. Web clients can be reached at http://localhost:6680, or http://$IP_ADDRESS:6680 if this is a remote system.

Upgrading​

When a new version of Mopidy Jellyfin is released, you can upgrade via pip using the --upgrade flag.

pip3 install --user --upgrade mopidy-jellyfin

Edit this page
Previous
Kodi
Next
Jellyfin Web Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#client-list

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#requirements-for-inclusion-in-all-clients

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/branding

Skip to main content
ContributingBranding
On this page
Branding
Usage of the Jellyfin name​

You are free to use the Jellyfin name to promote your project, with some restrictions:

Do not use the Jellyfin name in a way that would make the average user think you are associated with the project, unless permission was given by the Project Leader or Leadership Team.
Only include the Jellyfin name in your project's name in a way that makes it clear you are not affiliated with the Jellyfin project, and to indicate compatibility with Jellyfin (For example Awesome Client for Jellyfin).
Do not use the Jellyfin name in any context that promotes, allows or encourages piracy.
Do not wrongfully claim to be part of the Jellyfin team.
Writing Style​

As a general rule, Jellyfin should always be capitalized, but language, file, or system conventions trump Jellyfin naming conventions.

Specific examples include:

Writing referring to the project in the abstract should use capitalized Jellyfin at all times. I contribute to Jellyfin and you should too!
C# class and project names, including their files and directories, should use capitalized Jellyfin as required by the C# case standards (camelCase or PascalCase). Jellyfin.LiveTv, Jellyfin.sln
Other code elements, where the code formatting or style requires lowercase, should use lowercase jellyfin. jellyfinWebComponentsBowerPath
The Git repository and non-C# files inside of it should use lowercase jellyfin for convenience on case-sensitive filesystems. build-jellyfin.ps1
The final output binary, initscrips, and package names should use lowercase jellyfin for similar reasons as above. jellyfin.dll, jellyfin_3.5.2-1_all.deb, jellyfin.zip
Configuration directories can use either depending on operating system conventions. /var/lib/jellyfin, AppData/Jellyfin
The logo has no strict rules for capitalization, the style is dependent on aesthetics and font choice.
Icons and Other Assets​
WARNING

Jellyfin is currently rebranding, as such these guidelines (including the logo) are outdated. Join our #jellyfin-ui-ux chat on Matrix for any questions.

All iconography and other resources can be found in the jellyfin-ux repository.

Icons
Banners
Fonts
Logo​

When using the full version of the logo, the text should only be placed to the right of the icon.

 

The design for the logo uses a gradient for the infill, and if the non-transparent logo is chosen there is an optional background color.

Gradient Start: #AA5CC3
Gradient End: #00A4DC
Background Color: #000B25
Theme​
Background Color: #101010
Accent Color: #00A4DC
Fonts​

The banner uses the Plus Jakarta Sans font.

Edit this page
Previous
Contributing
Next
Development
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#requirements-for-inclusion-as-a-recommended-client

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#supported-browsers

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/clients/#additional-client-documentation

Skip to main content
Clients
On this page
Clients

Clients connect your devices to your Jellyfin server and let you view your content on any supported device.

NOTE

If you are interested in helping out, please see our contribution guide and feel free to contact us for more information!

Client List​

A list of all Jellyfin clients can be found on the main Clients page.

NOTE

Some clients that are no longer maintained can be found in the jellyfin-archive organization on GitHub.

INFO

Do you have a client that interfaces with Jellyfin and want to see it listed on the Clients page? Please verify it meets the requirements below and submit a pull request!

Requirements for Inclusion in All Clients​

Clients must meet the following guidelines for inclusion in the list of all clients:

Must be aligned with the Jellyfin Community Standards.
In particular, the client must NOT engage in, encourage, or facilitate piracy.
The developer must be in good community standing in accordance to the Community Standards.
Must adhere to the Jellyfin Branding Guidelines, including usage of the Jellyfin name, trademarks and icons.
This includes usage of the Jellyfin name or org.jellyfin namespace that could hinder the ability to publish an official client to a store in the future.
Must include first rate support for Jellyfin servers. (i.e. Support for Jellyfin should be a primary function or at the same level of integration of any other supported services.)
Must NOT be specific to or intended to promote a specific hosted Jellyfin server instance.
Must have clear licensing and be void of any known issues related to attribution, copyright, or license violations.

The final decision for inclusion is at the discretion of the Jellyfin Contributor Team following the decision-making guidelines in the Jellyfin Constitution.

Requirements for Inclusion as a Recommended Client​

The client must be a first-party client (meaning published and maintained by the Jellyfin team with source freely licensed and available in the Jellyfin GitHub organization).

OR

The client must fill a significant void in the current first-party client offerings. Must be a high-quality client on a popular platform.

Supported Browsers​

Our goal is to provide support for the two most recent versions of these browsers.

Firefox
Firefox ESR
Chrome
Chrome for Android
Safari for MacOS and iOS
Edge

Older browsers may be supported as a result of the needs of specific web-based clients, but full functionality is not guaranteed on their desktop version.

Additional Client Documentation​
📄️ Codec Support

The goal is to Direct Play all media. This means the container, video, audio and subtitles are all compatible with the client. If the media is incompatible for any reason, Jellyfin will use FFmpeg to convert the media to a format that the client can process. Direct Stream will occur if the audio, container or subtitles happen to not be supported. If the video codec is unsupported, this will result in video transcoding. Subtitles can be tricky because they can cause Direct Stream (subtitles are remuxed) or video transcoding (burning in subtitles) to occur. This is the most intensive CPU component of transcoding. Decoding is less intensive than encoding.

📄️ CSS Customization

In Dashboard > General, the "Custom CSS" field can be used to override current CSS in Jellyfin's stylesheet.

📄️ Jellyfin Vue

Jellyfin Vue is an experimental, alternative browser-based web client for Jellyfin written using Vue.js.

📄️ Kodi

Add-on Repository

📄️ Mopidy

The Mopidy Jellyfin extension is available to install from PyPi using pip.

📄️ Jellyfin Web Configuration

Editing

Edit this page
Previous
Managing Users
Next
Codec Support
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/users/adding-managing-users

Skip to main content
Server GuideUsersManaging Users
On this page
Managing Users

User management can be done under Users in the Dashboard. Here you can see your current users or add new ones. And manage your users' settings.

Adding a User​

To add a new user, click the + symbol at the top of the page. This will open a new page where you can enter the user's name as it will be either displayed on or has to be typed into login screen. By default, this will be displayed, but this can be changed at any point by modifying the user, explained further down.

Manage User Library Access​

By default, the enables access to all libraries option will be enabled, disabling this option will enable you to give the user access rights per library, libraries can consist of several folders. When adding new libraries any user that did not have access to all libraries will not receive the rights to open the new library, but this can be changed at any point by modifying the user, explained further down.

Manage a User​

To manage a user either click on their portrait to go straight to their Profile tab, or click the ... symbol inside that user's portrait. The later will open a small submenu with the options Open Library access Parental control, and delete. Except for delete, which does the obvious, these options will lead to different tabs but are otherwise all on the same page. Open corresponds to the Profile tab, Library access to access, Parental control to Parental Control, and there is an additional fourth tab Password for Password control. Changes to any option on any of these tabs need to be saved using Save at the bottom of the page.

Profile​

Directly under the tabs you have a link to Edit this user's profile, image and personal preferences. Clicking that allows you to change the user's personal settings, any setting here can be changed by both user and admin.

Under name you can change the user's name as it will be either displayed on or has to be typed into login screen.

Under Authentication Provider you have the option to change the backend that handles the login, by default the only option here will be default which means Jellyfin will handle this user, this option is sufficient for most use cases. Currently, the only other possibility is to have a LDAP server handle the login by installing the LDAP-Auth plugin. Note that if you wish to change a user's provider to LDAP after creating it in Jellyfin the username needs to be identical to the user's UID in LDAP, including capitalization.

Allow remote connections to this Jellyfin Server. Unchecking this option will block login attempts this user makes from outside the networks defined as local, by default this will only be the subnet assigned to your network. But more can be added.

Feature Access​

For the following options it should be noted that if you never set up Live TV, users are blocked regardless of the state. See the docs page for Live TV » Live TV for more information.

Allow Live TV access Unchecking this option will block the user's access to watch Live TV.

Allow Live TV recording management Unchecking this option will block the user's access to set recording schedules.

Media Playback​

Allow media playback Unchecking this option will block the user's access to media libraries, this does not include Live TV.

NOTE

More information about transcoding can be found here.

Allow audio/video playback that requires transcoding Unchecking this option will block the user's access to video playback that requires transcoding.

Allow video playback that requires conversion without re-encoding Unchecking this option will block the user's access to video playback that requires conversion without re-encoding.

Internet streaming bitrate limit (Mbps) Under this option you can set a bitrate limit per stream for all out of network devices.

Allow Media Deletion From​

These checkboxes allow a user to remove media for either All libraries, or per Library. Be careful when enabling these as some plugins enable automatic removal of media after watching.

Remote Control​

These allow a user to control other devices that are currently logged into Jellyfin, for example if you run a separate client on a HTPC without remote control.

Allow remote control of other users Allows this user to control what other users are playing and send messages but does not give them administrative rights.

Allow remote control of shared devices Allows this user to control unclaimed DLNA devices, and devices they are logged in to at the moment.

Download & Sync​

These allow a user to download media. Syncing and Transcoding are currently not available.

Additional options​

Allow media conversion This option is currently not available.

Allow social media sharing Allows this user to share the url to web pages containing media information, for example when viewing information about a movie, series, season, or episode.

Disable this user Blocks the user from logging in, existing connections will be abruptly terminated.

Hide this user from login screens Useful for private or hidden administrator accounts. The user will need to sign in manually by entering their username and password. All newly created users are hidden by default.

Locking and Unlocking users​

Locking

Failed login attempts before user is locked out Determines how many incorrect login attempts can be made before lockout occurs, disabling the user. 0 means inheriting the default of 3 for non-admin and 5 for admin, -1 disables lockout

When a user is locked out after the set amount of attempts the admin has determined for that account, the user will receive the following message when trying to login to the Jellyfin instance:

Connection Failure
We\'re unable to connect to the selected server right now. Please ensure it is running and try again.


Unlocking

The unlocking of a user is a manual process for the Jellyfin administrator. When a user is locked-out a message of the lockout appears on the activity feed on the administrator dashboard. To unlock the user, the administrator needs to navigate to the profile of the locked out user. When on the profile of the locked-out user, the following message should appear:

This user is currently disabled
See below to reenable


To reenable the user the administrator must navigate to the Disable this user option in the Additional options section uncheck the checkmark and hit Save. The disabled user should be able to login again.

Library Access​

These options allow you to restrict access to libraries, or from devices.

Enable access to all libraries By default the Enable access to all libraries option will be enabled, disabling this option will enable you to give the user access rights per library, libraries can consist of several folders. When adding new libraries any user that did not have access to all libraries will not receive the rights to open the new library.

Enable access from all devices By default the Enable access from all devices option will be enabled, disabling this option will enable you to give the user access rights per device and logins from new devices are blocked until they've been approved here.

Parental Control​

These options allow you to restrict access to specific content by this user or the timeframe in which they may access. Content that matches these restrictions will be hidden, while the timeframe effectively disables the user.

Maximum allowed parental rating Allows you to select the highest rating allowed to show up for this user.

Block items with no or unrecognized rating information Allows you to always hide items with no or unrecognized rating information.

Block items with tags Allows you to always hide items when they contain specific tags, you can add tags to items by editing their metadata.

Access Schedule Allows you to set the timeframe(s) where this user is allowed to login, media can only play during the timeframe and will be stopped past it.

Password​

Allows you to set or change the user's password. Note that users can change their own passwords in their personal settings.

Reset Password will allow the user to log in without giving a password.

If the user has a password, additional options are shown.

Edit this page
Previous
Users
Next
Clients
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#__docusaurus_skipToContent_fallback

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/upgrades

Skip to main content
TestingUpgrades & Downgrades
On this page
Upgrades & Downgrades

This document provides details on upgrading and downgrading between Stable and Unstable releases, and why you might want to do so.

Stable vs. Unstable​

Which install type to pick depends on your needs; ultimately, Unstable is for testing new things, while Stable is for running a server for others to use reliably.

Stable provides the most consistent and predictable user experience. A particular major release (e.g. 10.8.z, 10.9.z) will not introduce, remove, or change major features or functionality (with minor caveats for security). Bugfixes are provided in point releases, which are released as needed during the lifecycle of the major release in response to bugfixes and security advisories. Most users should generally use Stable releases, as this will ensure maximum uptime and consistency for your end users.

Unstable provides the most up-to-date, cutting edge features, but may have rapid and unpredictable breaking changes or serious bugs, and has more limited client support as API changes are made over time. Unstable releases are provided via weekly binary builds on Monday mornings around 5:00 AM UTC, or by building your own packages from the master code branches.

In addition, Unstable is used to test forthcoming releases during the major release cycle since we provide no beta builds. If you want to help us test upcoming releases - and we ask that anyone able to do so does - you will need to run the Unstable builds for at least some amount of time, before switching back to Stable on release.

What do you mean "no beta builds"​

Because of the massive complexity of packaging Jellyfin for multiple unique platforms, not to mention 3rd party builds providing several more, with our 10.9.0 release and beyond we have decided not to provide explicitly tagged pre-release builds. This is quite unusual for free-and-open-source software, but is a practical necessity to streamline our major releases and increase their cadence.

To compensate, we use a feature freeze window on major breaking changes before major releases, and leverage our scheduled weekly Unstable builds as an alternative. Before each major release, we will announce a schedule of the upcoming Unstable releases and how to map them to hypothetical "beta" and "release candidate" pre-release versions. For instance, with a 4 week freeze, we might consider the first 3 weeks of Unstable builds as "beta" and the last week as "release candidate". If you want to get in some early testing, you can try it out in the first 3 weeks; if you'd rather wait until things are mostly settled, wait until the last week.

While this system isn't perfect, it does streamline versioning significantly, helps us avoid a 3rd repository component/label, and helps give Unstable builds a bit more love around releases, while having very little additional administrative overhead versus explicit pre-release versions.

Warnings & Notes​
Make Backups​

Generally, once you've upgraded to an Unstable version from a given Stable version, you can't simply downgrade back to that original Stable version. This is because Unstable versions will likely have made changes to the database schemas, configuration entries, and other metadata, which the older Stable version cannot handle.

The only way to downgrade from an Unstable to an older Stable is to restore from a backup, or to completely clear out your data and start again. The exception is migrating from an Unstable to a newly released Stable major version at the time that Stable version is released.

Always make a backup of your instance data and configuration directories before upgrading to Unstable for any reason. You never know what might go wrong, be it a failure in migrations, a breaking bug that forces a downgrade back, or some other corruption. This applies even for testing right before a Stable release. It is always better to have a backup ready, perform some testing immediately after upgrading, and revert if things aren't working right - after reporting your bug, of course!

You can utilize certain plugins to help with this, for instance the Trakt plugin to synchronize watched status, but this will not necessarily preserve everything. So be careful here, and know the limitations before proceeding.

Follow the process listed in the documentation here for more details.

Disable Automatic Updates on Unstable​

Running with automatic updates while on Unstable, or during a pre-release testing of Unstable, can cause problems. Always ensure you update manually and test things out afterwards. We generally recommend against automatic updates in general even on Stable, as it can result in missed release notes from new versions, but we understand how desirable this can be; avoid the temptation when running Unstable though to avoid missing important changes.

Upgrading from Stable to Unstable​

The exact details of this process depend on your platform and installation method. This document will detail the two most popular: Debian/Ubuntu packages via our repository, and Docker. The process is generally the same for others (e.g. manual downloads, Windows installers, etc.) with the exact details changed; for the specifics of individual platforms, please see the child articles under Testing Jellyfin Server.

We assume you are already running Jellyfin Stable releases.

Plugins (Stable to Unstable)​

We provide plugins for Stable and Unstable releases in separate repositories with separate versioning. This is done to avoid accidental incompatibilities and allow us to release Unstable plugins at a much quicker cadence in response to ongoing changes in the master branch. You will need to switch to the Unstable plugin repository if you use any plugins. If you do this before upgrading, plugins will be automatically upgraded afterwards.

Plugins are versioned in such a way that Unstable plugins will seamlessly upgrade from the latest Stable plugin version to an Unstable plugin version, and then permit a seamless upgrade from the Unstable version to the next Stable version (e.g. 13.0.0.0 Stable -> 13.2024.0429.0 Unstable -> 14.0.0.0 Stable).

In your Jellyfin server instance, navigate to the Dashboard -> Plugins -> Repositories.

Delete the default "Stable" repository by clicking the trashcan button.

Add a new repository with the "+" button. Name the repository whatever you wish, and use the following as the Repository URL.

https://repo.jellyfin.org/files/plugin-unstable/manifest.json

Debian/Ubuntu Repositories (Stable to Unstable)​

Edit your /etc/apt/sources.list.d/jellyfin.sources and add unstable to the Components: line. Do not remove main, simply add unstable after it.

...
Components: main unstable
...


Run sudo apt-get update.

Run sudo apt-get upgrade and apply the upgraded Jellyfin packages. Jellyfin will automatically restart.

Once Jellyfin starts, if you updated your plugin repository above before upgrading, plugins will automatically upgrade to their newer Unstable versions. Wait until Jellyfin finishes starting, then restart the service again (either via the UI's "Restart" button or "systemctl" commands) to finish the upgrade.

Docker (Stable to Unstable)​
Stop your Jellyfin container.
Pull the jellyfin/jellyfin:unstable image tag.
Start a new Jellyfin container with the updated image.
Upgrading from Unstable to Stable upon Release​

When a new major version of Jellyfin is released, it is possible - until the next published Unstable release - to directly upgrade from Unstable to the new Stable. This provides a migration path for Unstable testers before the release to move to the actual Stable release.

As part of the release process, Unstable weekly builds will be temporarily disabled for 1-2 weeks to provide a window for this to occur, after which they will resume as normal. If you wish to remain on Unstable, you can simply wait this out, otherwise follow the process here to "upgrade" back to the new Stable version.

The exact details of this process depend on your platform and installation method. This document will detail the two most popular: Debian/Ubuntu packages via our repository, and Docker. The process is generally the same for others (e.g. manual downloads, Windows installers, etc.) with the exact details changed; for the specifics of individual platforms, please see the child articles under "Testing Jellyfin Server".

We assume you are already running Jellyfin Unstable releases.

Plugins (Unstable to Release)​

We provide plugins for Stable and Unstable releases in separate repositories with separate versioning. You will need to switch (back) to the Stable plugin repository if you use any plugins, to avoid installing future incompatible versions of the Unstable plugins onto your Stable install. Note that plugins may not be available for a few hours to a few days after a new release, depending on the plugin; if they are already ready and you follow these steps, they should automatically upgrade when switching back to Stable.

Plugins are versioned in such a way that Unstable plugins will seamlessly upgrade from the latest Stable plugin version to an Unstable plugin version, and then permit a seamless upgrade from the Unstable version to the next Stable version (e.g. 13.0.0.0 Stable -> 13.2024.0429.0 Unstable -> 14.0.0.0 Stable).

In your Jellyfin server instance, navigate to the Dashboard -> Plugins -> Repositories.

Delete the "Unstable" repository by clicking the trashcan button.

Add a new repository with the "+" button. Name the repository whatever you wish ("Stable" is the default), and use the following as the Repository URL.

https://repo.jellyfin.org/files/plugin/manifest.json

Debian/Ubuntu (Unstable to Release)​

Edit your /etc/apt/sources.list.d/jellyfin.sources and remove unstable from the Components: line.

...
Components: main
...


Run sudo apt-get update.

Run sudo apt install jellyfin=<version> jellyfin-server=<version> jellyfin-web=<version>. Replace <version> with the desired version number, for example, 10.9.1+ubu2204. This will reinstall the Stable version over top of the Unstable version. Jellyfin will automatically restart.

Example: sudo apt install jellyfin=10.9.1+ubu2204 jellyfin-server=10.9.1+ubu2204 jellyfin-web=10.9.1+ubu2204

Docker (Unstable to Release)​
Stop your Jellyfin container.
Pull the jellyfin/jellyfin:latest image tag.
Start a new Jellyfin container with the updated image.
Post-Install (Unstable to Release)​
Once updated plugins become available, Jellyfin should automatically upgrade these to the next stable version as mentioned above. If you find any that do not, try to upgrade them manually.
Downgrading from Unstable to an older Stable​

As mentioned above, this process requires restoring from a backup taken before you first upgraded to Unstable.

The exact details of this process depend on your platform and installation method. This document will detail the two most popular: Debian/Ubuntu packages via our repository, and Docker. The process is generally the same for others (e.g. manual downloads, Windows installers, etc.) with the exact details changed; for the specifics of individual platforms, please see the child articles under Testing Jellyfin Server.

We assume you are already running Jellyfin Unstable releases.

Debian/Ubuntu (Unstable to Old Stable)​

Stop Jellyfin using the service manager (sudo service jellyfin stop or similar). Ensure Jellyfin has actually stopped.

Restore your backup of the configuration and data directories. Ensure you remove the current contents entirely (or move it out of the way) first.

Edit your /etc/apt/sources.list.d/jellyfin.sources and remove unstable from the Components: line.

...
Components: main
...


Run sudo apt-get update.

Run sudo apt-get install --reinstall jellyfin jellyfin-server jellyfin-web. This will forcibly reinstall the new Stable version over top of the Unstable version. Jellyfin should automatically start; if not, start Jellyfin using the service manager (sudo service jellyfin start or similar).

Docker (Unstable to Old Stable)​
Stop your Jellyfin container.
Restore your backup of the configuration and data directories. Ensure you remove the current contents entirely (or move it out of the way) first.
Pull the jellyfin/jellyfin:latest image tag.
Start a new Jellyfin container with the updated image.
Post-Install (Unstable to Old Stable)​
Your backup should have restored your original plugin repository and plugin versions. If not, you may need to remove any Unstable plugins and reinstall them; configuration will be preserved here.
Edit this page
Previous
Testing
Next
Testing Jellyfin Server
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/server/

Skip to main content
TestingTesting Jellyfin Server
On this page
Testing Jellyfin Server
BACKUPS!

Unstable often makes irreversible changes to existing Jellyfin setups. Please make regular backups of Jellyfin files. Read More

Weekly Unstable Build​

The weekly unstable builds are generated every Monday 5:00 AM UTC. Testing using the Unstable builds can not only test Jellyfin itself, but also help identify issues with packaging.

To install them, navigate to our downloads page and choose Server, choose your platform, then choose Unstable. The choices have to be made in this order. After choosing, scroll down and find the installation method you would like to use.

Follow the steps in the Upgrade & Downgrade documentation for more detailed instructions.

Testing from Master Branch​

The Master branch of the server can be used to obtain the absolute bleeding edge. This is only intended for developers. Further info can be found in the packaging repository itself and in the contributing docs.

Edit this page
Previous
Upgrades & Downgrades
Next
macOS
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/web/

Skip to main content
TestingTesting Jellyfin Web Clients
On this page
Testing Jellyfin Web Clients
Weekly Unstable Builds​

Weekly unstable builds ship Jellyfin Server and Jellyfin Web in a complete package. Please refer to Testing Jellyfin Server for more info.

Testing pull requests from Cloudflare Pages Deployments​

Each pull request of Jellyfin Web and Jellyfin Vue is automatically deployed to Cloudflare Pages. Please follow the steps below on how to test them.

Find the pull request you would like to test / review in the list of open pull requests: pull requests for Jellyfin Web, pull requests for Jellyfin Vue

On most pull requests, there should be a comment from jellyfin-bot with a link to a deployed version of the current pull request. Click on the link next to Preview URL to open a hosted instance of the current pull request. 

NOTE

Some pull requests might not have this comment, or the link might otherwise not work. To test out these pull requests, they will have to be built manually.

Clicking on the link in the comment will open an instance of the client you are testing. For Jellyfin Web, it will be linked automatically to our demo server. For Jellyfin Vue, you can connect to the demo server with this address: https://demo.jellyfin.org/unstable/. The credentials will be provided on the login page.

If you wish to connect to a different server, click the Change Server button in the apps at the login screen. Alternatively, enter a different server address in Jellyfin Vue when first prompted to add a server.

CAUTION

Using a development version of clients may lead to data corruption or loss on the server. Please use a dedicated test server and make regular backups of Jellyfin files.

DANGER

Although Cloudflare Pages deployments from Pull Requests are built into our CI/CD workflow in a completely transparent and auditable manner, some of them may come from external contributors that might not be good actors!.

By default, never trust any artifacts given by anyone outside the official channels if you can't inspect the source code first. They might compromise your system or track your activity!

Testing from source code​

Jellyfin web clients can be hosted as a standalone application without being associated with a Jellyfin server. In that case, a separate Jellyfin server will be needed.

"Test server" below refers to the device hosting the web client in the test setup.

Prerequisites​

Below is a list of things to prepare before testing Jellyfin web clients.

Have an instance of Jellyfin Server. A dedicated testing setup is recommended.
Install the latest LTS version of NodeJS and npm on the test server.
Install Git on the test server.
(Optional) Install nvm: macOS, Linux, Windows.
(Optional) Install GitHub CLI or GitHub Desktop on the test server.
(Optional) A text editor or web IDE to make changes during testing, eg. VSCode, Notepad++, Jetbrains Webstorm.
NOTE

Installing Github CLI or Github Desktop will automatically install Git on the system.

Obtaining source code​

The source code of the web clients can be cloned from their respective GitHub repositories: Jellyfin Web, Jellyfin Vue. Instructions on how to do so can be found here.

Checking out branches​

The master branch is the default branch and where the unstable build is built from. After cloning, it will be checked out by default. If you wish to go back to testing the master branch after testing pull requests, please checkout the master branch. To checkout the master branch, simply do the following:

Git CLI, GitHub CLI: open a terminal in the web folder and run git checkout master.
GitHub Desktop: Select the master branch in the branch dropdown menu.
Checking out pull requests​

Pull requests are special branches submitted by contributors with the goal of eventually being merged into master. To checkout a pull request, please follow the instructions below.

Find the pull request you would like to checkout in the list of open pull requests: Jellyfin Web, Jellyfin Vue.
Checkout the pull request in Git: Git CLI and GitHub CLI, GitHub Desktop.
Pulling latest changes​

Branches won't be updated automatically by default. If it has been a while since you last pulled latest changes, the source code you have might be out of date. To pull in the latest changes, follow the instructions below:

Git CLI and GitHub CLI: Open a terminal window in the folder with the cloned contents of the clients and run the command git pull.
GitHub Desktop: Follow these instructions from GitHub.
Installing dependencies and starting a development server​

The web clients can be launched directly without being built. Please open a terminal window in the folder with the cloned contents of the clients, then follow the instructions of the respective projects.

For Jellyfin Web: Follow steps 2 and 3 of these instructions For Jellyfin Vue: Follow steps 2 - 4 of these instructions

To exit the development server, simply press Ctrl+C in the terminal window.

Edit this page
Previous
macOS
Next
About Jellyfin
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#testing-basics

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#the-testing-process

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#what-to-test

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#testing-for-general-bugs

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#reproducing-unconfirmed-issues

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#reporting-test-findings

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#reporting-general-bugs

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#successful-reproduction-of-unconfirmed-issue

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/testing/#unsuccessful-reproduction-of-unconfirmed-issue

Skip to main content
Testing
On this page
Testing Jellyfin

In addition to contributing code, testing is also very important for Jellyfin.

Testing Basics​

Please keep the following things in mind:

Make regular backups. Changes from testing might be irreversible.
Keep everything local. It is generally not a good idea to expose testing environments to the wider internet.
Expect things to break, especially with non-release versions.
The Testing Process​

Below is a quick overview of the testing process:

Get a copy of the software to be tested.
Setup the testing environment. (Install software and dependencies)
Perform test(s).
Document and report findings.
What To Test​

There are 2 types of items that need to be tested on Jellyfin:

Testing for general bugs. This means trying to find new, previously unknown bugs.
Reproduction of unconfirmed issues. This means trying to reproduce issues someone else has reported.
Testing for General Bugs​

To test for general bugs, use Jellyfin normally, or try to come up with edge cases that you think might break Jellyfin and / or edge cases that have broken other pieces of software before. If you have successfully broken Jellyfin, congratulations! You might have found a previously unknown bug.

Reproducing Unconfirmed Issues​

To test for unconfirmed issues, start by browsing the GitHub Issue Tracker. Any issue that hasn't been labeled confirmed means that it hasn't been confirmed yet. Testing issues that have been marked confirmed but hasn't been tested since the last major release would also be helpful. Find an issue that you have the necessary hardware / software to reproduce, and have fun!

Reporting Test Findings​

To report test findings, start by going to the GitHub Issue Tracker of the respective component. What you would do next depends entirely on what is being tested.

Reporting General Bugs​

Start by searching the issue tracker for similar issues. If you believe an issue is a duplicate to an open issue, comment your findings there. Otherwise, open a new issue report following the template of the specific repo. Please remember to follow ALL instructions on the template to avoid problems with other people. After you have submitted the report, the Jellyfin Triage Team will tell you what to do next.

Successful Reproduction of Unconfirmed Issue​

If you have successfully reproduced an unconfirmed issue, please comment your findings, along with reproduction steps you have taken and exact details of your setup. They should be as detailed as possible. Once the Jellyfin Triage Team reviews your report, the issue may be marked confirmed if no further info is required.

Unsuccessful Reproduction of Unconfirmed Issue​

If you have attempted to reproduce an unconfirmed issue but failed to do so, also comment on the original issue. The Jellyfin Triage Team might close the issue or ask for further feedback from another user.

Edit this page
Previous
Jellyfin Web Configuration
Next
Upgrades & Downgrades
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about/#__docusaurus_skipToContent_fallback

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about/#

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about/#why-did-you-fork

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about/#the-team

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/about/#core-team

Skip to main content
About Jellyfin
On this page
About Jellyfin

Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media. It is an alternative to the proprietary Emby and Plex, to provide media from a dedicated server to end-user devices via multiple apps. Jellyfin is descended from Emby's 3.5.2 release and ported to the .NET Core framework to enable full cross-platform support. There are no strings attached, no premium licenses or features, and no hidden agendas: just a team who want to build something better and work together to achieve it. We welcome anyone who is interested in joining us in our quest!

Jellyfin seeks to continue development of the original Emby project with a Free Software ethos. It is committed to bringing all its users access to the best possible Media System, developed entirely by a community of volunteers who contribute code, documentation, translations, and support to the project.

You can find our main repository on GitHub as well as our organization page.

Why did you fork?​

The Jellyfin project was started in early December 2018 primarily as a result of Emby's decision to take their next release (4.x) closed-source. Several members of the future Jellyfin team, including Joshua, Andrew, Vasily, and dkanada, were actively observing the Emby situation due to previously-reported GPL violations and a growing discontent with the Emby team for their practices and lack of respect for the FLOSS philosophy and ethos. These including the addition of a paywall for gratis users in an early 3.x release, the hiding/removal of client app and server code over several years, a lack of openness to community contributions, and various other reasons. Upon the announcement of the closed-source Emby 4 release, this group quickly gathered to fork as many repositories as (legally) possible and begin the process of renaming the project Jellyfin.

Since December 2018, the project has grown immensely, through several speedbumps and waves of activity, gaining contributors from around the world and of all skill levels and experiences, and we continue to advance the project as best as we can. We want to be the stewards of a truly FLOSS option in the video streaming space against Plex and Emby, and to remain a good proof of the power of Free and Open-Source software.

The Team​
Core Team​

The core team consists of those with merge permissions on the main Jellyfin repositories, and thus have the ultimate decision authority for contributions to the core Jellyfin server and web client. In addition, each member has various other roles and responsibilities as defined below.

Person	Contact	Role(s)
Joshua Boniface	GitHub Matrix Email	Project Leader, Packaging, Releases, Finance, Infrastructure
Anthony Lavado	GitHub	Social Media, Outreach, Finance
Andrew Rabert	GitHub	Finance
Bond-009	GitHub	Server
Claus Vium	GitHub	Server
Bill Thornton	GitHub	Web
Cody Robibero	GitHub	Server, Plugins
Niels van Velzen	GitHub	Clients
Edit this page
Previous
Testing Jellyfin Web Clients
Next
Community Standards
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#__docusaurus_skipToContent_fallback

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/chat

Skip to main content
Community StandardsChat Room Rules
On this page
Jellyfin Chat Room Rules

Version 2.0

Basics​

You shall abide by our Community Standards at all times.

You shall not do any of the following things:

Antagonize, flame, insult, demean, abuse, or harass other users or those outside of the community.
Dox or otherwise share others' private information, even if it is available publicly.
Post offensive, sexual, or otherwise inappropriate content - keep it "Safe For Work" in all channels.
Discuss media acquisition or related tools, regardless of its legality. Where your media comes from or how to get it is none of our or our community's business.
Spam the chat rooms in any way, including but not limited to Telegram short links and Self advertisement.
Post verbatim replies from "AI" Chat systems (e.g. ChatGPT) as answers.
Engage in the discussion of media acquisition or related tools, regardless of its legality. Please note that this is different from what is allowed on the forum.

Your username and profile fields shall be appropriate with respect to our above standards and shall not contain swearing, slurs, piracy, or attempts to impersonate others.

You shall ensure you are posting in the correct channel before making a post. Do NOT post the same question in multiple channels.

Please write in English if at all possible, as English is the working language of the Jellyfin project. If you cannot, please write in your native language (with or without attempted English) and ask for a translation if required.

If you are using Jellyfin for commercial purposes or within a business setting, please review our Commercial Support Policy.

Considering that the chat rooms are more likely to see users less experienced with tech, there are additional rules about technical misinformation. Please see the Technical Misinformation Rules below.

There are cases where the rules don't cover. Please act in good faith under all circumstances. Moderation will be done at the team's discretion when not covered by the rules.

Chat Rooms Specifics​

This chat lives primarily on Matrix, and is bridged to Discord and IRC. Because of this, you will see the following:

On Discord, you will see many people, including most of our team members, with "APP" next to their names. Most of these are humans, not bots. Our actual bots are called Jeff (Bot) and jeffbridges.
On Matrix, you will see many accounts with the IDs @jfdiscord_<some numbers>:im.jellyfin.org. These are bridged users from Discord.
On Discord and Matrix, you will see messages sent from jeffbridges. These are users from IRC.
On IRC, you will see messages sent from jeffbridges. These are users from other platforms.

In rare cases, your first message from Discord to the chat may be dropped by the Matrix bridge. Please send a general "Hello" message in #offtopic before posting your questions to ⁠#troubleshooting, or else we may miss it.

Do NOT directly message team members or fellow users or send them friend requests unless you have been asked to do so. Please ask all questions in the wider community channels instead. If you wish to contact the team privately, please refer to the Contact and Punishments section

Technical Misinformation Rules​

Since the chat rooms are much more likely to see users less experienced with tech, there are additional rules about technical misinformation specific to the chat rooms.

Definition of Technical Misinformation: Information about technology that can be objectively proven wrong.

You will generally NOT face punishment for simply saying something wrong occasionally. This rule is reserved for users who repeatedly demonstrate their unwillingness / inability to do basic research and / or take corrections from the community.

You may NOT spread information that may violate the ToS (Terms of Service) of other services (eg. Hosting Jellyfin behind Cloudflare). When the ToS is unclear, you should assume that it is against the ToS.

Discussion of topics related to technical misinformation should be limited to #offtopic only.

Contact and Punishments​

If you see something against the rules, or something that makes you feel unsafe, let our staff know. We want this server to be a welcoming space for all users of Jellyfin.

If you wish to contact moderators privately, please send an E-mail to us containing all the relevant info on your matter. Contact info can be found on the contact page.

Violation of these rules may result in the following punishments: an informal warning, a formal warning or a ban. If a formal warning has been issued, the next violation will result in a ban. See Community Standards: Dispute Resolution and Moderation for more info.

Edit this page
Previous
Community Standards
Next
Commercial Support Policy
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/commercial-support

Skip to main content
Community StandardsCommercial Support Policy
Commercial Support Policy

Jellyfin is an explicitly anti-commercial project; that is to say that we:

Are volunteer- and best-effort-only.
Will not commercialize the software ourselves.
Do not provide payment for development.
Do not support bug bounties or other such systems of paid support.
Collect donations purely to cover infrastructure and other incidental costs.

Because of this policy, many within the project have mixed feelings about supporting commercial instances of Jellyfin. For example, a streaming service built on it, or a large deployment for business use.

Thus, while Jellyfin is a GNU GPL-licensed project which does not prevent or preclude commercial uses, please be aware that some members of our community do not look kindly on this and, as is their choice under our volunteer-only policy, may not be willing to provide support for commercial implementations. Not everyone feels this way, and such discussions are allowed here (subject to all other rules), but we want to ensure this is explicitly stated to avoid any misunderstandings or misaligned expectations.

In short, if you are expecting support for the commercialization of Jellyfin, please do so respectfully and with the mutual understanding that this is not something everyone might wish to endorse, and no member of the team nor forum community is under any obligation to assist if they do not want to.

Note that this policy is strictly in regards to legitimate business uses of Jellyfin. Running pirate media instances is covered by our Server Policy.

Edit this page
Previous
Chat Room Rules
Next
Server Policy
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#mission-statement

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#code-of-conduct

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#dispute-resolution-and-moderation

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#questions-or-comments

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/community-standards/#changelog

Skip to main content
Community Standards
On this page
Jellyfin Community Standards

This document outlines the standards by which all participants in the Jellyfin community, be it user or contributor, on all possible platforms, must adhere.

Mission Statement​

Jellyfin aims to be the best free and open-source media streaming platform possible, without any proprietary/locked features or unreasonable centralization.

Jellyfin is a project made up entirely and exclusively of Volunteers who donate their free time to the project.

Jellyfin is not and will never be under the control of any corporation or profit-driven entity, and does not exist to make money for anyone, including any volunteer contributors or the project leadership.

Fostering a community of respectful and productive contributors is central to our success and longevity.

Code of Conduct​

At all times when interacting with the Jellyfin community via any method (Matrix, Forums, etc.), you must abide by the following:

Respect others and remember the Human. Do exhibit kindness and empathy to others and make them feel welcome. Do not antagonize, flame, insult, demean, abuse, or harass others. Do not use slurs or sexualized language. Do not dox or otherwise expose others' private information, even if it is shared publicly elsewhere. Always act in good faith and give other contributors the benefit of the doubt. Try to read positivity rather than negativity into communications where at all possible.

Do not engage in, encourage, facilitate or discuss piracy in any Jellyfin communities. Jellyfin is a media server system for your own media collection; how you obtain media is not our concern and is not to be discussed in our communities in any form. Do not ask about where or how to obtain media, do not ask about, sell, trade, or otherwise facilitate access to other users' servers or discuss any piracy related topics. This includes discussing technologies commonly used for piracy and personal philosophies about it, in our communities. Please also refrain from discussing any topic that is closely related to piracy or accompanying topics and technology.

Do not suggest, encourage, or discuss configurations that may violate the Terms of Service (TOS) of any other platforms. Jellyfin can interface with multiple external services, both internally (e.g. Metadata providers) and by user configuration, each of which has its own requirements and TOS to protect itself. We do not want Jellyfin or its community to develop a reputation for facilitating circumvention or breaking of other services' TOSes or be seen as a problematic member of the wider community. The exact nature of these violations is subject to interpretation on a case-by-case basis based on the service in question and the discussion, and this rule is designed to bring attention to the issue. As a concrete example, the Cloudflare Terms Of Service forbid video streaming behind a normal Cloudflare tunnel; thus, suggesting a user run their instance in this way is a violation of this rule.

English is the primary working language of Jellyfin, but large portions of the community are not native English speakers. Be patient when language issues arise, and do not mistake incomplete language knowledge for ignorance or worse. If you are having trouble communicating an idea in English, please post in your native language and ask for help translating, and someone is likely to understand.

Jellyfin is created exclusively by volunteers, as set out in our Mission Statement. Since they are freely giving their time and effort, no volunteer contributor owes anything whatsoever to any other contributor, any user, or the project itself. Contributors are free to come and go as they please, to work on and give attention to what they deem interesting or important, and to respond or not respond to anything they wish. Do not badger volunteers in any way about any topic.

If you have questions to ask of the community, please choose the appropriate location (see our Getting Help page) and ask your question in full, immediately, with as much detail as possible. Author issues aside, Asking Questions the Smart Way is a valuable resource and is recommended reading before engaging with any free and open source community, including ours. Do not pester or harass community members for help or to answer questions. Do not require others to pry information out of you. Do not spam questions; they will be answered when they are answered.

Dispute Resolution and Moderation​

Disputes are inevitable, including violations of the rules above. When these occur, the following policy applies.

Before any other resolution step, we trust the community to police itself. If you see a community member violating these community standards, please let them know, and link them to this document. Do not respond in kind (e.g. respond to a flame with a flame). Most disagreements can be solved with education and discussion. If you have been linked to this document by another user, do not dwell on this point: alter your behavior as appropriate and move on.

If the issue cannot be resolved between the contributors, any complaints, instances of explicit rule breaking, or unresolvable disagreements with other community members may be directed towards the Core Team or the Project Leader directly. You may do so through email (team [at] jellyfin.org) or on Matrix via a direct message. Please include details and context as appropriate. See the about page for the list of Core Team members and ways to contact them.

The team will review the complaint and decide on an action, including but not limited to: informal private guidance, informal private warnings, formal public warnings, temporary ban(s) from the various platforms, or permanent ban(s).

Formal warnings will be made under a "second-chance-only" policy. Once warned, if one repeats the same behavior, the response will escalate as appropriate to the infraction.

Moderation tasks in some locations are delegated to other, non-Core team members. This dispute resolution procedure applies anywhere under the Jellyfin umbrella. The Core team and Project Leader retain final say in any dispute resolutions.

Questions or Comments​

Questions or comments regarding these standards should be forwarded to the Project Leader or Core Team.

Changelog​

This document represents official Jellyfin project policy. Any changes to this document require a changelog entry here and approval by a Project Leader.

2020-09-14, Joshua Boniface: Initial version of the community standards document. Based very loosely on several CoCs including the Contributor Covenant, and various Forum rules I've read and written over the years.
2022-09-03, Joshua Boniface: Update header and footer sections; reduce redundant wording; make rules clearer.
2024-08-12, JPVenson: Added section about respecting the TOS of other services
Edit this page
Previous
About Jellyfin
Next
Chat Room Rules
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#__docusaurus_skipToContent_fallback

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/development

Skip to main content
ContributingDevelopment
On this page
How to contribute code to Jellyfin

This page details how our repositories are organized, how to get started editing the code and creating your first pull request, and some general procedures around pull requests in Jellyfin.

What should you work on?​

There are many projects within the organization to browse through for contributions. Summarized here are the two biggest ones, one for backend devs and another for frontend devs.

Jellyfin Server: The server portion, built using .NET 8 and C#.
Jellyfin Web: The main client application built for browsers, but also used in some of our other clients that are just wrappers.

Note that each of the repositories also has its own documentation on how to get started with that project, generally found in the repository README. You can also view the organization source tree to see how some of the bigger projects are structured.

The best way to get going on some actual development is to look through the issues list of the associated repository, find an issue you would like to work on, and start hacking! Issues are triaged regularly by the administrative team, and labels assigned that should help you find issues within your skill-set. Once you start working on an issue, please comment on it stating your intent to work on the issue, to avoid unnecessary duplication of work.

Major Issue Types​

A list of issue types can be found on the issue guidelines section.

What if there isn't an issue?​

If there isn't already an issue dealing with the changes you want to make, please create an issue to track it first, then ensure your PR(s) reference the issue in question. This is especially useful for bugs that are found and then fixed by the author, so both the original issue and the fix can be documented and tracked in detail.

How should you make changes?​

Once you've found something you want to work on or improve, the next step is to make your changes in the code, test them, then submit a Pull Request (PR) on GitHub.

For simplicity, all examples assume the developer is operating on Linux with SSH access to GitHub, however the general ideas can be applied to HTTP-based GitHub interfaces, and can be translated to Windows or MacOS.

If you aren't familiar with Git, we recommend the official documentation to understand how this version control system works and how to use it.

Set up your copy of the repo​

The first step is to set up a copy of the Git repository of the project you want to contribute to. Jellyfin follows a "fork, feature-branch, and PR" model for contributions.

On GitHub, "Fork" the Jellyfin repository you wish to contribute to, to your own user account using the "Fork" button in the relevant repository.

Clone your fork to your local machine and enter the directory:

git clone git@github.com:yourusername/projectname.git
cd projectname/


Add the "upstream" remote, which allows you to pull down changes from the main project easily:

git remote add upstream git@github.com:jellyfin/projectname.git


To get the Jellyfin.Server project to run successfully, checkout both the server, as well as the web client project.

Build the Jellyfin Web project with NPM, and copy the location of the resulting dist folder.

In your Jellyfin.Server project add an environment variable named JELLYFIN_WEB_DIR with the value set to the full path of your dist folder.

You will now be ready to begin building or modifying the project.

Make changes to the repo​

Once you have your repository, you can get to work.

Rebase your local branches against upstream master so you are working off the latest changes:

git fetch --all
git rebase upstream/master


Create a local feature branch off of master to make your changes:

git checkout -b my-feature master


Make your changes and commits to this local feature branch.

Repeat step 1 on your local feature branch once you're done your work, to ensure you have no conflicts with other work done since you stated.

Push up your local feature branch to your GitHub fork:

git push --set-upstream origin my-feature


On GitHub, create a new PR against the upstream master branch following the advice below.

Once your PR is merged, ensure you keep your local branches up-to-date:

git fetch --all
git checkout master
git rebase upstream/master
git push -u origin master


Delete your local feature branch if you no longer need it:

git branch -d my-feature

CONTRIBUTORS.md​

If it's your first time contributing code to a particular repository, please add yourself to the CONTRIBUTORS.md file at the bottom of the Jellyfin Contributors section. While GitHub does track this, having the written document makes things clearer if the code leaves GitHub and lets everyone quickly see who has worked on the project for copyright or praise!

Official Branches​
Feature Branches​

From time to time, major projects may come up that require multiple PRs and contributions from multiple people. For these tasks, feature branches specific to the feature should be created, based off of master. This helps allow the work to progress without breaking master for long periods and allowing those interested in that particular project the ability to work at their own pace instead of racing to fix a broken feature before the next release. To create a feature branch, please communicate with a Core team member and that can be arranged.

Once the feature a feature branch was created for is ready, it can be merged in one shot into master and the feature branch removed. Alternatively, for very-long-lived features, certain "stable" snapshots can be merged into master as required.

The Master Branch​

The master branch is the primary face of the project and main development branch. Except for emergency release hotfixes, all PRs should target master. As a general rule, no PR should break master and all PRs should be tested before merging to ensure this does not occur. We're only human and this is still likely to happen, but you should generally be safe to build off of master if you want the latest and greatest version of Jellyfin.

Testing a Pull Request​

To test someone else's pull request, you must import the changes to your local repository.

Fetch the changes in a pull request and link them to a new local branch:

git fetch upstream pull/<PR_ID>/head:my-testing-branch

NOTE

<PR_ID> is pull request number on GitHub.

Checkout the new local branch:

git checkout my-testing-branch


Perform any testing or build required to test, then return to master and delete the branch:

git checkout master
git branch -D my-testing-branch

Pull Request Guidelines​

When submitting a new PR, please ensure you do the following things. If you haven't, please read How to Write a Git Commit Message as it is a great resource for writing useful commit messages.

Before submitting a PR, squash "junk" commits together to keep the overall history clean. A single commit should cover a single significant change: avoid squashing all your changes together, especially for large PRs that touch many files, but also don't leave "fixed this", "whoops typo" commits in your branch history as this is needless clutter in the final history of the project.

Write a good title that quickly describes what has been changed. For example, "Add LDAP support to Jellyfin". As mentioned in How to Write a Git Commit Message, always use the imperative mood, and keep the title short but descriptive. The title will eventually be a changelog entry, so please try to use proper capitalization but no punctuation; note that the Core team may alter titles to better conform to this standard before merging.

For anything but the most trivial changes that can be described fully in the (short) title, follow the PR template and write a PR body to describe, in as much detail as possible:

Why the changes are being made. Reference specific issues with keywords (fixes, closes, addresses, etc.) if at all possible.

How you approached the issue (if applicable) and briefly describe the changes, especially for large PRs.

If your pull request is not finished yet, please mark it as a "draft" when you open it. While this tag is in place, the pull request will not be merged, and reviews should remain as comments only. Once you are happy with the final state of your PR, please remove this tag; forgetting to do so might result in your PR being unintentionally ignored as still under active development! Inactive WIPs may occasionally elicit pings from the team inquiring on the status and closed if there is no response.

Avoid rebasing and force-pushing to large or complex pull requests if at all possible, and especially after reviews. It forces unnecessary reviews to verify the changes are still okay and build properly.

Expect review and discussion. If you cannot back up your changes with a good description and through review, please reconsider whether it should be done at all. All PRs to dev require at least one approving review from an administrative team member, however we welcome and encourage reviews from any contributor, especially if it is in an area you are knowledgeable about. More eyes are always better.

All PRs require review by at least two team members before being merged into master, though reviews from any contributor are welcome! After the second team member review the PR may be merged immediately, or more review or feedback requested explicitly from other contributors if required.

Building and Testing Inside a Docker Container​

We need to install all development dependencies and pull down the code inside the container before we can compile and run.

NOTE

Run each command on a separate line. The container we'll test in is named jftest. Within Docker, anytime the entrypoint executable is terminated, the session restarts, so just exec into it again to continue. This is also why we explicitly kill it to reload the new version.

Master Branch​
docker exec -ti jftest bash
apt-get update && apt-get install -y git gnupg curl autoconf g++ make libpng-dev gifsicle automake libtool gcc musl-dev nasm ca-certificates
curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
curl -LO https://packages.microsoft.com/config/debian/12/prod.list && mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
apt-get update && apt-get install -y dotnet-sdk-8.0
curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg
echo "deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main" | tee /etc/apt/sources.list.d/nodesource.list
apt-get update && apt-get install -y nodejs
cd /opt && git clone https://github.com/jellyfin/jellyfin.git && git clone https://github.com/jellyfin/jellyfin-web.git
cd jellyfin/ && DOTNET_CLI_TELEMETRY_OPTOUT=1 && DOTNET_CLI_HOME="/tmp/" dotnet publish Jellyfin.Server --configuration Debug --output="/jellyfin" --self-contained --runtime linux-x64
cd /opt/jellyfin-web && npm install && npm run build:development && cp -r /opt/jellyfin-web/dist /jellyfin/jellyfin-web
apt-get remove -y gnupg curl && apt-get clean -y autoclean && apt-get autoremove -y
kill -15 $(pidof jellyfin)

Pull Request​

First, complete the steps above to setup your container to build the master branch.

NOTE

<PR_ID> is pull request number on GitHub.

docker exec -ti jftest bash
cd /opt/jellyfin
git fetch origin pull/<PR_ID>/head:my-testing-branch
git merge my-testing-branch
dotnet build
kill -15 $(pidof jellyfin)

Edit this page
Previous
Branding
Next
Reporting Issues
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/issues

Skip to main content
ContributingReporting Issues
On this page
Reporting Issues

This page discusses how to open issues, including the policies and procedures of the Jellyfin project around handling issues.

Issues should only detail software bug reports.

All other discussions, including initial troubleshooting, should be directed towards our help channels.

Requesting Features​

Please note that feature and enhancement requests should be directed towards our Fider instance for tracking, voting, and reporting. Please keep all feature requests to this page and not GitHub issues.

Searching and Voting​

Before opening an issue, please search the existing issues to see if a similar problem or feature request has been reported. Duplicate issues clutter the repository and should be avoided.

If you do find an issue that matches, or closely matches, your issue, please make use of the 👍 reaction to confirm the issue also affects you or that you support the feature request. If you wish, add a comment as well describing your version of the issue or feature use case.

If the existing issue is closed, please read through it to see if the accepted workaround(s) apply to your case. If not, leave a comment and the issue will be reopened. Note that, since PRs go into dev first but releases are built from master, an issue's fix won't be immediately available in the official sources, but will be included in the next release.

Opening an Issue​

Once you're ready to open an issue, please see this page!

Reporting Bugs​

When writing a bug issue, please ensure you capture as much relevant detail as possible - this is very important to assist in troubleshooting and triaging/investigating the issue. Some useful elements include:

How you installed Jellyfin (upgrade or fresh install)

What platform and operating system you are using (Debian, Arch, Docker, etc.)

What you were doing that caused the issue to appear

Any relevant log output

Any non-standard configurations you use

Bugs should be tagged with [bug] at the beginning of their title. This will later be removed by the Jellyfin team when assigning labels. To assist in triaging, if you know which other label(s) should be applied to your issue, please add them after the [bug] label.

Bugs should be reproduceable. That is, you should be able to have determined through troubleshooting how to replicate the issue. While one-time bugs should not be ignored, if they're difficult or impossible to reproduce, it's likely very hard to fix them. Please attempt to reproduce the bug before filing the issue and include the smallest test case you can to demonstrate it.

If you ever need assistance for troubleshooting or opening an issue, please contact the community and we'll try to help you out!

Issue Labels​

Jellyfin features a number of issue labels to assist in triaging and managing issues. Users cannot assign these themselves due to GitHub's permissions, but they will be added by a team member during triaging.

Categories​

These labels are broad categories for which part of the codebase is affected.

backend: An issue that mainly relates to the server backend code.
build: An issue that mainly relates to the build process.
Criticality​

These labels help determine how critical an issue is.

regression: An issue in need of immediate attention due to a regression from the last build.
bug: A bug in the code that affects normal usage.
Management​

These labels help assist in managing the project and direction.

good first issue: Something that should be very straightforward to do and is a great place to get started.
help wanted: An issue that currently has no clear expert within the project and could use outside assistance.
roadmap: A meta-issue related to the future roadmap of the project.
investigation: An investigation-type issue into the codebase.
Pull Requests​

These labels apply only to pull requests for administrative purposes.

requires testing: A PR that has not been tested in a live environment yet. Any major backend-affecting PRs should be tested before being merged to avoid regressions.
Edit this page
Previous
Development
Next
Releases
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/release-procedure

Skip to main content
ContributingReleases
On this page
Release Procedure

This document is a guide for the core team, provided publicly to ensure transparency in the release process.

Versioning​

Jellyfin uses semantic versioning. All releases will have versions in the X.Y.Z format, starting from 10.0.0. Note however that the 10.Y.Z release chain represents the "cleanup" of the codebase, so it should be accepted that 10.Y.Z breaks all compatibility, at some point, with previous Emby-compatible interfaces, and may also break compatibility with previous 10.Y releases if required for later cleanup work. Our versioning will typically follow the patterns below:

X: Major Versions​
Breaks compatibility with the HTTP or plugin APIs
Y: Minor Versions​
Introduces new features
Makes minor backwards-compatible API changes
Z: Hotfix Versions​
Critical bug fixes or minor changes
General Release Philosophy​

Releases will generally be performed on Sundays "when ready". For Major/Minor releases, the "when ready" is generally quite flexible and is whenever the release is truly ready without major breaking bugs. After a major release, each Sunday the Admin team should review the recently merged PRs and, if backports are required, perform a Hotfix release containing those PRs.

Major Release Procedure​
Preparation​

Testing is ongoing via master nightly builds, so master should be generally unbroken before proceeding. The version of master should already reflect the upcoming major release version (i.e. X.Y.0).

Once master is in a generally stable state after extensive work, announce a "golden nightly" is incoming via the jellyfin-dev Matrix/Riot channel and Forum.

Collect testing information and repeat as needed.

Once the release is considered stable and working, announce full PR freeze via the jellyfin-dev Matrix/Riot channel.

Allow one further "golden nightly" and at least 48 hours of testing time. Restart this process if major breaking bugs are found.

Once all testing is complete and the release remains stable, proceed.

Release Web Client​

Create a release branch on the jellyfin-web repository via CLI from master, named release-X.Y.z, where X and Y are the new version number, and z is a literal z. Push the new branch to GitHub.

Create a GitHub release for the new version, based on the newly-created release-X.Y.z branch. The tag should be named vX.Y.Z (i.e. vX.Y.0) and the release named "Release X.Y.Z". The release body should contain the following link only, replacing the version as required:

[Please see the release announcement on the main repository.](https://github.com/jellyfin/jellyfin/releases/tag/vX.Y.Z)


Publish the release.

Release Server​

Create a release branch on the jellyfin repository via CLI from master, named release-X.Y.z, where X and Y are the new version number, and z is a literal z. Push the new branch to GitHub.

Create a GitHub release for the new version, based on the newly-created release-X.Y.z branch. The tag should be named vX.Y.Z (i.e. vX.Y.0) and the release named "Release X.Y.Z". The release body should contain the following components:

a. A quick top blurb under a # Jellyfin X.Y.Z header.

a. A list of features, including in-line links to Fider if available, under a ## New Features and Major Improvements header.

a. A list of known release notes, categorized by the relevant platform (e.g. [All] or [Windows]), under a ## Important Release Notes header.

a. If applicable, a set of release notes/comments about FFmpeg, under a ## FFmpeg header.

a. A full changelog, split by repository with ### [repo](https://github.com/jellyfin/repo) subheaders, under a ## Changelog header. Each element should be a PR number and the PR title.

Publish the release.

Wait for builds to complete.

Announce the new release in the jellyfin-announce Matrix/Riot channel and Forum.

Hotfix Release Procedure​

During normal work on the master branch, select PRs suitable for backporting by tagging them with the stable-backport label during the PR lifecycle. All PRs will target master and thus bugfixes for the stable release must include this label to be included.

Collect the list of merged stable-backport PRs from all relevant repositories.

For each repository, perform stable branch reconciliation for the relevant PRs:

For each PR slated for backport:

Grab the merge commit hash for the PR from master branch.

Cherry-pick the merge commit into the release-x.y.z branch via: git cherry-pick -sx -m1 <merge-commit-hash>.

Fix any merge conflicts, generally keeping what's in the merge. If there are significant merge conflicts, this likely indicates that the fix is too large for backporting.

Finalize the cherry-pick via: git add and git commit -v.

For the main jellyfin repository, bump the version of the repository to the new hotfix version with the bump_version script and commit the result with the message "Bump version for X.Y.Z".

Push the updated release branch to GitHub.

Web Client​

Create a GitHub release for the new version, based on the relevant release-X.Y.z branch. The tag should be named vX.Y.Z and the release named "Release X.Y.Z". The release body should contain the following link only, replacing the version as required:

[Please see the release announcement on the main repository.](https://github.com/jellyfin/jellyfin/releases/tag/vX.Y.Z)


Publish the release on GitHub and the archive repository.

Server​

Create a GitHub release for the new version, based on the relevant release-X.Y.z branch. The tag should be named vX.Y.Z and the release named "Release X.Y.Z". The release body should contain the following components:

a. A quick top blurb under a # Jellyfin X.Y.Z header.

a. A list of known release notes, categorized by the relevant platform (e.g. [All] or [Windows]), under a ## Important Release Notes header.

a. If applicable, a set of release notes/comments about FFmpeg, under a ## FFmpeg header.

a. A full changelog, split by repository with ### [repo](https://github.com/jellyfin/repo) subheaders, under a ## Changelog header. Each element should be a PR number and the PR title.

Publish the release.

Wait for builds to complete.

Announce the new release in the jellyfin-announce channel and anywhere else as required.

Edit this page
Previous
Reporting Issues
Next
Source Tree
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/source-tree

Skip to main content
ContributingSource Tree
On this page
Source Tree

Jellyfin is a maze of clients, plugins, and other useful projects. These source trees can serve as an excellent tool to inform new developers about the structure of several projects.

Jellyfin Server​
.ci: Azure Pipelines Build definitions
DvdLib: DVD Anaylzer
Emby.Dlna: DLNA support for the server
Profiles: DLNA Profiles for clients
Emby.Drawing: image processor managing the image encoder and image cache paths
Emby.Naming: parsers for the media filenames
Emby.Notifications: listening for events and sending the associated notification
Emby.Photos: metadata provider for photos
Emby.Server.Implementations: main implementations of the interfaces
ScheduledTasks: all scheduled tasks can be found here
Jellyfin.Api: Jellyfin API
Controller: API controllers answering the Jellyfin API requests
Helpers:
MediaInfoHelper.cs: logic for the stream builder that determines method of playback such as Direct Play or Transcoding
Jellyfin.Data: models used in the Entity Framework Core Database schema
Jellyfin.Drawing.Skia: image manipulation like resizing images, making image collages
Jellyfin.Networking: managing network interaces and settings
Jellyfin.Server.Implementations: like Emby.Server.Implementations, implementations using the EF Core Database
Jellyfin.Server: main server project that starts the whole server
MediaBrowser.Common: common methods used throughout the server
MediaBrowser.Controller: interface definitions
MediaBrowser.LocalMetadata: metadata provider and saver for local images, local Collections and Playlists
MediaBrowser.MediaEncoding: managing ffmpeg while interacting with the media files
MediaBrowser.Model: defining models used throughout the server
MediaBrowser.Providers: managing multiple metadata sources
MediaBrowser.XbmcMetadata: metadata provider and saver for local .nfo files
RSSDP: RSSDP library, including custom changes, for the Simple Service Discovery (SSDP) protocol
apiclient: files used for generating the axios API client
deployment: files used while building Jellyfin for different plattforms
tests: multiple Unit Test projects testing Jellyfin functionality
Dockerfile.* Dockerfiles defining the Jellyfin Docker image
Web Client​
src:
assets: images, styles, splash screens, and any other static assets
css: all global stylesheets used throughout the client
img: images for things like device icons and logos
splash: progressive web apps will show these splash screens
components: custom elements used for different sections of the user interface
playerstats.js: display playback info in browsers and other clients that include the web source
controllers: scripts that handle the logic for different pages
elements: custom UI components that are used globally such as buttons or menus
legacy: currently used for all polyfills and scripts related to backwards compatibility
libraries: dependencies that we eventually want to remove and include during the build step
scripts: any script that isn't tied to a UI element or page but rather general functionality
strings: translations for the entire interface
themes: custom and bundled themes can be found here in their own directories
Kodi​
jellyfin_kodi
database: manipulating the local Jellyfin sqlite database
dialogs: code behind popup menus for user interaction
entrypoint: main add-on settings page
helper: small helper functions, mostly formatting or reused functions
jellyfin: interacting with the server
objects:
kodi: handling local Kodi media types and database
resources:
language: string files for localization
skins: design of popup menus for user interaction
Edit this page
Previous
Releases
Next
Style Guides
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#reporting-issues

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#developing-code

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/development#set-up-your-copy-of-the-repo

Skip to main content
ContributingDevelopment
On this page
How to contribute code to Jellyfin

This page details how our repositories are organized, how to get started editing the code and creating your first pull request, and some general procedures around pull requests in Jellyfin.

What should you work on?​

There are many projects within the organization to browse through for contributions. Summarized here are the two biggest ones, one for backend devs and another for frontend devs.

Jellyfin Server: The server portion, built using .NET 8 and C#.
Jellyfin Web: The main client application built for browsers, but also used in some of our other clients that are just wrappers.

Note that each of the repositories also has its own documentation on how to get started with that project, generally found in the repository README. You can also view the organization source tree to see how some of the bigger projects are structured.

The best way to get going on some actual development is to look through the issues list of the associated repository, find an issue you would like to work on, and start hacking! Issues are triaged regularly by the administrative team, and labels assigned that should help you find issues within your skill-set. Once you start working on an issue, please comment on it stating your intent to work on the issue, to avoid unnecessary duplication of work.

Major Issue Types​

A list of issue types can be found on the issue guidelines section.

What if there isn't an issue?​

If there isn't already an issue dealing with the changes you want to make, please create an issue to track it first, then ensure your PR(s) reference the issue in question. This is especially useful for bugs that are found and then fixed by the author, so both the original issue and the fix can be documented and tracked in detail.

How should you make changes?​

Once you've found something you want to work on or improve, the next step is to make your changes in the code, test them, then submit a Pull Request (PR) on GitHub.

For simplicity, all examples assume the developer is operating on Linux with SSH access to GitHub, however the general ideas can be applied to HTTP-based GitHub interfaces, and can be translated to Windows or MacOS.

If you aren't familiar with Git, we recommend the official documentation to understand how this version control system works and how to use it.

Set up your copy of the repo​

The first step is to set up a copy of the Git repository of the project you want to contribute to. Jellyfin follows a "fork, feature-branch, and PR" model for contributions.

On GitHub, "Fork" the Jellyfin repository you wish to contribute to, to your own user account using the "Fork" button in the relevant repository.

Clone your fork to your local machine and enter the directory:

git clone git@github.com:yourusername/projectname.git
cd projectname/


Add the "upstream" remote, which allows you to pull down changes from the main project easily:

git remote add upstream git@github.com:jellyfin/projectname.git


To get the Jellyfin.Server project to run successfully, checkout both the server, as well as the web client project.

Build the Jellyfin Web project with NPM, and copy the location of the resulting dist folder.

In your Jellyfin.Server project add an environment variable named JELLYFIN_WEB_DIR with the value set to the full path of your dist folder.

You will now be ready to begin building or modifying the project.

Make changes to the repo​

Once you have your repository, you can get to work.

Rebase your local branches against upstream master so you are working off the latest changes:

git fetch --all
git rebase upstream/master


Create a local feature branch off of master to make your changes:

git checkout -b my-feature master


Make your changes and commits to this local feature branch.

Repeat step 1 on your local feature branch once you're done your work, to ensure you have no conflicts with other work done since you stated.

Push up your local feature branch to your GitHub fork:

git push --set-upstream origin my-feature


On GitHub, create a new PR against the upstream master branch following the advice below.

Once your PR is merged, ensure you keep your local branches up-to-date:

git fetch --all
git checkout master
git rebase upstream/master
git push -u origin master


Delete your local feature branch if you no longer need it:

git branch -d my-feature

CONTRIBUTORS.md​

If it's your first time contributing code to a particular repository, please add yourself to the CONTRIBUTORS.md file at the bottom of the Jellyfin Contributors section. While GitHub does track this, having the written document makes things clearer if the code leaves GitHub and lets everyone quickly see who has worked on the project for copyright or praise!

Official Branches​
Feature Branches​

From time to time, major projects may come up that require multiple PRs and contributions from multiple people. For these tasks, feature branches specific to the feature should be created, based off of master. This helps allow the work to progress without breaking master for long periods and allowing those interested in that particular project the ability to work at their own pace instead of racing to fix a broken feature before the next release. To create a feature branch, please communicate with a Core team member and that can be arranged.

Once the feature a feature branch was created for is ready, it can be merged in one shot into master and the feature branch removed. Alternatively, for very-long-lived features, certain "stable" snapshots can be merged into master as required.

The Master Branch​

The master branch is the primary face of the project and main development branch. Except for emergency release hotfixes, all PRs should target master. As a general rule, no PR should break master and all PRs should be tested before merging to ensure this does not occur. We're only human and this is still likely to happen, but you should generally be safe to build off of master if you want the latest and greatest version of Jellyfin.

Testing a Pull Request​

To test someone else's pull request, you must import the changes to your local repository.

Fetch the changes in a pull request and link them to a new local branch:

git fetch upstream pull/<PR_ID>/head:my-testing-branch

NOTE

<PR_ID> is pull request number on GitHub.

Checkout the new local branch:

git checkout my-testing-branch


Perform any testing or build required to test, then return to master and delete the branch:

git checkout master
git branch -D my-testing-branch

Pull Request Guidelines​

When submitting a new PR, please ensure you do the following things. If you haven't, please read How to Write a Git Commit Message as it is a great resource for writing useful commit messages.

Before submitting a PR, squash "junk" commits together to keep the overall history clean. A single commit should cover a single significant change: avoid squashing all your changes together, especially for large PRs that touch many files, but also don't leave "fixed this", "whoops typo" commits in your branch history as this is needless clutter in the final history of the project.

Write a good title that quickly describes what has been changed. For example, "Add LDAP support to Jellyfin". As mentioned in How to Write a Git Commit Message, always use the imperative mood, and keep the title short but descriptive. The title will eventually be a changelog entry, so please try to use proper capitalization but no punctuation; note that the Core team may alter titles to better conform to this standard before merging.

For anything but the most trivial changes that can be described fully in the (short) title, follow the PR template and write a PR body to describe, in as much detail as possible:

Why the changes are being made. Reference specific issues with keywords (fixes, closes, addresses, etc.) if at all possible.

How you approached the issue (if applicable) and briefly describe the changes, especially for large PRs.

If your pull request is not finished yet, please mark it as a "draft" when you open it. While this tag is in place, the pull request will not be merged, and reviews should remain as comments only. Once you are happy with the final state of your PR, please remove this tag; forgetting to do so might result in your PR being unintentionally ignored as still under active development! Inactive WIPs may occasionally elicit pings from the team inquiring on the status and closed if there is no response.

Avoid rebasing and force-pushing to large or complex pull requests if at all possible, and especially after reviews. It forces unnecessary reviews to verify the changes are still okay and build properly.

Expect review and discussion. If you cannot back up your changes with a good description and through review, please reconsider whether it should be done at all. All PRs to dev require at least one approving review from an administrative team member, however we welcome and encourage reviews from any contributor, especially if it is in an area you are knowledgeable about. More eyes are always better.

All PRs require review by at least two team members before being merged into master, though reviews from any contributor are welcome! After the second team member review the PR may be merged immediately, or more review or feedback requested explicitly from other contributors if required.

Building and Testing Inside a Docker Container​

We need to install all development dependencies and pull down the code inside the container before we can compile and run.

NOTE

Run each command on a separate line. The container we'll test in is named jftest. Within Docker, anytime the entrypoint executable is terminated, the session restarts, so just exec into it again to continue. This is also why we explicitly kill it to reload the new version.

Master Branch​
docker exec -ti jftest bash
apt-get update && apt-get install -y git gnupg curl autoconf g++ make libpng-dev gifsicle automake libtool gcc musl-dev nasm ca-certificates
curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
curl -LO https://packages.microsoft.com/config/debian/12/prod.list && mv prod.list /etc/apt/sources.list.d/microsoft-prod.list
apt-get update && apt-get install -y dotnet-sdk-8.0
curl -fsSL https://deb.nodesource.com/gpgkey/nodesource-repo.gpg.key | gpg --dearmor -o /etc/apt/keyrings/nodesource.gpg
echo "deb [signed-by=/etc/apt/keyrings/nodesource.gpg] https://deb.nodesource.com/node_20.x nodistro main" | tee /etc/apt/sources.list.d/nodesource.list
apt-get update && apt-get install -y nodejs
cd /opt && git clone https://github.com/jellyfin/jellyfin.git && git clone https://github.com/jellyfin/jellyfin-web.git
cd jellyfin/ && DOTNET_CLI_TELEMETRY_OPTOUT=1 && DOTNET_CLI_HOME="/tmp/" dotnet publish Jellyfin.Server --configuration Debug --output="/jellyfin" --self-contained --runtime linux-x64
cd /opt/jellyfin-web && npm install && npm run build:development && cp -r /opt/jellyfin-web/dist /jellyfin/jellyfin-web
apt-get remove -y gnupg curl && apt-get clean -y autoclean && apt-get autoremove -y
kill -15 $(pidof jellyfin)

Pull Request​

First, complete the steps above to setup your container to build the master branch.

NOTE

<PR_ID> is pull request number on GitHub.

docker exec -ti jftest bash
cd /opt/jellyfin
git fetch origin pull/<PR_ID>/head:my-testing-branch
git merge my-testing-branch
dotnet build
kill -15 $(pidof jellyfin)

Edit this page
Previous
Branding
Next
Reporting Issues
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#adding-to-documentation

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#translating

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/contributing/#testing

Skip to main content
Contributing
On this page
Contributing to Jellyfin

Thank you for your interest in contributing to the Jellyfin project! This page and its children describe the ways you can contribute, as well as some of our policies. This should help guide you through your first Issue or PR.

Even if you cannot contribute code, you can still help Jellyfin! The two main things you can help with are testing and creating issues. Contributing to code, documentation, translations, and other non-code components are all outlined in the sections below.

Reporting Issues​

We use GitHub extensively to track open issues, new enhancements or features, and other aspects of development.

Please see the getting help page for help with troubleshooting and finding bugs, and the documentation on issues for more information on how to submit good issues.

Developing Code​

The entire project consists of a C# core server, a JavaScript web client, and a number of other clients written in various languages and frameworks. If you have experience with these languages, we're always grateful for any contributions you might want to make!

For general guidelines on how the project works, including how to set up your development copy, make changes, and guidelines on Pull Requests (PRs), please see the documentation on contributing code. Jellyfin follows a "fork and PR" methodology; if you're not familiar with this, please see the relevant section.

Adding To Documentation​

Documentation is incredibly helpful! All these docs are written using Docusaurus. You can find the raw markdown in the documentation repository. Pull requests are welcome!

Translating​

If you're interested in helping to translate Jellyfin into your local language, we use Weblate running at translate.jellyfin.org to handle translations. These are collected in the translations branches of the various repositories and are merged into the master branches before each release.

Testing​

Testing is the easiest way to contribute. Simply use Jellyfin, and if you run into problems, let us know. This is the most common way we uncover bugs, through a user doing something we hadn't thought about. If the issue does end up being related to the code, a bug issue can then be opened.

Edit this page
Previous
Server Policy
Next
Branding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/style-guides/#__docusaurus_skipToContent_fallback

Skip to main content
Style Guides
Style Guides

This section documents the code style used for the different languages used by Jellyfin.

If the language you are looking for does not have a style guide yet, respect the style of the surrounding code in the files you are editing.

Edit this page
Previous
Source Tree
Next
JavaScript
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/style-guides/#

Skip to main content
Style Guides
Style Guides

This section documents the code style used for the different languages used by Jellyfin.

If the language you are looking for does not have a style guide yet, respect the style of the surrounding code in the files you are editing.

Edit this page
Previous
Source Tree
Next
JavaScript
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/style-guides/javascript

Skip to main content
Style GuidesJavaScript
On this page
JavaScript
Filenames​

Filenames must be camel case and may not include underscores (_) or dashes (-). The filename's extensions must be .js.

File Structure​

All files must abide by the following general structure, with JSDoc comments being optional but preferred.

/**
 * This module documents the structure used by JavaScript code in Jellyfin.
 *
 * @module path/to/this/module
 */

import module from 'dependency';
import { myFunction, myClass } from 'dependency/submodule';
import 'otherDependency';

/**
 * Defines a non-exported function, accessible only from this module.
 *
 * @param {Object} argument - The argument to pass to the function.
 * @returns {Int|null} The resulting object from the function.
 */
function privateFunction (argument) {
    // Code omitted
}

export function publicFunction (argument) {
    // Code omitted
}

export default { publicFunction }

Miscellaneous​
File Encoding​

All files must be encoded in UTF-8 and use LF line endings when committed.

Non-ASCII Characters​

For printable characters, use the actual Unicode character directly in your code.

For non-printable characters, use the hexadecimal or Unicode escape.

Edit this page
Previous
Style Guides
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/clients/#__docusaurus_skipToContent_fallback

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#__docusaurus_skipToContent_fallback

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#official-packages-and-methods

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#debuntu-debian-ubuntu-and-derivatives-using-apt-with-official-repository

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#repository-automatic

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#repository-using-extrepo

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#repository-manual

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#containers

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#community-maintained-packages

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#alpine-linux

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#arch-linux

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#fedora-centos-and-other-rpm-distributions

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#rpm-fusion

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#manual-installation-via-the-rpm-packages

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#gentoo

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#nixos

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#advanced

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#manual-installation-on-debian-ubuntu-and-derivatives

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#deb-packages-very-manual

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#linux-generic-amd64

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#base-installation-process

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#ffmpeg-installation

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#running-jellyfin

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#starting-jellyfin-on-boot-optional

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#portable-dll

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads#portable

Skip to main content
Downloads
Clients
Server
Full Repository
Recommended
All
Filters
Jellyfin Media Player
OfficialOpen Source

The official Jellyfin desktop client.

GitHub
Flathub (Linux)
GitHub Downloads
JellyCon
OfficialOpen Source

A lightweight Kodi add-on that lets you browse and play media files directly from your Jellyfin server within the Kodi interface.

GitHub
Installation Guide
Jellyfin for Android
OfficialOpen Source

The official Jellyfin app for Android devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin Mobile for iOS
OfficialOpen Source

The official Jellyfin app for iOS and iPadOS devices.

GitHub
App Store
Jellyfin for Android TV
OfficialOpen Source

The official Jellyfin app for Android TV and Fire TV devices.

GitHub
F-Droid
Amazon Appstore
Play Store
Jellyfin for Roku
OfficialOpen Source

The official Jellyfin app for Roku devices.

Due to a technical limitation of the Roku store, the Jellyfin app for Roku may state that a cable or satellite subscription is required. However, no subscription of any form is required to use the Jellyfin server or any official client.

GitHub
Channel Store
Jellyfin for WebOS
OfficialOpen Source

The official Jellyfin app for WebOS devices.

GitHub
Content Store
Infuse
Third PartyProprietary

A third-party client for iOS, iPadOS, and tvOS devices.

Website
App Store
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/linux/#building-from-source

Skip to main content
InstallationLinux
On this page
Linux
Official packages and methods​
Debuntu (Debian, Ubuntu, and derivatives using apt) with official repository​

The Jellyfin team provides 3rd-party Debian and Ubuntu repositories, to help ensure your Jellyfin install is always kept up-to-date. For Ubuntu, only LTS distributions from the past 5 years are supported.

Repository (Automatic)​

To simplify deployment and help automate this for as many users as possible, we provide a BASH script to handle repo installation as well as installing Jellyfin. All you need to do is run this command on your system (requires curl, or subsitute curl with wget -O-):

curl https://repo.jellyfin.org/install-debuntu.sh | sudo bash

NOTE

You can verify the script download integrity with (requires sha256sum):

diff <( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) <( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )


An empty output means everything is correct. Then you can inspect the script to see what it does (optional but recommended) and execute it with:

less install-debuntu.sh
sudo bash install-debuntu.sh

NOTE

The script tries to handle as many common derivatives as possible, including, at least, Linux Mint (Ubuntu and Debian editions), Raspbian/Raspberry Pi OS, and KDE Neon. We welcome PRs to the script for any other common derivatives, or you can use the steps below instead.

Repository (Using extrepo)​

extrepo is only supported on Debian currently. The advantage of extrepo is that it is packaged in Debian. So you don’t have to execute the curl | sudo bash combo from the previous Automatic section. The risk with that command is that it relies on the security of the webserver. extrepo avoids this by having the Jellyfin repo information including the GPG key in its extrepo-data. extrepo-data is verified with GPG by the extrepo tool. So there is a chain of trust from Debian all the way to the Jellyfin repo information.

sudo apt install extrepo
sudo extrepo enable jellyfin


Now you can continue at step 5. of the Repository (Manual) section.

Containers​

For non Debian/Ubuntu systems, containers are the recommended way to install Jellyfin. Please follow the instructions here.

Community maintained packages​
Alpine Linux​

Jellyfin can be found in the community repository as jellyfin and jellyfin-web.

To enable the web UI after installing jellyfin-web, make sure to remove the --nowebclient option from /etc/conf.d/jellyfin.

Arch Linux​

The Extra repository contains builds for both jellyfin-server and jellyfin-web. jellyfin-server includes a hard dependency on jellyfin-ffmpeg.

Both packages, server and web, can also be built from source at the tip of the master branch using jellyfin-git. The AUR also offers each separately at jellyfin-server-git and jellyfin-web-git.

Fedora, CentOS and other RPM distributions​

Builds in RPM package format are provided by RPM Fusion. Official packages are no longer provided starting with 10.9.

RPM Fusion​

rpmfusion must be enabled first

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm


Install the jellyfin package, which will automatically install jellyfin-server, jellyfin-web and jellyfin-firewalld

sudo dnf install jellyfin


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin

Manual installation via the .rpm packages​

You will need to enable rpmfusion, as ffmpeg is a dependency of the jellyfin server package

sudo dnf install https://mirrors.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm

NOTE

You do not need to manually install ffmpeg; it will be installed by the Jellyfin server package as a dependency.

Install the Jellyfin server

sudo dnf install <link to server `.rpm` file URL>


Install the Jellyfin web interface

sudo dnf install <link to web `.rpm` file URL>


Enable and start the Jellyfin service:

sudo systemctl enable --now jellyfin


Allow Jellyfin through the firewall:

sudo firewall-cmd --permanent --add-service=jellyfin

NOTE

This will open the following ports:

8096 TCP, used by default for HTTP traffic; you can change this in the dashboard
8920 TCP, used by default for HTTPS traffic; you can change this in the dashboard
1900 UDP, used for service auto-discovery; this is not configurable
7359 UDP, used for auto-discovery; this is not configurable

Reload the firewall to apply the new rules:

sudo firewall-cmd --reload


Go to localhost:8096 or ip-address-of-jellyfin-server:8096 to finish setup in the web UI.

Gentoo​

The Gentoo ebuild repository includes the Jellyfin package which can be installed like other software:

emerge www-apps/jellyfin

NixOS​

NixOS has a module for Jellyfin, it can be enabled as follows:

{
  services.jellyfin.enable = true;
}


For more information, refer to the NixOS wiki.

Advanced​
Manual installation on Debian, Ubuntu and derivatives​
Repository (Manual)​

If you would prefer to install everything manually, the full steps are as follows:

Install curl and gnupg if you haven't already:

sudo apt install curl gnupg


On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the GPG signing key (signed by the Jellyfin Team) and install it:

sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://repo.jellyfin.org/jellyfin_team.gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/jellyfin.gpg


Add a repository configuration at /etc/apt/sources.list.d/jellyfin.sources:

export VERSION_OS="$( awk -F'=' '/^ID=/{ print $NF }' /etc/os-release )"
export VERSION_CODENAME="$( awk -F'=' '/^VERSION_CODENAME=/{ print $NF }' /etc/os-release )"
export DPKG_ARCHITECTURE="$( dpkg --print-architecture )"
cat <<EOF | sudo tee /etc/apt/sources.list.d/jellyfin.sources
Types: deb
URIs: https://repo.jellyfin.org/${VERSION_OS}
Suites: ${VERSION_CODENAME}
Components: main
Architectures: ${DPKG_ARCHITECTURE}
Signed-By: /etc/apt/keyrings/jellyfin.gpg
EOF

NOTE

The supported values for the above variables are:

${VERSION_OS}: One of debian or ubuntu; if it is not, use the closest one for your distribution.
${VERSION_CODENAME}: One of our supported Debian or Ubuntu release codenames. These can change as new releases come out and old releases are dropped, so check the script to be sure yours is supported.
${DPKG_ARCHITECTURE}: One of our supported architectures. Microsoft does not provide a .NET for 32-bit x86 Linux systems, and hence Jellyfin is not supported on the i386 architecture.

Update your APT repositories:

sudo apt update


Install the Jellyfin metapackage, which will automatically fetch the various sub-packages:

sudo apt install jellyfin

NOTE

If you want to be explicit, instead of the metapackage, you can install the sub-packages individually:

sudo apt install jellyfin-server jellyfin-web


The jellyfin-server package will automatically select the right jellyfin-ffmpeg package for you as well.

Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

.deb Packages (Very Manual)​

Raw .deb packages, including old versions, source packages, and dpkg meta files, are available in the main download repository.

NOTE

The repository is the preferred way to obtain Jellyfin on Debian and Ubuntu systems, as this ensures you get automatic updates and that all dependencies are properly resolved. Use these steps only if you really know what you're doing.

On Ubuntu (and derivatives) only, enable the Universe repository to obtain all the FFmpeg dependencies:

sudo add-apt-repository universe

NOTE

If the above command fails you will need to install the following package software-properties-common. This can be achieved with the following command sudo apt-get install software-properties-common

On Debian, you can also enable the non-free components of your base repositories for additional FFmpeg dependencies, but this is optional.

Download the desired jellyfin-server, jellyfin-web, and jellyfin-ffmpeg .deb packages from the repository; jellyfin is a metapackage and is not required.

Install the downloaded .deb packages:

sudo dpkg -i jellyfin_*.deb jellyfin-ffmpeg_*.deb

NOTE

This step may throw errors; continue to the next step to resolve them.

Use apt to install any missing dependencies:

sudo apt -f install


Manage the Jellyfin system service:

sudo systemctl {action} jellyfin
sudo service jellyfin {action}

Linux (generic amd64)​

Generic amd64, arm64, and armhf Linux builds in TAR archive format are available in the main download repository.

Base Installation Process​

Create a directory in /opt for jellyfin and its files, and enter that directory.

sudo mkdir /opt/jellyfin
cd /opt/jellyfin


Download the latest generic Linux build for your architecture. The rest of these instructions assume version 10.8.13 is being installed (i.e. jellyfin_10.8.13_amd64.tar.gz). Download the generic build, then extract the archive:

sudo wget https://repo.jellyfin.org/?path=/server/linux/stable/combined/jellyfin_10.8.13_amd64.tar.gz
sudo tar xvzf jellyfin_10.8.13_amd64.tar.gz


Create a symbolic link to the Jellyfin 10.8.13 directory. This allows an upgrade by repeating the above steps and enabling it by simply re-creating the symbolic link to the new version.

sudo ln -s jellyfin_10.8.13 jellyfin


Create four sub-directories for Jellyfin data.

sudo mkdir data cache config log

FFmpeg Installation​

If you are not running a Debian derivative, install ffmpeg through your OS's package manager, and skip this section.

CAUTION

Not being able to use jellyfin-ffmpeg will most likely break hardware acceleration and tonemapping.

If you are running Debian or a derivative, you should download and install an ffmpeg .deb package built specifically for Jellyfin.

If you run into any dependency errors, run this and it will install them and jellyfin-ffmpeg.

sudo apt install -f

Running Jellyfin​

Due to the number of command line options that must be passed on to the Jellyfin binary, it is easiest to create a small script to run Jellyfin.

sudoedit jellyfin.sh


Then paste the following commands and modify as needed.

#!/bin/bash
JELLYFINDIR="/opt/jellyfin"
FFMPEGDIR="/usr/share/jellyfin-ffmpeg"

$JELLYFINDIR/jellyfin/jellyfin \
 -d $JELLYFINDIR/data \
 -C $JELLYFINDIR/cache \
 -c $JELLYFINDIR/config \
 -l $JELLYFINDIR/log \
 --ffmpeg $FFMPEGDIR/ffmpeg


Assuming you desire Jellyfin to run as a non-root user, chmod all files and directories to your normal login user and group. Also make the startup script above executable.

sudo chown -R user:group *
sudo chmod u+x jellyfin.sh


Finally you can run it. You will see lots of log information when run, this is normal. Setup is as usual in the web browser.

./jellyfin.sh

Starting Jellyfin on boot (optional)​

Create a systemd unit file.

cd /etc/systemd/system
sudo nano jellyfin.service


Then paste the following contents, replacing youruser with your username.

[Unit]
Description=Jellyfin
After=network.target

[Service]
Type=simple
User=youruser
Restart=always
ExecStart=/opt/jellyfin/jellyfin.sh

[Install]
WantedBy=multi-user.target


Apply the correct permissions to the file, enable the service to start on boot, then start it.

sudo chmod 644 jellyfin.service
sudo systemctl daemon-reload
sudo systemctl enable jellyfin.service
sudo systemctl start jellyfin.service

Portable DLL​

Platform-agnostic .NET Core DLL builds in TAR archive format are available here. These builds use the binary jellyfin.dll and must be loaded with dotnet.

Building from source​

Jellyfin can be built from source directly. Please read Building from source for more info.

Edit this page
Previous
Container
Next
Windows
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#__docusaurus_skipToContent_fallback

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#container-images

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#docker

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/configuration/#server-side-system-fonts

Skip to main content
AdministrationConfiguration
On this page
Configuration

There are several entry points available for administrators to manage the configuration of their server. This section aims to outline all those configuration methods, explain what options are available, and what each option does.

NOTE

The configuration options here are distinct from the runtime settings available from the Administrator Dashboard in the web client. The configuration options here are generally meant to be static and set before starting the server.

Command Line Options​

Documentation for the available command line options can be obtained by adding the --help flag when running the Jellyfin executable.

Server Paths​

The file paths used by the server are determined according to the rules outlined below. In general, the XDG specification is followed by default for non-Windows systems.

Data Directory​

This is the directory that will hold all Jellyfin data and is also used as a default base directory for some other paths below. It is set from the following sources in order of decreasing precedence.

Command line option --datadir, if specified
Environment variable JELLYFIN_DATA_DIR, if specified
<%ProgramData%>\Jellyfin\Server, if launching from the Windows Tray app.
<%LocalAppData%>\jellyfin, if launching the Windows server directly.
$XDG_DATA_HOME/jellyfin, if $XDG_DATA_HOME exists
$HOME/.local/share/jellyfin
NOTE

Windows users can also specify the data directory using a Windows Registry string key called DataFolder located at Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server

An additional string key called InstallFolder in Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server can also specify the install location.

Configuration Directory​

This is the directory containing the server configuration files. It is set from the following sources in order of decreasing precedence.

Command line option --configdir, if specified
Environment variable JELLYFIN_CONFIG_DIR, if specified
<Data Directory>/config, if it exists or if running on Windows
$XDG_CONFIG_HOME/jellyfin if $XDG_CONFIG_HOME exists
$HOME/.config/jellyfin
Cache Directory​

This is the directory containing the server cache. It is set from the following sources in order of decreasing precedence.

Command line option --cachedir, if specified
Environment variable $JELLYFIN_CACHE_DIR, if specified
<Data Directory>/cache, if Windows
$XDG_CACHE_HOME/jellyfin if $XDG_CACHE_HOME exists
$HOME/.cache/jellyfin
Web Directory​

This is the directory containing the built files from a web client release. It is set from the following sources in order of decreasing precedence.

Command line option --webdir, if specified
Environment variable $JELLYFIN_WEB_DIR, if specified
<Binary Directory>/jellyfin-web, where <Binary Directory> is the directory containing the Jellyfin executable
NOTE

This setting is only used when the server is configured to host the web client. See the hostwebclient option in the Main Configuration Options section below for additional details.

Log Directory​

This is the directory where the Jellyfin logs will be stored. It is set from the following sources in order of decreasing precedence.

Command line option --logdir, if specified
Environment variable $JELLYFIN_LOG_DIR, if specified
<Data Directory>/log
Main Configuration​

The main server configuration is built upon the ASP .NET configuration framework, which provides a tiered approach to loading configuration. The base directory to locate the configuration files is set using the configuration directory setting. The configuration sources are as follows, with later sources having higher priority and overwriting the values in earlier sources.

Hard-coded default values: These defaults are specified in the Jellyfin source code and cannot be changed.

Default logging configuration file (logging.default.json): This file should not be modified manually by users. It is reserved by the server to be overwritten with new settings on each new release.

System-specific logging configuration file (logging.json): This is the file you should change if you want to have a custom logging setup. Jellyfin uses the Serilog logging framework, and you can read about the configuration options available in their documentation.

NOTE

This file can be changed at runtime, which will automatically reload the configuration and apply the changes immediately.

Environment variables: The documentation provided by Microsoft explains how to set these configuration options via environment variables. Jellyfin uses its own custom JELLYFIN_ prefix for these variables. For example, to set a value for the HttpListenerHost:DefaultRedirectPath setting, you would set a value for the JELLYFIN_HttpListenerHost__DefaultRedirectPath environment variable.

Command line options: Certain command line options are loaded into the configuration system and have the highest priority. The following command line options are mapped to associated configuration options.

--nowebclient sets the hostwebclient configuration setting to false
Main Configuration Options​

This section lists all the configuration options available and explains their function.

Key	Default Value	Description
hostwebclient	True	Set to True if the server should host the web client.
FFmpeg:probesize	"1G"	Value to set for the FFmpeg probesize format option. See the FFmpg documentation for more details.
FFmpeg:analyzeduration	"200M"	The value to set for the FFmpeg analyzeduration format option. See the FFmpg documentation for more details.
PublishedServerUrl	Server Url based on primary IP address	The Server URL to publish in udp Auto Discovery response.
Fonts​

Jellyfin uses fonts to render text in many places.

Server Side System Fonts​

The system fonts installed on the server are used for burning in subtitles and rendering cover images. How to install them depends on the operating system or if a container is being used.

Client Side System Fonts​

The system fonts installed on the client devices are used to display the text in the client interface as well as render subtitles for some clients. How to install them depends on the operating system.

Fallback Fonts​

The Fallback Fonts installed on the server are loaded up by the web client to render ASS subtitles. They will be used if no other existing fonts (such as MKV attachments or client-side fonts) can be used to render certain glyphs, such as CJK characters, instead of displaying an empty "tofu" block.

This setting can be set to a folder on the server containing fonts for this purpose. These fonts are limited to a total size of 20 MB, since all of them will be always preloaded in the browser, regardless of whether they'll be needed or not. Lightweight formats optimized for web like woff2 are recommended. A tool to convert normal TrueType (.ttf) and OpenType (.otf) fonts to woff2 can be found in their repo.

Downloading Fonts​

There are many fonts available online. Google Fonts is a good place to download fonts for most languages.

Edit this page
Previous
Backup and Restore
Next
Hardware Acceleration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/configuration/#fallback-fonts

Skip to main content
AdministrationConfiguration
On this page
Configuration

There are several entry points available for administrators to manage the configuration of their server. This section aims to outline all those configuration methods, explain what options are available, and what each option does.

NOTE

The configuration options here are distinct from the runtime settings available from the Administrator Dashboard in the web client. The configuration options here are generally meant to be static and set before starting the server.

Command Line Options​

Documentation for the available command line options can be obtained by adding the --help flag when running the Jellyfin executable.

Server Paths​

The file paths used by the server are determined according to the rules outlined below. In general, the XDG specification is followed by default for non-Windows systems.

Data Directory​

This is the directory that will hold all Jellyfin data and is also used as a default base directory for some other paths below. It is set from the following sources in order of decreasing precedence.

Command line option --datadir, if specified
Environment variable JELLYFIN_DATA_DIR, if specified
<%ProgramData%>\Jellyfin\Server, if launching from the Windows Tray app.
<%LocalAppData%>\jellyfin, if launching the Windows server directly.
$XDG_DATA_HOME/jellyfin, if $XDG_DATA_HOME exists
$HOME/.local/share/jellyfin
NOTE

Windows users can also specify the data directory using a Windows Registry string key called DataFolder located at Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server

An additional string key called InstallFolder in Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server can also specify the install location.

Configuration Directory​

This is the directory containing the server configuration files. It is set from the following sources in order of decreasing precedence.

Command line option --configdir, if specified
Environment variable JELLYFIN_CONFIG_DIR, if specified
<Data Directory>/config, if it exists or if running on Windows
$XDG_CONFIG_HOME/jellyfin if $XDG_CONFIG_HOME exists
$HOME/.config/jellyfin
Cache Directory​

This is the directory containing the server cache. It is set from the following sources in order of decreasing precedence.

Command line option --cachedir, if specified
Environment variable $JELLYFIN_CACHE_DIR, if specified
<Data Directory>/cache, if Windows
$XDG_CACHE_HOME/jellyfin if $XDG_CACHE_HOME exists
$HOME/.cache/jellyfin
Web Directory​

This is the directory containing the built files from a web client release. It is set from the following sources in order of decreasing precedence.

Command line option --webdir, if specified
Environment variable $JELLYFIN_WEB_DIR, if specified
<Binary Directory>/jellyfin-web, where <Binary Directory> is the directory containing the Jellyfin executable
NOTE

This setting is only used when the server is configured to host the web client. See the hostwebclient option in the Main Configuration Options section below for additional details.

Log Directory​

This is the directory where the Jellyfin logs will be stored. It is set from the following sources in order of decreasing precedence.

Command line option --logdir, if specified
Environment variable $JELLYFIN_LOG_DIR, if specified
<Data Directory>/log
Main Configuration​

The main server configuration is built upon the ASP .NET configuration framework, which provides a tiered approach to loading configuration. The base directory to locate the configuration files is set using the configuration directory setting. The configuration sources are as follows, with later sources having higher priority and overwriting the values in earlier sources.

Hard-coded default values: These defaults are specified in the Jellyfin source code and cannot be changed.

Default logging configuration file (logging.default.json): This file should not be modified manually by users. It is reserved by the server to be overwritten with new settings on each new release.

System-specific logging configuration file (logging.json): This is the file you should change if you want to have a custom logging setup. Jellyfin uses the Serilog logging framework, and you can read about the configuration options available in their documentation.

NOTE

This file can be changed at runtime, which will automatically reload the configuration and apply the changes immediately.

Environment variables: The documentation provided by Microsoft explains how to set these configuration options via environment variables. Jellyfin uses its own custom JELLYFIN_ prefix for these variables. For example, to set a value for the HttpListenerHost:DefaultRedirectPath setting, you would set a value for the JELLYFIN_HttpListenerHost__DefaultRedirectPath environment variable.

Command line options: Certain command line options are loaded into the configuration system and have the highest priority. The following command line options are mapped to associated configuration options.

--nowebclient sets the hostwebclient configuration setting to false
Main Configuration Options​

This section lists all the configuration options available and explains their function.

Key	Default Value	Description
hostwebclient	True	Set to True if the server should host the web client.
FFmpeg:probesize	"1G"	Value to set for the FFmpeg probesize format option. See the FFmpg documentation for more details.
FFmpeg:analyzeduration	"200M"	The value to set for the FFmpeg analyzeduration format option. See the FFmpg documentation for more details.
PublishedServerUrl	Server Url based on primary IP address	The Server URL to publish in udp Auto Discovery response.
Fonts​

Jellyfin uses fonts to render text in many places.

Server Side System Fonts​

The system fonts installed on the server are used for burning in subtitles and rendering cover images. How to install them depends on the operating system or if a container is being used.

Client Side System Fonts​

The system fonts installed on the client devices are used to display the text in the client interface as well as render subtitles for some clients. How to install them depends on the operating system.

Fallback Fonts​

The Fallback Fonts installed on the server are loaded up by the web client to render ASS subtitles. They will be used if no other existing fonts (such as MKV attachments or client-side fonts) can be used to render certain glyphs, such as CJK characters, instead of displaying an empty "tofu" block.

This setting can be set to a folder on the server containing fonts for this purpose. These fonts are limited to a total size of 20 MB, since all of them will be always preloaded in the browser, regardless of whether they'll be needed or not. Lightweight formats optimized for web like woff2 are recommended. A tool to convert normal TrueType (.ttf) and OpenType (.otf) fonts to woff2 can be found in their repo.

Downloading Fonts​

There are many fonts available online. Google Fonts is a good place to download fonts for most languages.

Edit this page
Previous
Backup and Restore
Next
Hardware Acceleration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#using-docker-compose

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#podman

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#managing-via-systemd

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#with-hardware-acceleration

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#podman-run

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/container/#systemd

Skip to main content
InstallationContainer
On this page
Container
Container images​

Official container image: jellyfin/jellyfin .

LinuxServer.io image: linuxserver/jellyfin .

hotio image: hotio/jellyfin .

Jellyfin distributes official container images on Docker Hub for multiple architectures. These images are based on Debian and built directly from the Jellyfin source code.

Additionally, there are several third parties providing unofficial container images, including the LinuxServer.io (Dockerfile) project and hotio (Dockerfile), which offer images based on Ubuntu and the official Jellyfin Ubuntu binary packages.

Docker​

Docker allows you to run containers on Linux, Windows and MacOS.

WARNING

If you wish to use Windows or macOS, please install Jellyfin natively instead. Windows macOS.

While it is possible to run Jellyfin in Docker on a Windows or macOS host, it is NOT supported. Some features are known to be broken when running in Docker on platforms other than Linux, Notably:

Hardware Accelerated Transcoding
Scanning on macOS in Docker

You WILL NOT receive any support for running Jellyfin in Docker on platforms other than Linux.

The basic steps to create and run a Jellyfin container using Docker are as follows.

Follow the official installation guide to install Docker.

Download the latest container image.

docker pull jellyfin/jellyfin


Create persistent storage for configuration and cache data.

Either create two directories on the host and use bind mounts:

mkdir /path/to/config
mkdir /path/to/cache


Or create two persistent volumes:

docker volume create jellyfin-config
docker volume create jellyfin-cache


Create and run a container in one of the following ways.

NOTE

The default network mode for Docker is bridge mode. Bridge mode will be used if host mode is omitted. Using host networking (--net=host) is optional but required in order to use DLNA.

Using Docker command line interface:

docker run -d \
 --name jellyfin \
 --user uid:gid \
 --net=host \
 --volume /path/to/config:/config \ # Alternatively --volume jellyfin-config:/config
 --volume /path/to/cache:/cache \ # Alternatively --volume jellyfin-cache:/cache
 --mount type=bind,source=/path/to/media,target=/media \
 --restart=unless-stopped \
 jellyfin/jellyfin


Bind Mounts are needed to pass folders from the host OS to the container OS whereas volumes are maintained by Docker and can be considered easier to backup and control by external programs. For a simple setup, it's considered easier to use Bind Mounts instead of volumes. Multiple media libraries can be bind mounted if needed:

--mount type=bind,source=/path/to/media1,target=/media1
--mount type=bind,source=/path/to/media2,target=/media2,readonly
...etc


Custom server-side system fonts directory can be optionally bind mounted in order to use these fonts during transcoding with subtitle burn-in:

--mount type=bind,source=/path/to/fonts,target=/usr/local/share/fonts/custom,readonly


A directory of fallback fonts can be mounted as well. In this case, you will have to set the directory of fallback fonts to /fallback_fonts in Jellyfin server settings panel:

--mount type=bind,source=/path/to/fallback/fonts,target=/fallback_fonts,readonly

Using Docker Compose​

Create a docker-compose.yml file with the following contents. Add in the UID and GID that you would like to run jellyfin as in the user line below, or remove the user line to use the default (root).

services:
  jellyfin:
    image: jellyfin/jellyfin
    container_name: jellyfin
    user: uid:gid
    network_mode: 'host'
    volumes:
      - /path/to/config:/config
      - /path/to/cache:/cache
      - type: bind
        source: /path/to/media
        target: /media
      - type: bind
        source: /path/to/media2
        target: /media2
        read_only: true
      # Optional - extra fonts to be used during transcoding with subtitle burn-in
      - type: bind
        source: /path/to/fonts
        target: /usr/local/share/fonts/custom
        read_only: true
    restart: 'unless-stopped'
    # Optional - alternative address used for autodiscovery
    environment:
      - JELLYFIN_PublishedServerUrl=http://example.com
    # Optional - may be necessary for docker healthcheck to pass if running in host network mode
    extra_hosts:
      - 'host.docker.internal:host-gateway'


Then while in the same folder as the docker-compose.yml run:

docker compose up


To run the container in background add -d to the above command.

You can learn more about using Docker by reading the official Docker documentation.

Podman​

Podman allows you to run rootless containers. It's also the officially supported container solution on Fedora Linux and its derivatives such as CentOS Stream and RHEL. Steps to run Jellyfin using Podman are similar to the Docker steps.

Install Podman:

sudo dnf install -y podman


Create and run a Jellyfin container:

podman run \
 --detach \
 --label "io.containers.autoupdate=registry" \
 --name myjellyfin \
 --publish 8096:8096/tcp \
 --rm \
 --user $(id -u):$(id -g) \
 --userns keep-id \
 --volume jellyfin-cache:/cache:Z \
 --volume jellyfin-config:/config:Z \
 --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
 docker.io/jellyfin/jellyfin:latest


Open the necessary ports in your machine's firewall if you wish to permit access to the Jellyfin server from outside the host. This is not done automatically when using rootless Podman. If your distribution uses firewalld, the following commands save and load a new firewall rule opening the HTTP port 8096 for TCP connections.

sudo firewall-cmd --add-port=8096/tcp --permanent
sudo firewall-cmd --reload


Podman doesn't require root access to run containers, although there are some details to be mindful of; see the relevant documentation. For security, the Jellyfin container should be run using rootless Podman. Furthermore, it is safer to run as a non-root user within the container. The --user option will run with the provided user id and group id inside the container. The --userns keep-id flag ensures that current user's id is mapped to the non-root user's id inside the container. This ensures that the permissions for directories bind-mounted inside the container are mapped correctly between the user running Podman and the user running Jellyfin inside the container.

Keep in mind that the --label "io.containers.autoupdate=image" flag will allow the container to be automatically updated via podman auto-update.

The z (shared volume) or Z (private volume) volume option and relabel=shared or relabel=private mount option tell Podman to relabel files inside the volumes as appropriate, for systems running SELinux.

Replace jellyfin-config and jellyfin-cache with /path/to/config and /path/to/cache if you wish to use bind mounts.

This example mounts your media library read-only by setting ro=true; set this to ro=false if you wish to give Jellyfin write access to your media.

Managing via Systemd​

To run as a systemd service see podman-systemd.unit.

As always it is recommended to run the container rootless. Therefore we want to manage the container with the systemd --user flag.

Create a new user that the rootless container will run under.

useradd jellyfin

This allows users who are not logged in to run long-running services.

loginctl enable-linger jellyfin

Open an interactive shell session.

machinectl shell jellyfin@

Install .config/containers/systemd/jellyfin.container

Contents of ~/.config/containers/systemd/jellyfin.container

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target


Reload daemon and start the service.

systemctl --user daemon-reload

systemctl --user start jellyfin

To enable Podman auto-updates, enable the necessary systemd timer.

systemctl --user enable --now podman-auto-update.timer

Optionally check logs for errors

journalctl --user -u jellyfin

exit the current session.

With hardware acceleration​

To use hardware acceleration, you need to allow the container to access the render device. If you are using container-selinux-2.226 or later, you have to set the container_use_dri_devices flag in selinux or the container will not be able to use it:

sudo setsebool -P container_use_dri_devices 1

On older versions of container-selinux, you have to disable the selinux confinement for the container by adding --security-opt label=disable to the podman command.

Then, you need to mount the render device inside the container:

--device /dev/dri/:/dev/dri/

Finally, you need to set the --device flag for the container to use the render device:

--device /dev/dri/

podman run​
   podman run \
    --detach \
    --label "io.containers.autoupdate=registry" \
    --name myjellyfin \
    --publish 8096:8096/tcp \
    --device /dev/dri/:/dev/dri/ \
    # --security-opt label=disable # Only needed for older versions of container-selinux < 2.226
    --rm \
    --user $(id -u):$(id -g) \
    --userns keep-id \
    --volume jellyfin-cache:/cache:Z \
    --volume jellyfin-config:/config:Z \
    --mount type=bind,source=/path/to/media,destination=/media,ro=true,relabel=private \
    docker.io/jellyfin/jellyfin:latest

systemd​
[Unit]
Description=jellyfin

[Container]
Image=docker.io/jellyfin/jellyfin:latest
AutoUpdate=registry
PublishPort=8096:8096/tcp
UserNS=keep-id
#SecurityLabelDisable=true # Only needed for older versions of container-selinux < 2.226
AddDevice=/dev/dri/:/dev/dri/
Volume=jellyfin-config:/config:Z
Volume=jellyfin-cache:/cache:Z
Volume=jellyfin-media:/media:Z

[Service]
# Inform systemd of additional exit status
SuccessExitStatus=0 143

[Install]
# Start by default on boot
WantedBy=default.target

Edit this page
Previous
Installation
Next
Linux
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/windows/#__docusaurus_skipToContent_fallback

Skip to main content
InstallationWindows
On this page
Windows

Windows installers and builds in ZIP archive format are available here.

CAUTION

If you installed a version prior to 10.4.0 using a PowerShell script, you will need to manually remove the service using the command nssm remove Jellyfin and uninstall the server by remove all the files manually. Also one might need to move the data files to the correct location, or point the installer at the old location.

CAUTION

The Basic Install is the recommended way to run the Jellyfin Server. Using the Advanced/Service mode may experience FFmpeg hardware acceleration issues and is only for advanced users.

Install using installer​

Install

Download the latest version.
Run the installer.
(Optional) When installing as a service (not recommended), pick the service account type.
If everything was completed successfully, Jellyfin is now running.
Open your browser at http://your_local_IP_address:8096 to finish setting up Jellyfin.

Update

Download the latest version.
Close or Stop Jellyfin if it is running.
Run the installer.
If everything was completed successfully, the new version is installed.

Uninstall

Go to Add or remove programs in Windows.
Search for Jellyfin.
Click Uninstall.
Install manually (portable)​

Install

Download and extract the latest version.

Create a folder jellyfin at your preferred install location.

Copy the extracted folder into the jellyfin folder and rename it to system.

Create jellyfin.bat within your jellyfin folder containing:

To use the default library/data location at %localappdata%:
<--Your install path-->\jellyfin\system\jellyfin.exe

To use a custom library/data location (Path after the -d parameter):
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data

To use a custom library/data location (Path after the -d parameter) and disable the auto-start of the webapp:
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data -noautorunwebapp


Run

jellyfin.bat


Open your browser at http://<--Server-IP-->:8096.

Update

Stop Jellyfin
Rename the Jellyfin system folder to system-bak
Download and extract the latest Jellyfin version
Copy the extracted folder into the jellyfin folder and rename it to system
Run jellyfin.bat to start the server again

Rollback

Stop Jellyfin.
Delete the system folder.
Rename system-bak to system.
Run jellyfin.bat to start the server again.
Edit this page
Previous
Linux
Next
TrueNAS SCALE
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/windows/#

Skip to main content
InstallationWindows
On this page
Windows

Windows installers and builds in ZIP archive format are available here.

CAUTION

If you installed a version prior to 10.4.0 using a PowerShell script, you will need to manually remove the service using the command nssm remove Jellyfin and uninstall the server by remove all the files manually. Also one might need to move the data files to the correct location, or point the installer at the old location.

CAUTION

The Basic Install is the recommended way to run the Jellyfin Server. Using the Advanced/Service mode may experience FFmpeg hardware acceleration issues and is only for advanced users.

Install using installer​

Install

Download the latest version.
Run the installer.
(Optional) When installing as a service (not recommended), pick the service account type.
If everything was completed successfully, Jellyfin is now running.
Open your browser at http://your_local_IP_address:8096 to finish setting up Jellyfin.

Update

Download the latest version.
Close or Stop Jellyfin if it is running.
Run the installer.
If everything was completed successfully, the new version is installed.

Uninstall

Go to Add or remove programs in Windows.
Search for Jellyfin.
Click Uninstall.
Install manually (portable)​

Install

Download and extract the latest version.

Create a folder jellyfin at your preferred install location.

Copy the extracted folder into the jellyfin folder and rename it to system.

Create jellyfin.bat within your jellyfin folder containing:

To use the default library/data location at %localappdata%:
<--Your install path-->\jellyfin\system\jellyfin.exe

To use a custom library/data location (Path after the -d parameter):
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data

To use a custom library/data location (Path after the -d parameter) and disable the auto-start of the webapp:
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data -noautorunwebapp


Run

jellyfin.bat


Open your browser at http://<--Server-IP-->:8096.

Update

Stop Jellyfin
Rename the Jellyfin system folder to system-bak
Download and extract the latest Jellyfin version
Copy the extracted folder into the jellyfin folder and rename it to system
Run jellyfin.bat to start the server again

Rollback

Stop Jellyfin.
Delete the system folder.
Rename system-bak to system.
Run jellyfin.bat to start the server again.
Edit this page
Previous
Linux
Next
TrueNAS SCALE
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/windows

Skip to main content
Downloads
Clients
Server
Full Repository
Linux
Docker
Windows
macOS
.NET
Unstable
Stable
Help?
Windows
Official

Both installers (.exe) and manual ZIP archives (.zip) are provided.

Downloads
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/windows/#install-using-installer

Skip to main content
InstallationWindows
On this page
Windows

Windows installers and builds in ZIP archive format are available here.

CAUTION

If you installed a version prior to 10.4.0 using a PowerShell script, you will need to manually remove the service using the command nssm remove Jellyfin and uninstall the server by remove all the files manually. Also one might need to move the data files to the correct location, or point the installer at the old location.

CAUTION

The Basic Install is the recommended way to run the Jellyfin Server. Using the Advanced/Service mode may experience FFmpeg hardware acceleration issues and is only for advanced users.

Install using installer​

Install

Download the latest version.
Run the installer.
(Optional) When installing as a service (not recommended), pick the service account type.
If everything was completed successfully, Jellyfin is now running.
Open your browser at http://your_local_IP_address:8096 to finish setting up Jellyfin.

Update

Download the latest version.
Close or Stop Jellyfin if it is running.
Run the installer.
If everything was completed successfully, the new version is installed.

Uninstall

Go to Add or remove programs in Windows.
Search for Jellyfin.
Click Uninstall.
Install manually (portable)​

Install

Download and extract the latest version.

Create a folder jellyfin at your preferred install location.

Copy the extracted folder into the jellyfin folder and rename it to system.

Create jellyfin.bat within your jellyfin folder containing:

To use the default library/data location at %localappdata%:
<--Your install path-->\jellyfin\system\jellyfin.exe

To use a custom library/data location (Path after the -d parameter):
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data

To use a custom library/data location (Path after the -d parameter) and disable the auto-start of the webapp:
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data -noautorunwebapp


Run

jellyfin.bat


Open your browser at http://<--Server-IP-->:8096.

Update

Stop Jellyfin
Rename the Jellyfin system folder to system-bak
Download and extract the latest Jellyfin version
Copy the extracted folder into the jellyfin folder and rename it to system
Run jellyfin.bat to start the server again

Rollback

Stop Jellyfin.
Delete the system folder.
Rename system-bak to system.
Run jellyfin.bat to start the server again.
Edit this page
Previous
Linux
Next
TrueNAS SCALE
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/windows/#install-manually-portable

Skip to main content
InstallationWindows
On this page
Windows

Windows installers and builds in ZIP archive format are available here.

CAUTION

If you installed a version prior to 10.4.0 using a PowerShell script, you will need to manually remove the service using the command nssm remove Jellyfin and uninstall the server by remove all the files manually. Also one might need to move the data files to the correct location, or point the installer at the old location.

CAUTION

The Basic Install is the recommended way to run the Jellyfin Server. Using the Advanced/Service mode may experience FFmpeg hardware acceleration issues and is only for advanced users.

Install using installer​

Install

Download the latest version.
Run the installer.
(Optional) When installing as a service (not recommended), pick the service account type.
If everything was completed successfully, Jellyfin is now running.
Open your browser at http://your_local_IP_address:8096 to finish setting up Jellyfin.

Update

Download the latest version.
Close or Stop Jellyfin if it is running.
Run the installer.
If everything was completed successfully, the new version is installed.

Uninstall

Go to Add or remove programs in Windows.
Search for Jellyfin.
Click Uninstall.
Install manually (portable)​

Install

Download and extract the latest version.

Create a folder jellyfin at your preferred install location.

Copy the extracted folder into the jellyfin folder and rename it to system.

Create jellyfin.bat within your jellyfin folder containing:

To use the default library/data location at %localappdata%:
<--Your install path-->\jellyfin\system\jellyfin.exe

To use a custom library/data location (Path after the -d parameter):
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data

To use a custom library/data location (Path after the -d parameter) and disable the auto-start of the webapp:
<--Your install path-->\jellyfin\system\jellyfin.exe -d <--Your install path-->\jellyfin\data -noautorunwebapp


Run

jellyfin.bat


Open your browser at http://<--Server-IP-->:8096.

Update

Stop Jellyfin
Rename the Jellyfin system folder to system-bak
Download and extract the latest Jellyfin version
Copy the extracted folder into the jellyfin folder and rename it to system
Run jellyfin.bat to start the server again

Rollback

Stop Jellyfin.
Delete the system folder.
Rename system-bak to system.
Run jellyfin.bat to start the server again.
Edit this page
Previous
Linux
Next
TrueNAS SCALE
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#__docusaurus_skipToContent_fallback

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/downloads/macos

Skip to main content
Downloads
Clients
Server
Full Repository
Linux
Docker
Windows
macOS
.NET
Unstable
Stable
Help?
macOS
Official

Both installers (.dmg) and manual TAR archives (.tar.xz) are provided.

Downloads
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#packaged-versiondmg

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#install

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#upgrade

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#uninstall

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#deleting-configuration

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#portable-version

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#installing-the-portable-version

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#upgrading-the-portable-version

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#uninstalling-the-portable-version

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/macos/#using-ffmpeg-with-the-portable-version

Skip to main content
InstallationmacOS
On this page
Install on macOS

macOS Application packages and builds in TAR archive format are available here.

Jellyfin requires macOS 12 or newer to run. Jellyfin 10.9 or newer is required for Apple Silicon native support.

Packaged Version(dmg)​
Install​
Download the latest version.
Drag the .app package into the Applications folder.
Start the application.
Click the icon in the menu bar and select "Launch Web UI".
Upgrade​
Download the latest version.
Stop the currently running server either via the dashboard or using the menu bar icon.
Drag the new .app package into the Applications folder and click yes to replace the files.
Start the application.
Uninstall​
Stop the currently running server either via the dashboard or using the application icon.
Move the .app package to the trash.
Deleting Configuration​

This will delete all settings and user information. This applies for the .app package and the portable version.

Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Portable Version​

The portable version is intended for advanced users who want more customization options.

For average users, the packaged version is strongly recommended.

If you are not comfortable with command line, then this is not the version for you.

Installing the Portable Version​
Download the latest version of Jellyfin.
Extract it into the Applications folder.
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096.

Closing the terminal window will end Jellyfin. Running Jellyfin in screen or tmux can prevent this from happening.

Upgrading the Portable Version​
Download the latest version.
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Extract the latest version into Applications
Open Terminal and type cd followed with a space then drag the jellyfin folder into the terminal.
Type xattr -rd com.apple.quarantine . to remove the quarantine flag.
Type codesign -fs - --deep jellyfin to create an ad-hoc signature for the server.
Type ./jellyfin to run jellyfin.
Open your browser at http://localhost:8096
Uninstalling the Portable Version​
Stop the currently running server either via the dashboard or using CTRL+C in the terminal window.
Move /Application/jellyfin-version folder to the Trash. Replace version with the actual version number you are trying to delete.
Delete the folder ~/.config/jellyfin/
Delete the folder ~/.local/share/jellyfin/
Using FFmpeg with the Portable Version​

The portable version doesn't come with FFmpeg by default. There are a few options for installing FFmpeg:

download jellyfin-ffmpeg from the Jellyfin repo (recommended)
use the package manager homebrew by typing brew install ffmpeg into your Terminal (here's how to install homebrew if you don't have it already
download the most recent static build from this link (compiled by a third party see this page for options and information) (Apple Silicon builds are not available from this source)
compile from source available from the official website

Once downloaded, remove the quarantine flag for the ffmpeg and ffprobe.

Ensure that both ffmpeg and ffprobe are located at the same path, then execute the following command:

cd /path/to/ffmpeg/folder
xattr -rd com.apple.quarantine .

Edit this page
Previous
Synology
Next
Building from source
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source/#__docusaurus_skipToContent_fallback

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source/#

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source/#container-image

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source/#linux-or-macos

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/installation/source/#windows

Skip to main content
InstallationBuilding from source
On this page
Building from source

As an alternative to using binary packages, you can build Jellyfin from source.

Jellyfin supports several methods of building for different platforms and instructions for all supported platforms are below.

All package builds begin with these two steps:

Clone the repository.

git clone https://github.com/jellyfin/jellyfin-packaging.git
cd jellyfin-packaging


Initialize the submodules.

git submodule update --init

Container image​

Build the container image using Docker or Podman.

docker build -t $USERNAME/jellyfin --file docker/Dockerfile .


or

podman build -t $USERNAME/jellyfin --file docker/Dockerfile .


or use provided Python build script:

./build.py auto docker


Replace "auto" with your own Jellyfin version tag if you want to.

Run Jellyfin in a new container using Docker or Podman from the built container image.

docker run -d -p 8096:8096 $USERNAME/jellyfin


or

podman run -d -p 8096:8096 $USERNAME/jellyfin

Linux or MacOS​

Use the included build script to perform builds.

./build --help
./build --list-platforms
./build <platform> all


The resulting archives can be found at ../bin/<platform>.

NOTE

This will very likely be split out into a separate repository at some point in the future.

Windows​

Install dotnet SDK 8.0 from Microsoft's Website and install Git for Windows. You must be on Powershell 3 or higher.

From Powershell set the execution policy to unrestricted.

set-executionpolicy unrestricted


If you are building a version of Jellyfin newer than 10.6.4, you will need to download the build script from a separate repository.

git clone https://github.com/jellyfin/jellyfin-server-windows.git windows


Run the Jellyfin build script.

windows\build-jellyfin.ps1 -verbose


The -WindowsVersion and -Architecture flags can optimize the build for your current environment; the default is generic Windows x64.

The -InstallLocation flag lets you select where the compiled binaries go; the default is $Env:AppData\Jellyfin-Server\.

The -InstallFFMPEG flag will automatically pull the stable ffmpeg binaries appropriate to your architecture (x86/x64 only for now) from BtbN and place them in your Jellyfin directory.

The -InstallNSSM flag will automatically pull the stable nssm binary appropriate to your architecture (x86/x64 only for now) from NSSM's Website and place it in your Jellyfin directory.

(Optional) Use NSSM to configure Jellyfin to run as a service.

Jellyfin is now available in the default directory, or whichever directory you chose.

Start it from PowerShell.

&"$env:APPDATA\Jellyfin-Server\jellyfin.exe"


Start it from CMD.

%APPDATA%\Jellyfin-Server\jellyfin.exe

NOTE

This will very likely be split out into a separate repository at some point in the future.

Edit this page
Previous
macOS
Next
Backup and Restore
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#__docusaurus_skipToContent_fallback

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/configuration

Skip to main content
AdministrationConfiguration
On this page
Configuration

There are several entry points available for administrators to manage the configuration of their server. This section aims to outline all those configuration methods, explain what options are available, and what each option does.

NOTE

The configuration options here are distinct from the runtime settings available from the Administrator Dashboard in the web client. The configuration options here are generally meant to be static and set before starting the server.

Command Line Options​

Documentation for the available command line options can be obtained by adding the --help flag when running the Jellyfin executable.

Server Paths​

The file paths used by the server are determined according to the rules outlined below. In general, the XDG specification is followed by default for non-Windows systems.

Data Directory​

This is the directory that will hold all Jellyfin data and is also used as a default base directory for some other paths below. It is set from the following sources in order of decreasing precedence.

Command line option --datadir, if specified
Environment variable JELLYFIN_DATA_DIR, if specified
<%ProgramData%>\Jellyfin\Server, if launching from the Windows Tray app.
<%LocalAppData%>\jellyfin, if launching the Windows server directly.
$XDG_DATA_HOME/jellyfin, if $XDG_DATA_HOME exists
$HOME/.local/share/jellyfin
NOTE

Windows users can also specify the data directory using a Windows Registry string key called DataFolder located at Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server

An additional string key called InstallFolder in Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server can also specify the install location.

Configuration Directory​

This is the directory containing the server configuration files. It is set from the following sources in order of decreasing precedence.

Command line option --configdir, if specified
Environment variable JELLYFIN_CONFIG_DIR, if specified
<Data Directory>/config, if it exists or if running on Windows
$XDG_CONFIG_HOME/jellyfin if $XDG_CONFIG_HOME exists
$HOME/.config/jellyfin
Cache Directory​

This is the directory containing the server cache. It is set from the following sources in order of decreasing precedence.

Command line option --cachedir, if specified
Environment variable $JELLYFIN_CACHE_DIR, if specified
<Data Directory>/cache, if Windows
$XDG_CACHE_HOME/jellyfin if $XDG_CACHE_HOME exists
$HOME/.cache/jellyfin
Web Directory​

This is the directory containing the built files from a web client release. It is set from the following sources in order of decreasing precedence.

Command line option --webdir, if specified
Environment variable $JELLYFIN_WEB_DIR, if specified
<Binary Directory>/jellyfin-web, where <Binary Directory> is the directory containing the Jellyfin executable
NOTE

This setting is only used when the server is configured to host the web client. See the hostwebclient option in the Main Configuration Options section below for additional details.

Log Directory​

This is the directory where the Jellyfin logs will be stored. It is set from the following sources in order of decreasing precedence.

Command line option --logdir, if specified
Environment variable $JELLYFIN_LOG_DIR, if specified
<Data Directory>/log
Main Configuration​

The main server configuration is built upon the ASP .NET configuration framework, which provides a tiered approach to loading configuration. The base directory to locate the configuration files is set using the configuration directory setting. The configuration sources are as follows, with later sources having higher priority and overwriting the values in earlier sources.

Hard-coded default values: These defaults are specified in the Jellyfin source code and cannot be changed.

Default logging configuration file (logging.default.json): This file should not be modified manually by users. It is reserved by the server to be overwritten with new settings on each new release.

System-specific logging configuration file (logging.json): This is the file you should change if you want to have a custom logging setup. Jellyfin uses the Serilog logging framework, and you can read about the configuration options available in their documentation.

NOTE

This file can be changed at runtime, which will automatically reload the configuration and apply the changes immediately.

Environment variables: The documentation provided by Microsoft explains how to set these configuration options via environment variables. Jellyfin uses its own custom JELLYFIN_ prefix for these variables. For example, to set a value for the HttpListenerHost:DefaultRedirectPath setting, you would set a value for the JELLYFIN_HttpListenerHost__DefaultRedirectPath environment variable.

Command line options: Certain command line options are loaded into the configuration system and have the highest priority. The following command line options are mapped to associated configuration options.

--nowebclient sets the hostwebclient configuration setting to false
Main Configuration Options​

This section lists all the configuration options available and explains their function.

Key	Default Value	Description
hostwebclient	True	Set to True if the server should host the web client.
FFmpeg:probesize	"1G"	Value to set for the FFmpeg probesize format option. See the FFmpg documentation for more details.
FFmpeg:analyzeduration	"200M"	The value to set for the FFmpeg analyzeduration format option. See the FFmpg documentation for more details.
PublishedServerUrl	Server Url based on primary IP address	The Server URL to publish in udp Auto Discovery response.
Fonts​

Jellyfin uses fonts to render text in many places.

Server Side System Fonts​

The system fonts installed on the server are used for burning in subtitles and rendering cover images. How to install them depends on the operating system or if a container is being used.

Client Side System Fonts​

The system fonts installed on the client devices are used to display the text in the client interface as well as render subtitles for some clients. How to install them depends on the operating system.

Fallback Fonts​

The Fallback Fonts installed on the server are loaded up by the web client to render ASS subtitles. They will be used if no other existing fonts (such as MKV attachments or client-side fonts) can be used to render certain glyphs, such as CJK characters, instead of displaying an empty "tofu" block.

This setting can be set to a folder on the server containing fonts for this purpose. These fonts are limited to a total size of 20 MB, since all of them will be always preloaded in the browser, regardless of whether they'll be needed or not. Lightweight formats optimized for web like woff2 are recommended. A tool to convert normal TrueType (.ttf) and OpenType (.otf) fonts to woff2 can be found in their repo.

Downloading Fonts​

There are many fonts available online. Google Fonts is a good place to download fonts for most languages.

Edit this page
Previous
Backup and Restore
Next
Hardware Acceleration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/hardware-acceleration/

Skip to main content
AdministrationHardware Acceleration
On this page
Hardware Acceleration

The Jellyfin server can offload on the fly video transcoding by utilizing an integrated or discrete graphics card (GPU) suitable to accelerate this workloads very efficiently without straining your CPU.

Supported Acceleration Methods​

The Jellyfin server uses a modified version of FFmpeg as its transcoder, namely jellyfin-ffmpeg. It enables the Jellyfin server to access the fixed-function video codecs, video processors and GPGPU computing interfaces provided by vendor of the installed GPU and the operating system.

The supported and validated video hardware acceleration (HWA) methods are:

Intel Quick Sync Video (QSV)

NVIDIA NVDEC/NVENC (NVENC)

AMD Advanced Media Framework (AMF)

Intel/AMD Video Acceleration API (VA-API, Linux only)

Apple Video Toolbox (macOS only)

Rockchip RKMPP (Linux only)

Full & Partial Acceleration​

The transcoding pipeline usually has multiple stages, which can be simplified to:

Video Decoding

Video Deinterlacing (optional)

Video Scaling & Format conversion (optional)

Video HDR/DV Tone-mapping (optional)

Video Subtitle burn-in (optional)

Video Encoding

Zero-copy in above stages

NOTE

Some of these stages cannot be GPU accelerated due to software, hardware or driver limitations.

Partial acceleration may result in higher CPU usage and lower transcoding speed.

Jellyfin supports full acceleration for:

Mainstream Intel and Nvidia GPUs on Windows and Linux
AMD Polaris and newer GPUs on Linux via VA-API and Vulkan interop
Older AMD GPUs on Windows
Rockchip VPU of RK3588/3588S
Intel and Apple Silicon on macOS 12 and above

Using jellyfin-ffmpeg with Jellyfin is highly recommended, which has a -Jellyfin suffix in the version string.

$ /usr/lib/jellyfin-ffmpeg/ffmpeg

ffmpeg version 6.0.1-Jellyfin Copyright (c) 2000-2023 the FFmpeg developers
  built with gcc 12.2.0 (crosstool-NG 1.25.0.90_cf9beb1)
...

CAUTION

Using FFmpeg binaries downloaded from somewhere else will result in partial acceleration.

Jellyfin-ffmpeg usually ships with our deb package, official Docker images and Windows installers.

The only exception is when using a portable installation or an unsupported distro, then it's required to manually download and set it in Jellyfin.

Configure & Verify Hardware Acceleration​

There are some preparations that need to be done before enabling hardware acceleration.

The specific configuration steps may vary between GPU vendors, installation methods, and operating systems.

On Linux you can check available GPU using the lspci command:

lspci -nn | grep -Ei "3d|display|vga"


Or using lshw:

lshw -C display

Intel QSV & VA-API​

Click Intel GPU.

AMD AMF & VA-API​

Click AMD GPU.

NVIDIA NVENC​

Click NVIDIA GPU.

Apple VideoToolbox​

Click Apple Mac.

Rockchip RKMPP​

Click Rockchip VPU.

Enable Hardware Acceleration​

Hardware acceleration options can be found in the Admin Dashboard under the Transcoding section of the Playback tab.

Select a valid hardware acceleration method from the drop-down menu and a device if applicable. Supported codecs need to be indicated by checking the boxes in Enable hardware decoding for and Hardware encoding options.

The hardware acceleration is available immediately for media playback. No server restart is required.

Remote Hardware Acceleration​

If your Jellyfin server does not support hardware acceleration, but you have another machine that does, you can leverage rffmpeg to delegate the transcoding to another machine.

NOTE

Currently Linux-only and requires SSH between the machines, as well as shared storage for media and the Jellyfin data directory.

Hardware Accelerated Tone-mapping​

Jellyfin supports hardware accelerated tone-mapping of HDR10 and HLG to SDR.

Dolby Vision (P5 & P8) to SDR tone-mapping is supported in Jellyfin 10.8 and requires jellyfin-ffmpeg 5.0.1-5 or newer.

NOTE

Intel VPP HDR10 tone-mapping is supported on Intel QSV and VA-API on Linux.

VPP is prefered if both tone-mapping options are enabled.

Rockchip RKMPP currently only support HDR10 and HLG tone-mapping.

Tips For Hardware Acceleration​

Avoid H.264 / AVC 10-bit videos

TIP

The hardware decoding of H.264 / AVC 10-bit (High 10 profile) video is not supported by any Intel, NVIDIA and AMD GPU. It is only supported by Apple Silicon and Rockchip. Jellyfin will fall back to software decoding for it when there is no hardware decoder available. Consider upgrading such video to H.265 / HEVC 10-bit (Main 10 profile).

iGPU / APU Prefer dual-channel memory

TIP

Integrated GPUs take up a portion of system memory as their video memory, which means using dual-channel memory can double the video memory bandwidth. This can be useful while computing intensive workloads such as hardware HDR/DV tone-mapping.

Use SSD or RamDisk for caching

TIP

On modern GPUs the peak throughput of video transcoding can be limited by the I/O speed of your hard drives. In this case, an SSD or RamDisk can be used for caching the transcoded temporary video segments.

Tune encoder presets to trade off quality for speed

TIP

Hardware encoder presets can greatly affect encoding speed. You can lower this preset in the Jellyfin dashboard to sacrifice encoding quality to maximize speed, or raise the preset to optimize encoding quality on an overkill GPU.

Raspberry Pi Hardware Acceleration Support Deprecation​

Jellyfin previously supported hardware acceleration on Raspberry Pi via OpenMAX OMX in Jellyfin 10.8, with partial support for Raspberry Pi via V4L2 in 10.9. However, the support never reached the level of maturity seen with other acceleration methods. Many operations fell back to the already underperforming CPU, due to the lacking of full hardware acceleration. The situation worsened with the release of the latest generation of Raspberry Pi 5, which lacks hardware encoders entirely, rendering further development of hardware acceleration on this platform impractical.

As a result, we have to deprecate V4L2 support for Raspberry Pi, unfortunately. While it may continue to work for now, future updates to the Linux kernel or FFmpeg could break this support, and it's unlikely that we'll address any resulting issues. This decision may be reversed if future Raspberry Pi models reintroduce hardware encoders.

Edit this page
Previous
Configuration
Next
AMD GPU
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/storage

Skip to main content
AdministrationStorage
On this page
Storage
Storage​

Jellyfin is designed to directly read media from the filesystem. A network storage device that is using samba or NFS must be directly mounted to the OS. The Jellyfin database should also be stored locally and not on a network storage device.

NFS​

In case you encounter performance issues where files take a long time to start playing while using NFSv3, you might be running in an issue with .NET locking without NFSv3 having locking enabled.

To solve this, you have the following options:

Disable .NET locking using DOTNET_SYSTEM_IO_DISABLEFILELOCKING (introduced in .NET 6).
Disable locking for the mount using the nolock option.
Enable the lock service.
Use NFSv4 which has built-in lock support.
Docker or VMs​

For storage, a moderate size library database can grow anywhere from 10 to 100 GB. The transcoding folder needs roughly the same size as the original media if it's being transcoded at the same bitrate. A single 50GB Blu-Ray Remux by itself can take up to approximately 60GB or as little as 15GB, depending on the quality selected. If the transcoding folder is held on the same storage as the database, this must be taken into consideration.

Cloud​

A popular choice for cloud storage has been the program rclone. It is supported on most Operating Systems. To facilitate combining local and cloud filesystems, rclone can be paired with another program such as mergerfs. For cloud storage, it is recommended to disable image extraction as this requires downloading the entire file to perform this task.

MergerFS​

MergerFS isn't meant for everything, see here for more.

rclone recommended config.

To modify and examine your mergerfs mount, here's a quick guide.

Edit this page
Previous
Migrating
Next
Troubleshooting
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#full-database-migration

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#watched-status-migration

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#migrating-linux-install-to-docker

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#using-docker-cli

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#using-docker-compose-yaml

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/migrate/#migrating-from-emby-352-to-jellyfin

Skip to main content
AdministrationMigrating
On this page
Migrating

This page covers migrations of Jellyfin as well as migrations to Jellyfin.

Jellyfins internal databases cannot be copied or adjusted easily. Depending on your case there may be ways to work around this, for example by just migrating parts of the data, or because it's possible maintain the same file paths.

If that's not an option for you, there is also a script available to migrate the entire database without data loss, but it's not a turn-key solution.

Full Database Migration​

Jellyfin Migrator is a third-party script that can migrate your entire installation from Windows to Linux or Linux Docker. It can also do other migrations, like a reorganization of your media files. All statistics, settings and metadata are preserved.

Watched Status Migration​

There are third-party scripts available that will use the API to copy watched status and users from one instance to another. This can be done from Plex, Emby or another Jellyfin instance.

Emby/Jellyfin to Jellyfin migration

Plex to Jellyfin migration

Migrating Linux install to Docker​

It's possible to use the data of a local install in the official docker image by mapping files and folders to the same locations and configuring the image accordingly. It's possible to do this via the command line or by using Docker environment variables. To read more, see the Configuration page.

NOTE

You need to have exactly matching paths for your files inside the docker container! This means that if your media is stored at /media/raid/ this path needs to be accessible at /media/raid/ inside the docker container too - the configurations below do include examples.

To guarantee proper permissions, get the uid and gid of the local user Jellyfin runs as (on a default install this is the jellyfin system user). You can do this by running the following command:

   id jellyfin


You need to replace the <uid>:<gid> placeholder below with the correct values.

NOTE

To properly map the folders for your install, go to Dashboard > Paths.

Using docker cli​
docker run -d \
    --user <uid>:<gid> \
    -e JELLYFIN_CACHE_DIR=/var/cache/jellyfin \
    -e JELLYFIN_CONFIG_DIR=/etc/jellyfin \
    -e JELLYFIN_DATA_DIR=/var/lib/jellyfin \
    -e JELLYFIN_LOG_DIR=/var/log/jellyfin \
    --mount type=bind,source=/etc/jellyfin,target=/etc/jellyfin \
    --mount type=bind,source=/var/cache/jellyfin,target=/var/cache/jellyfin \
    --mount type=bind,source=/var/lib/jellyfin,target=/var/lib/jellyfin \
    --mount type=bind,source=/var/log/jellyfin,target=/var/log/jellyfin \
    --mount type=bind,source=</path/to/media>,target=</path/to/media> \
    --net=host \
    --restart=unless-stopped \
    jellyfin/jellyfin

Using docker-compose yaml​
services:
  jellyfin:
    image: jellyfin/jellyfin
    user: <uid>:<gid>
    network_mode: 'host'
    restart: 'unless-stopped'
    environment:
      - JELLYFIN_CACHE_DIR=/var/cache/jellyfin
      - JELLYFIN_CONFIG_DIR=/etc/jellyfin
      - JELLYFIN_DATA_DIR=/var/lib/jellyfin
      - JELLYFIN_LOG_DIR=/var/log/jellyfin
    volumes:
      - /etc/jellyfin:/etc/jellyfin
      - /var/cache/jellyfin:/var/cache/jellyfin
      - /var/lib/jellyfin:/var/lib/jellyfin
      - /var/log/jellyfin:/var/log/jellyfin
      - <path-to-media>:<path-to-media>

Migrating From Emby 3.5.2 to Jellyfin​
INFO

Direct database migration from Emby (of any version) to Jellyfin is NOT SUPPORTED. We have found many subtle bugs due to the inconsistent database schemas that result from trying to do this, and strongly recommend that all Jellyfin users migrating from Emby start with a fresh database and library scan.

The original procedure is provided below for reference however we cannot support it nor guarantee that a system upgraded in this way will work properly, if at all. If anyone is interested in writing a database migration script which will correct the deficiencies in the existing database and properly import them into Jellyfin, we would welcome it however!

CAUTION

While it is technically possible to migrate existing configuration of Emby version 3.5.2 or earlier, due to subtle and weird bugs reported after such attempts we do not recommend this migration. Emby versions 3.5.3 or 3.6+ cannot be migrated. Thus, we recommend creating a new Jellyfin configuration and rebuilding your library instead.

Windows users may take advantage of the install-jellyfin.ps1 script in the Jellyfin repository which includes an automatic upgrade option.

This procedure is written for Debian-based Linux distributions, but can be translated to other platforms by following the same general principles.

Upgrade to Emby version 3.5.2, so that the database schema is fully up-to-date and consistent. While this is not required, it can help reduce the possibility of obscure bugs in the database.

Stop the emby-server daemon:

sudo service emby-server stop


Move your existing Emby data directory out of the way:

sudo mv /var/lib/emby /var/lib/emby.backup


Remove or purge the emby-server package:

sudo apt purge emby-server


Install the jellyfin package using the installation instructions.

Stop the jellyfin daemon:

sudo service jellyfin stop


Copy over all the data files from the Emby backup data directory:

sudo cp -a /var/lib/emby.backup/* /var/lib/jellyfin/


Correct ownership on the new data directory:

sudo chown -R jellyfin:jellyfin /var/lib/jellyfin


Mark Startup Wizard as completed - if not marked as completed then it can be a security risk especially if remote access is enabled:

sudo sed -i '/IsStartupWizardCompleted/s/false/true/' /etc/jellyfin/system.xml


Start the jellyfin daemon:

sudo service jellyfin start

Edit this page
Previous
Hardware Selection
Next
Storage
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#__docusaurus_skipToContent_fallback

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#why-backing-up-is-important

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#taking-a-backup

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/configuration/#server-paths

Skip to main content
AdministrationConfiguration
On this page
Configuration

There are several entry points available for administrators to manage the configuration of their server. This section aims to outline all those configuration methods, explain what options are available, and what each option does.

NOTE

The configuration options here are distinct from the runtime settings available from the Administrator Dashboard in the web client. The configuration options here are generally meant to be static and set before starting the server.

Command Line Options​

Documentation for the available command line options can be obtained by adding the --help flag when running the Jellyfin executable.

Server Paths​

The file paths used by the server are determined according to the rules outlined below. In general, the XDG specification is followed by default for non-Windows systems.

Data Directory​

This is the directory that will hold all Jellyfin data and is also used as a default base directory for some other paths below. It is set from the following sources in order of decreasing precedence.

Command line option --datadir, if specified
Environment variable JELLYFIN_DATA_DIR, if specified
<%ProgramData%>\Jellyfin\Server, if launching from the Windows Tray app.
<%LocalAppData%>\jellyfin, if launching the Windows server directly.
$XDG_DATA_HOME/jellyfin, if $XDG_DATA_HOME exists
$HOME/.local/share/jellyfin
NOTE

Windows users can also specify the data directory using a Windows Registry string key called DataFolder located at Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server

An additional string key called InstallFolder in Computer\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Jellyfin\Server can also specify the install location.

Configuration Directory​

This is the directory containing the server configuration files. It is set from the following sources in order of decreasing precedence.

Command line option --configdir, if specified
Environment variable JELLYFIN_CONFIG_DIR, if specified
<Data Directory>/config, if it exists or if running on Windows
$XDG_CONFIG_HOME/jellyfin if $XDG_CONFIG_HOME exists
$HOME/.config/jellyfin
Cache Directory​

This is the directory containing the server cache. It is set from the following sources in order of decreasing precedence.

Command line option --cachedir, if specified
Environment variable $JELLYFIN_CACHE_DIR, if specified
<Data Directory>/cache, if Windows
$XDG_CACHE_HOME/jellyfin if $XDG_CACHE_HOME exists
$HOME/.cache/jellyfin
Web Directory​

This is the directory containing the built files from a web client release. It is set from the following sources in order of decreasing precedence.

Command line option --webdir, if specified
Environment variable $JELLYFIN_WEB_DIR, if specified
<Binary Directory>/jellyfin-web, where <Binary Directory> is the directory containing the Jellyfin executable
NOTE

This setting is only used when the server is configured to host the web client. See the hostwebclient option in the Main Configuration Options section below for additional details.

Log Directory​

This is the directory where the Jellyfin logs will be stored. It is set from the following sources in order of decreasing precedence.

Command line option --logdir, if specified
Environment variable $JELLYFIN_LOG_DIR, if specified
<Data Directory>/log
Main Configuration​

The main server configuration is built upon the ASP .NET configuration framework, which provides a tiered approach to loading configuration. The base directory to locate the configuration files is set using the configuration directory setting. The configuration sources are as follows, with later sources having higher priority and overwriting the values in earlier sources.

Hard-coded default values: These defaults are specified in the Jellyfin source code and cannot be changed.

Default logging configuration file (logging.default.json): This file should not be modified manually by users. It is reserved by the server to be overwritten with new settings on each new release.

System-specific logging configuration file (logging.json): This is the file you should change if you want to have a custom logging setup. Jellyfin uses the Serilog logging framework, and you can read about the configuration options available in their documentation.

NOTE

This file can be changed at runtime, which will automatically reload the configuration and apply the changes immediately.

Environment variables: The documentation provided by Microsoft explains how to set these configuration options via environment variables. Jellyfin uses its own custom JELLYFIN_ prefix for these variables. For example, to set a value for the HttpListenerHost:DefaultRedirectPath setting, you would set a value for the JELLYFIN_HttpListenerHost__DefaultRedirectPath environment variable.

Command line options: Certain command line options are loaded into the configuration system and have the highest priority. The following command line options are mapped to associated configuration options.

--nowebclient sets the hostwebclient configuration setting to false
Main Configuration Options​

This section lists all the configuration options available and explains their function.

Key	Default Value	Description
hostwebclient	True	Set to True if the server should host the web client.
FFmpeg:probesize	"1G"	Value to set for the FFmpeg probesize format option. See the FFmpg documentation for more details.
FFmpeg:analyzeduration	"200M"	The value to set for the FFmpeg analyzeduration format option. See the FFmpg documentation for more details.
PublishedServerUrl	Server Url based on primary IP address	The Server URL to publish in udp Auto Discovery response.
Fonts​

Jellyfin uses fonts to render text in many places.

Server Side System Fonts​

The system fonts installed on the server are used for burning in subtitles and rendering cover images. How to install them depends on the operating system or if a container is being used.

Client Side System Fonts​

The system fonts installed on the client devices are used to display the text in the client interface as well as render subtitles for some clients. How to install them depends on the operating system.

Fallback Fonts​

The Fallback Fonts installed on the server are loaded up by the web client to render ASS subtitles. They will be used if no other existing fonts (such as MKV attachments or client-side fonts) can be used to render certain glyphs, such as CJK characters, instead of displaying an empty "tofu" block.

This setting can be set to a folder on the server containing fonts for this purpose. These fonts are limited to a total size of 20 MB, since all of them will be always preloaded in the browser, regardless of whether they'll be needed or not. Lightweight formats optimized for web like woff2 are recommended. A tool to convert normal TrueType (.ttf) and OpenType (.otf) fonts to woff2 can be found in their repo.

Downloading Fonts​

There are many fonts available online. Google Fonts is a good place to download fonts for most languages.

Edit this page
Previous
Backup and Restore
Next
Hardware Acceleration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#restoring-a-backup

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/administration/backup-and-restore/#the-future

Skip to main content
AdministrationBackup and Restore
On this page
Backup and Restore

This guide documents how to both back up and then restore the data in your Jellyfin instance.

Why Backing Up is Important​

Backups are important in general for all digital data. There are myriad possible bugs and issues that can arise and cause data loss, especially when you upgrade major releases (for instance, from Jellyfin 10.9.x to Jellyfin 10.10.x).

In addition, Jellyfin does not have a downgrade mechanism. This is very important to understand; once your Jellyfin instance has been started with a new version, any pending migrations are immediately applied, and your Jellyfin data will no longer work with the old version. The only way to restore your active instance back to the old version is to restore a backup. Backups are thus critical if you want to test Unstable versions, or before upgradiing to the latest version. In fact, when testing Unstable, it is best to back up much more regularly, perhaps using a cron job or similar automatic mechanism, to ensure that your data can be recovered if you hit a major issue.

Backups may also come in handy if you hit a bug. For instance, if a bug in the new version causes corruption of some aspect of the Jellyfin data, restoring from a backup means you can quickly restore to good data and apply any fixes to avoid a repeat. Without a backup, you would be completely out of luck in this situation.

Finally, administrative mistakes, normal operation issues (e.g. filling up a disk), or general bit rot can cause corruption or issues that require a backup to be restored. It's always better to have one than not.

Taking a Backup​

Stop the running Jellyfin server. This is extremely important, as otherwise the database will be locked and might not be recoverable when restoring. Note that this will interrupt any playback.

Any platform: Within the Jellyfin Dashboard, click "Shutdown". This should cleanly stop the process on all platforms, but if not, try one of the following.
Docker: docker stop jellyfin
Debian/Ubuntu packages: sudo systemctl stop jellyfin or sudo service jellyfin stop
Windows Installer: Right-click the Tray app, and select "Quit"; or, in Process Manager, find the Jellyfin process and terminate it.
MacOS Installer (.dmg): In Activity Monitor, find the Jellyfin process and terminate it.
Portable Installs (regardless of platform): Stop the running jellyfin or jellyfin.exe program, however it was started.

Copy your data and configuration directories to a destination of your choice. What you name the copies is up to you; personally, I like to use dated and versioned directory names e.g. jellyfin.2024-05-01_10.8.13. Where these files are also depends on the platform; generally these follow the XDG Directory Specification for platforms that support it. For more information see the configuration documentation.

NOTE: These are default locations; if you've changed your data or config paths, use those instead.

Official Docker: Wherever your /data and /config volumes are sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
LinuxServer.io Docker: Data and config are wherever your /config volume is sourced from; this is set in your docker-compose.yml or in your -v options to docker run.
Debian/Ubuntu packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/default/jellyfin.
RPMFusion Fedora/CentOS packages: Data is in /var/lib/jellyfin and config is in /etc/jellyfin; these are defined in /etc/sysconfig/jellyfin.
Windows Tray/Installer (.exe): Data and config is in %PROGRAMDATA%\Jellyfin\Server (C:\ProgramData\Jellyfin\Server) or %LOCALAPPDATA%\Jellyfin (C:\Users\<Username>\AppData\Local\Jellyfin).
MacOS Installer (.dmg): Data is stored in one of these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.
Portable Installs:
Linux: Data is stored in ~/.local/share/jellyfin and config in ~/.local/share/jellyfin.
Windows: Data and config is in C:\Users\<Username>\AppData\Local\Jellyfin, using %LOCALAPPDATA%.
MacOS: Data is stored in these paths; back up whichever one(s) exist: ~/.config/jellyfin/, ~/.local/share/jellyfin/, ~/Library/Application Support/Jellyfin/.

As an example, on Debian, you can do this with these commands to make a copy of both directories into a single target directory:

TIMESTAMP=$(date +%Y%m%d%H%M%S)
VERSION=10.9.10
sudo mkdir -p /media/backups/jellyfin.${TIMESTAMP}_${VERSION}  # Or change the path wherever in your system makes sense to you
sudo cp -a /var/lib/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/data
sudo cp -a /etc/jellyfin /media/backups/jellyfin.${TIMESTAMP}_${VERSION}/config


Start up Jellyfin again, either after upgrading or on the current version. You now have a safe copy of your data in the path chosen in step 2.

Restoring a Backup​

This process assumes you followed the steps above to take the backup.

Stop the running Jellyfin server process.

Move your current data and configuration directories out of the way (e.g. by appending .bak to them). For example, sudo mv /var/lib/jellyfin /var/lib/jellyfin.bak and sudo mv /etc/jellyfin /etc/jellyfin.bak.

Copy - do not move or rename - your backup to the existing name. For example, sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/data /var/lib/jellyfin and sudo cp -a /media/backups/jellyfin.2024-10-27_10.9.11/config /etc/jellyfin.

If required, downgrade Jellyfin to the same version as your backup now.

Start up Jellyfin again. It should start cleanly with the old data, assuming versions are correct. If you downgraded this may happen automatically.

The Future​

Long-term, we have plans to provide an official backup and restore plugin bundled with Jellyfin, however this requires the completion of our EFCore rewrite, which is currently slated for our next major release 10.11.0. Once that becomes available, this document will be updated to reflect the process using that plugin.

Edit this page
Previous
Building from source
Next
Configuration
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#__docusaurus_skipToContent_fallback

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/devices

Skip to main content
Server GuideDevices
On this page
Devices

You can view all devices that have connected to the server from the settings. This will include both currently connected devices and any that have connected in the past. At the moment this page is really only useful to see connected devices and what users are registered to them.

Options​

The only option available at the moment is editing the display name. This can be useful for adding names that can better identify devices. The original name will stay visible in the options if you modify the value.

Remove​

If you don't want to keep old devices on the server, you can remove them from this page. Please note that if a device connects again it will show up here. Removing a device does not hide the device forever, it simply cleans out old entries.

Edit this page
Previous
Traefik v2.x
Next
Libraries
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/libraries

Skip to main content
Server GuideLibraries
On this page
Libraries

Libraries are virtual collections of media and can contain files from several different locations on the server.

You will see a page to add libraries when you first create the server, but they can also be added or removed at any time from the settings.

Log in to the Jellyfin web interface in your web browser.
On the menu that appears, click Admin > Dashboard.
Then again on the left side menu go to Server > Libraries.
Click "Add Media Library".
The server will now add your new media. There will be a progress bar at the top of the page indicating its progress.
Content​

The three most common types of content are movies, shows, and music. These will have the best support in client apps. You can also add other types of media such as books or photos. If you have several types of media in a single folder you can also label it as mixed, which will be a generic folder view that displays all files in the library.

NOTE

Use of the mixed library type is currently discouraged due to unreliable metadata results. We encourage the use of the dedicated library types.

Paths​

You can add multiple paths that will all be shown under the same library. The path selection dialog will allow you to select folders visually, but if you can't find the exact location you can also just enter the path manually.

Edit this page
Previous
Devices
Next
Live TV
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/live-tv/

Skip to main content
Server GuideLive TV
On this page
Live TV

Jellyfin allows you to watch and record live television using supported hardware. The first step is setting up a tuner to send data to Jellyfin, and then configure a source for the program guide data.

Click here for the general setup guide.

Tuner​

Jellyfin has support for the following tuners:

HDHomeRun
M3U

HDHomeRun is a special case because they will usually get detected automatically by the server. Otherwise you can manually add tuners by navigating to Live TV in the settings and adding one there.

NOTE

Docker users using HDHomeRun devices should set networking to host mode as Jellyfin needs to connect to a changing UDP port.

M3U allows you to add IPTV channel playlists which you can view and record.

Additional tuner types are available via plugins.

Guide​

Guide data will need to be mapped to their corresponding channels after a guide data provider is configured. The guide data formats below are included with the server:

Schedules Direct
XMLTV

Schedules Direct is a paid service providing electronic program guide data to the United States and Canada.

XMLTV is "... an XML based file format for describing TV listings. IPTV providers use XMLTV as the base reference template in their systems and extend it internally according to their business needs."

Status​

You can view the status of each tuner connected to the server in the settings. There are also buttons to manually refresh the tuners if they experience problems.

The guide data can be refreshed manually if you run into problems. This isn't normally required since the data is refreshed periodically.

Edit this page
Previous
Libraries
Next
Live TV Post Processing
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/metadata/

Skip to main content
Server GuideMetadata
Metadata

Jellyfin can get metadata for your media through multiple sources. By default, Jellyfin ships with the following providers:

The Movie Database (TMDb)
The Open Movie Database API (OMDb API)1
Local .nfo files

There are more official providers available in our Plugin Catalog, like TheTVDB, fanart.tv or AniDB. If you still can't find the provider you are looking for, you could even develop your own with our Plugin API.

NOTICE FOR USERS IN MAINLAND CHINA 中国大陆地区用户请注意

Because of external factors, certain metadata providers may not be accessable in mainland China.
由于外部因素，部分元数据提供者在中国大陆地区可能无法访问。

Below is a list of known inaccessable providers:
下方为已知无法访问的提供者：

The Movie Database (TMDb)
TheTVDB
Footnotes​

OMDb API only provides English metadata. ↩

Edit this page
Previous
Shows
Next
Media segments
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/notifications

Skip to main content
Server GuideNotifications
On this page
Notifications

You can use notifications to get alerts when certain events happen on your server. Some common notifications include plugin installations and different user events.

Services​

Notifications can be sent using different services depending on what kind of integration you want. Jellyfin will show notifications on the dashboard by default, but you can install alternative services on the Plugins page. Most services will require additional configuration but can be extremely useful for those who want instant updates for activity on their server.

Configuration​

You can properly configure this feature on the Notifications page in the settings. All notification types will be shown in a list as well as their current status. They can be enabled individually and can be set to only monitor specific users. Any installed notification services will show up in a list in this section.

Edit this page
Previous
Local .nfo metadata
Next
Plugins
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/open-subtitles

Skip to main content
Server GuidePluginsOpen Subtitles
Open Subtitles

This plugin will allow your server to download subtitles from OpenSubtitles.com for any video file on your server. The plugin can be installed from the catalog page and once enabled you will need to enter your OpenSubtitles.com account info in the plugin configuration page.

Edit this page
Previous
Plugins
Next
TVHeadend
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/tvheadend

Skip to main content
Server GuidePluginsTVHeadend
On this page
TVHeadend

The objective of the guide is to configure the Jellyfin TVHeadend plugin to backend a TVHeadend server.

Requirements​
TVHeadend server
Jellyfin server
TVHeadend plugin installed in Jellyfin
Configuration​
Create a user for Jellyfin in TVHeadend: it is convenient to create a specific user for Jellyfin.
Go to Configuration > Users > Access Entries > Add
Give the user parameters
Enabled: ✔
Username: Username (for example: Jellyfin)
Change parameters: Rights,Channel number range,Channel tags,DVR configurations,Streaming profiles,Connection limits
Web interface: ✔
Streaming: Basic,Advanced,HTSP
Video recoder: Basic,HTSP,View all
(Optional) Comment: Comment for the user (for example: User used by Jellyfin)
(Optional) Allowed networks: Network address with network mask to allow (for example 127.0.0.1/32)
Press Save
Go to Configuration > Users > Passwords > Add
Give the user parameters
Enabled: ✔
Username The user created previously (for example: Jellyfin)
Password: The password for the user created previously (for example: Jellyfin_password)
Press Save
NOTE

The parameters Change parameters, Streaming and Video recoder must be marked as shown. Otherwise, Jellyfin can connect to TVHeadend but problems may arise when reproducing the content.

Adjust the Jellyfin TVHeadend plugin to establish the connection.
Go to Dashboard > Plugins > TVHeadend > Settings
Provide creator access data previously:
TVHeadend Hostname or IP Address: IP address of the TVHeadend server (for example: 127.0.0.1)
Username: The user created previously (for example: Jellyfin)
Password: The password created previously (for example: Jellyfin_password)
NOTE

By default the the TVHeadend Hostname or IP Address section is configured by default with the hostname localhost, it is preferable to use the IP address 127.0.0.1 instead of localhost. Reference

Configure the channels for viewing in Jellyfin: even if Jellyfin manages to connect to TVHeadend, the guide will not be synchronized because there has to be a number assigned to the channels in TVHeadend. Reference

Manual mode
Go to Configuration > Channel/EPG > Channels
Select the channel to be changed and press Edit
In the option Number we enter the number that we are going to assign to the channel (for example: 1), this number must be nonzero
Press save
Automatic mode
Go to Configuration > DVB Inputs > Networks
Select the network you want and press Edit
In the option Channel numbers from we enter the number so we want the numbering of the channels to start (for example: 1), this number must be nonzero
Press save

Update the data from the TVHeadend guide to Jellyfin

Go to Dashboard > Live TV
Refresh guide data
NOTE

If the guide is not updated, restart the Jellyfin server.

Once the update of the guide is finished, the Live TV will already be able to see the guide related to the synchronized channels and will be able to visualize the content.

Edit this page
Previous
Open Subtitles
Next
Quick Connect
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/quick-connect

Skip to main content
Server GuideQuick Connect
On this page
Quick Connect

Starting with Jellyfin server version 10.7.0 and supported clients, you can use Quick Connect to sign into your account without the need of a password. You need to previously be logged into a supported client, like the default Jellyfin Web Client.

Enabling Quick Connect​

To use Quick Connect, the Jellyfin server admin has to enable this feature in the server dashboard.

Settings > Dashboard > General > Enable Quick Connect on this server

Using Quick Connect​

To sign in to a supported client, you have to enter the Quick Connect code in your user settings.

Settings > Quick Connect

If the code is validated successfully, your new device will be signed in without entering your Jellyfin username or password on the new device.

The client will generate a 6 digit code, which you have to enter in the already signed in client in your user settings.

Edit this page
Previous
TVHeadend
Next
Settings
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/settings

Skip to main content
Server GuideSettings
On this page
Settings

The general settings include options that don't require their own link in the sidebar. Most of these are items that will change the interface or user experience.

Server Name​

This name will be displayed to users when they select a server, and clients might use it in other locations as well. The default value will be the hostname of the computer.

Login Disclaimer​

This message will be shown to users when they login on your server.

Custom Style​

You can add custom CSS rules for minor changes to the web interface that don't require their own theme.

Edit this page
Previous
Quick Connect
Next
Tasks
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/tasks

Skip to main content
Server GuideTasks
On this page
Tasks

Tasks are operations that are scheduled to run periodically. They can also be triggered manually by clicking the run button on the right.

Default Jellyfin Tasks​

Below is a list of tasks that Jellyfin runs peoridically by default:

Libraries​
Download Missing Subtitles
Refresh Users
Extract Chapter Images
Scan Library
Extract Key Frames
Application​
Update Plugins
Maintenance​
Optimize Database
Clear Log Folder
Clear Cache Folder
Clear Activity Logs
Clear Transcodes Folder
Clean up collections and playlists
Plugin Tasks​

Plugins can add their own tasks if they include operations that need to be run at specified intervals. These will also show up in the settings for you to configure.

Edit this page
Previous
Settings
Next
Transcoding
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/transcoding/

Skip to main content
Server GuideTranscoding
On this page
Transcoding

These settings will relate to backend options that modify how the server transcodes media. Some improve or change the media quality while others reduce the resources required to transcode the media from its original format.

Hardware Acceleration​

If your hardware supports this you can enable hardware acceleration for much faster transcoding. Jellyfin supports hardware accelerated transcoding on all modern GPUs from Intel, AMD, Nvidia, Apple and Rockchip if the required hardware is available.

Thread Count​

This option will manually set the number of threads to use when transcoding. If you're not using the server for anything else, it's best to leave this option alone.

Types of Transcoding​

There are four types of playback; three of which involve transcoding. The type being used will be listed in the dashboard when playing a file. They are ordered below from lowest to highest load on the server:

Direct Play: Delivers the file without transcoding. There is no modification to the file and almost no additional load on the server.
Remux: Changes the container but leaves both audio and video streams untouched.
Direct Stream: Transcodes audio but leaves original video untouched.
Transcode: Transcodes the video stream.
HDR to SDR Tone-mapping​

When the source video is in HDR, it will need to be tone-mapped to SDR when transcoding, as Jellyfin currently doesn't support HDR to HDR tone-mapping, or passing through HDR metadata. While this can be done in software, it is very slow, and you may encounter situations where no modern consumer CPUs can transcode in real time. Therefore, a GPU is always recommended, where even a basic Intel iGPU can handle as much load as a Ryzen 5800X for this usecase.

Edit this page
Previous
Tasks
Next
Stereo Downmix
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/users/

Skip to main content
Server GuideUsers
On this page
Users

Many features are configurable for each user individually to allow administrators more granular control over a Jellyfin server. Keep in mind that Jellyfin users are entirely local and no information or metadata will ever be sent to remote servers during the login process.

Basic Overview​
Administrators​

To add another administrator, you can simply check the box labeled allow this user to manage the server at the top of the user options. This will give someone full access to all pages and features on the site so be careful who gets access.

Playback​

You can allow transcoding for audio and video individually to prevent certain people from using too much system resources. There is also an option to enable video playback that does not require encoding. This is much less CPU intensive and will often fix playback issues on devices that do not support newer video formats.

Deletion​

Users can delete media from the library with this option, which will also remove them from the filesystem. If your server doesn't have write permission to the media files, they will be removed temporarily but picked up on the next library scan. You can also enable this option for individual libraries.

Locking/Unlocking​

You can set a maximum of failed login attempts before a user gets locked out. This means that if a user tries to login but fails an x amount of times. The user will no longer be able to login until the server administrator manually unlocks the account.

Other​

If you disable a user, they will be kicked off the server immediately and unable to login until the option is deselected. This is useful if you do not want to expose unused credentials on a public server but might want to keep the account around for a while. You can also hide a user from the login screen and require manual entry of both the username and password. This will prevent users from knowing what accounts have been created on the server when they login.

Advanced Overview​

For more in-depth information on all user settings, see Managing Users.

Edit this page
Previous
Stereo Downmix
Next
Managing Users
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#installing

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#catalog

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#manual

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#list

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#official-plugins

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#metadata-plugins

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#anilist

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#anidb

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#anisearch

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#bookshelf

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#kitsu

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#fanart

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#kodi-sync-queue

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#local-intros

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#ldap

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#nextpvr

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://jellyfin.org/docs/general/server/plugins/#open-subtitles

Skip to main content
Server GuidePlugins
On this page
Plugins

Jellyfin has a collection of optional plugins that can be installed to provide additional features. To create a plugin, see the plugin template repository.

Installing​
Catalog​

Many plugins are available in a repository hosted on our servers, which can be easily installed using the plugin catalog in the settings. At the moment many of these are still being updated frequently so the version number may not be accurate. There are several different categories that can indicate what kind of functionality the plugins may provide.

The plugins folder is located in different locations depending on your install:

%UserProfile%\AppData\Local\jellyfin\plugins for direct installs
%ProgramData%\Jellyfin\Server\plugins for tray installs

After that start Jellyfin back up, and reinstall each plugin you want to update using the above method from the catalog. Plugin settings should be retained if you do not delete the .xml files from the <direct or tray path>\plugins\configurations folder.

Authentication: Add new authentication providers, such as LDAP.

Channels: Allow streaming remote audio or video content.

General: Plugins that serve general purposes, such as sync with Trakt.tv, or Kodi.

Live TV: Plugins that help with connecting to tuners, such as NextPVR, or TVHeadend.

Metadata: Scrape metadata from a new source or modify existing metadata.

Notifications: Allow notifications to connect to many different services, including Gotify and Slack.

Manual​

All plugins hosted on the repository can be built from source and manually added to your server as well. They just need to be placed in the plugin directory, which is something like /var/lib/jellyfin/plugins/ on most Linux distributions. Once the server is restarted any additions should automatically show up in your list of installed plugins. If you can't see the new plugin there may be a file permission issue.

List​
Official Plugins​
Metadata Plugins​

Manage your Anime in Jellyfin with several different metadata providers and options for organizing your collection.

Anilist​

  

Provides metadata support from Anilist.

Link:

Github
Anidb​

  

Provides metadata support from Anidb.

Link:

Github
Anisearch​

  

Provides metadata support from Anisearch.

Link:

Github
Bookshelf​

  

Supports several different metadata providers and options for organizing your collection.

Links:

GitHub
Kitsu​

  

Provides metadata support from Kitsu.

Github
Fanart​

  

Scrape poster images for movies, shows, and artists in your library from fanart.tv.

Links:

GitHub
Kodi Sync Queue​

  

Helps keep Jellyfin for Kodi in sync with the library without needing to run periodic full scans.

Links:

GitHub
Local Intros​

  

Use pre-roll intro videos from local storage.

Links:

GitHub
LDAP​

  

Authenticate your Jellyfin users against an LDAP database, and optionally create users who do not yet exist automatically. Allows the administrator to customize most aspects of the LDAP authentication process, including customizable search attributes, username attribute, and a search filter for administrative users (set on user creation). The user, via the "Manual Login" process, can enter any valid attribute value, which will be mapped back to the specified username attribute automatically as well.

Links:

GitHub
NextPVR​

  

Provides access to Live TV, Program Guide, and Recordings from NextPVR.

Links:

GitHub
Open Subtitles​

  

Download subtitles from the internet to use with your media files from Open Subtitles. You can configure the languages it downloads on a per-library basis.

Links:

GitHub
Subtitle Extract​

  

Plugin to automatically extract embedded subtitles in media. This avoids delayed subtitles during streaming if the client does not support direct play and requests subtitles.

Links:

GitHub
Playback Reporting​

  

Collect and show user playback statistics, such as total time watched, media watched, time of day watched, and time of week watched. Can keep information for as long as you want or can cull older information automatically. Also allows you to manually query the data collected so you can generate your own reports.

Links:

GitHub
Reports​

  

Generate reports of your media library.

Links:

GitHub
TMDb Box Sets​

  

Automatically create movie box sets based on TMDb collections. Configurable minimum number of films to be considered a boxset. Boxsets are created as collections and includes a scheduled task to ensure that new media is automatically put into boxsets.

Links:

GitHub
Trakt​

  

Record your watched media with Trakt.

Links:

GitHub
TVHeadend​

  

Manage TVHeadEnd from Jellyfin. Click here for plugin support.

Links:

GitHub
3rd-Party Plugins​
Ani-Sync​

Ani-Sync lets you synchronize/scrobble your Jellyfin Anime watch progress to popular services like MyAnimeList, AniList, Kitsu.

Links:

GitHub
Kinopoisk metadata plugin​

Fetches metadata from https://kinopoisk.ru. This site is popular in the Russian-speaking community and contains almost no English-language information. Can provide movies and series rating, description, actors and staff, trailers and so on.

Links:

GitHub
Last.FM​

Enables audio scrobbling to Last.FM as well as a metadata fetcher source.

Links:

GitHub
Merge Versions​

Automatically group every repeated movie.

Links:

GitHub
Shokofin​

A plugin to integrate your Shoko database with the Jellyfin media server.

Links:

GitHub
Skin Manager​

Download and manage the most popular skins.

Links:

GitHub
Themerr​

Plugin for Jellyfin that adds theme songs to movies and tv shows using ThemerrDB.

Links:

GitHub
YouTube Metadata​

Downloads metadata of YouTube videos with a YouTube API key.

Links:

GitHub
TubeArchivistMetadata​

A plugin to integrate your TubeArchivist library with Jellyfin, providing metadata and organizing media.

Links:

GitHub
Repositories​
Official Jellyfin Plugin Repositories​
Jellyfin
Official

Repository URL
https://repo.jellyfin.org/files/plugin/manifest.json

Jellyfin Unstable
OfficialUnstable

Repository URL
https://repo.jellyfin.org/files/plugin-unstable/manifest.json

3rd-Party Plugin Repositories​
9p4's Single-Sign-On (SSO) Repo
Third Party

Repository URL
https://raw.githubusercontent.com/9p4/jellyfin-plugin-sso/manifest-release/manifest.json
Includes
9p4's Single Sign On Plugin

Ani-Sync Repo
Third Party

Repository URL
https://raw.githubusercontent.com/vosmiic/jellyfin-ani-sync/master/manifest.json
Includes
Ani-Sync

danieladov's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
Includes
Merge Versions
Skin Manager
Theme Songs

dkanada's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/dkanada/jellyfin-plugin-intros/master/manifest.json
Includes
Intros

k-matti's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/k-matti/jellyfin-plugin-repository/master/manifest.json
Includes
SMS Notifications
NapiSub

LinFor's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/LinFor/jellyfin-plugin-kinopoisk/master/dist/manifest.json
Includes
Kinopoisk metadata plugin

LizardByte's Repo
Third Party

Repository URL
https://app.lizardbyte.dev/jellyfin-plugin-repo/manifest.json
Includes
Themerr

ShokoAnime's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/ShokoAnime/Shokofin/metadata/stable/manifest.json
Includes
Shokofin

TubeArchivist's Repo
Third Party

Repository URL
https://raw.githubusercontent.com/tubearchivist/tubearchivist-jf-plugin/master/manifest.json
Includes
TubeArchivistMetadata

Edit this page
Previous
Notifications
Next
Open Subtitles
Documentation
Feature Requests
Contribute
Status
Contact

Site content is licensed CC-BY-ND-4.0

---

# https://react-spring.dev/docs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Overview

Welcome to the react-spring docs site!

Getting Started

Learn about how to use react-spring with step by step explanations

Read more
Guides & Tutorials

Read up on step-by-step tutorials for common use cases exploring our different hooks

Coming soon!
Examples

Be inspired by exploring all our examples, why not contribute your own?

Read more
What is this?

Our old documentation was lacking in features & clarity. So, based on community feedback, we've made an endeavor to improve our documentation with a few key differences:

We want to explain more of our codebase conceptually e.g what is an animated component
All our content will be searchable so no more running around in the dark
Step-by-step tutorials on how to achieve common use-cases
How can I help?

Thank you for being interested in helping! It means a lot, if you want to provide generic feedback please do so here. Otherwise, each page has it's own feedback button you can use to give an up or down vote, followed by the option to then add written feedback.

If you're interested in adding an example to the site then why not check out the specific contributing guide.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/

Enable light mode
Enable dark mode
With naturally fluid animations you will elevate your UI & interactions. Bringing your apps to life has never been simpler.

npm i @react-spring/web

Copy npm i @react-spring/web
Get started
Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that.

Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Hear what our fans say
@ryanflorence
Remix Co-founder
Holy smokes. I don't think animation can get any easier in React now with React Spring. Wrapping Reach UI (https://reach.tech/ui) in your own brand and feel is going to be so easy.
@CompuIves
Creator of Codesandbox
Big fan of React Spring!
@Prinzhorn
Software Engineer
react-spring is insane. I haven't done a lot of animations but it's the first React library I come across that does it the correct way: not using setState to change styles but bypass React.
@JoshWComeau
Creator of CSS for JavaScript Developers
It's fantastic :) In my React Rally talk, I explicitly recommend it over React Motion, and all the demos use it (shout-out to @0xca0a). Will share a link to it once the talk vid is up.
@bpierre
Software Engineer
If you like react-motion but feel like your transitions aren‚Äôt smooth, it‚Äôs because it‚Äôs exclusively using React rendering. If you like Popmotion but feel like you are limited by what you can do, it‚Äôs because it entirely skips React rendering. react-spring does both, try it üëå
@hshoff
Engineer at Airbnb
react-spring by @0xca0a is a lovely animation library for react
@brunolemos
Software Engineer
The animation lib React Spring is so awesome! Great API (first-class support for hooks), performant (doesn't trigger a re-render) and cross-platform (web / react-native / universal). Adding animations makes the app much more fun to use.
@arzafran
Partner at Studio Freight
this would‚Äôve been impossible without the hard work from everyone at @pmndrs, zustand, r3f, react-spring, and obviously @clementroche_‚Äòs incredible talent. but it was no easy task to learn all the tricks we now know.. and thinking about all the stuff we still don‚Äôt
@winkerVSbecks
Software Engineer
So, it turns out you can mix HTML and WebGL. And with react-spring you can animate both.
@bobylito
Software Engineer
The game being game, I have a lot of animations. I started using what is proposed by tailwind but it is not good enough for 2020. I ended moving to react spring. The learning curve is steeper than what I had expect. But it's a delightful experience afterwards.
But wait, there‚Äôs more
It‚Äôs not just for web

Choose from our five targets:

web
native
three
konva
zdog

Missing a target you want? Request we add it or create it yourself with our advanced API usage.

Learn more about targets
import { animated, useSpring } from '@react-spring/web'



export const MyComponent = () => {

  const { x } = useSpring({

    from: {

      x: 0,

    },

    to: {

      x: 1,

    },

  })



  return <animated.div style={{ x }} />

}

Avoid unnecessary overhead
Run animations without
re-rendering

Use our imperative API methods to run animations without updating state. Respond to events without the react rendering overhead to achieve smooth, fluid animation.

View imperative API
Designed with you in mind
Production ready with SSR support

Forget about useRef & useEffect to attach your animations to dom nodes. animated takes care of it for you.




Fully written in Typescript for easy integration to your pre-existing codebase.




Use a target for a small bundle size or omit the target and just use the core for an even smaller package.

55.1kb
react-spring
19.2kb
@react-spring/web
15.2kb
@react-spring/core
Wow, that's a lot!
And there's even more
Animate any value ‚Äì strings, numbers, css variables...
Shorthand transformation styles
Interpolate values inline
Easily react to animation events
Usable with any component library
Get started now
import * as Dialog from '@radix-ui/react-dialog'

import { styled } from '@stitches/react'

import { animated, useSpring } from '@react-spring/web'



export const AnimatedDialog = ({ isOpen, onOpenCallback }) => {

  const { x, backgroundColor, o } = useSpring({

    x: isOpen ? '0%' : '-100%',

    backgroundColor: isOpen

      ? 'var(--color-whiteblur)'

      : 'var(--colors-white00)',

    o: isOpen ? 1 : 0,

    onRest: () => {

      if (isOpen && onOpenCallback) {

        onOpenCallback()

      }

    },

  })



  return (

    <Dialog.Root>

      <Overlay style={{ backgroundColor }} />

      <Modal
        style={{
          x,
          backgroundColor: o.to(o => 'rgba(255,255,255,' + o + ')'),
        }}
      />

    </Dialog.Root>

  )

}

import * as Dialog from '@radix-ui/react-dialog'

import { styled } from '@stitches/react'

import { animated, useSpring } from '@react-spring/web'



export const AnimatedDialog = ({ isOpen, onOpenCallback }) => {

  const { x, backgroundColor, o } = useSpring({

    x: isOpen ? '0%' : '-100%',

    backgroundColor: isOpen

      ? 'var(--color-whiteblur)'

      : 'var(--colors-white00)',

    o: isOpen ? 1 : 0,

    onRest: () => {

      if (isOpen && onOpenCallback) {

        onOpenCallback()

      }

    },

  })



  return (

    <Dialog.Root>

      <Overlay style={{ backgroundColor }} />

      <Modal
        style={{
          x,
          backgroundColor: o.to(o => 'rgba(255,255,255,' + o + ')'),
        }}
      />

    </Dialog.Root>

  )

}

import * as Dialog from '@radix-ui/react-dialog'

import { styled } from '@stitches/react'

import { animated, useSpring } from '@react-spring/web'



export const AnimatedDialog = ({ isOpen, onOpenCallback }) => {

  const { x, backgroundColor, o } = useSpring({

    x: isOpen ? '0%' : '-100%',

    backgroundColor: isOpen

      ? 'var(--color-whiteblur)'

      : 'var(--colors-white00)',

    o: isOpen ? 1 : 0,

    onRest: () => {

      if (isOpen && onOpenCallback) {

        onOpenCallback()

      }

    },

  })



  return (

    <Dialog.Root>

      <Overlay style={{ backgroundColor }} />

      <Modal
        style={{
          x,
          backgroundColor: o.to(o => 'rgba(255,255,255,' + o + ')'),
        }}
      />

    </Dialog.Root>

  )

}

import * as Dialog from '@radix-ui/react-dialog'

import { styled } from '@stitches/react'

import { animated, useSpring } from '@react-spring/web'



export const AnimatedDialog = ({ isOpen, onOpenCallback }) => {

  const { x, backgroundColor, o } = useSpring({

    x: isOpen ? '0%' : '-100%',

    backgroundColor: isOpen

      ? 'var(--color-whiteblur)'

      : 'var(--colors-white00)',

    o: isOpen ? 1 : 0,

    onRest: () => {

      if (isOpen && onOpenCallback) {

        onOpenCallback()

      }

    },

  })



  return (

    <Dialog.Root>

      <Overlay style={{ backgroundColor }} />

      <Modal
        style={{
          x,
          backgroundColor: o.to(o => 'rgba(255,255,255,' + o + ')'),
        }}
      />

    </Dialog.Root>

  )

}

import * as Dialog from '@radix-ui/react-dialog'

import { styled } from '@stitches/react'

import { animated, useSpring } from '@react-spring/web'



export const AnimatedDialog = ({ isOpen, onOpenCallback }) => {

  const { x, backgroundColor, o } = useSpring({

    x: isOpen ? '0%' : '-100%',

    backgroundColor: isOpen

      ? 'var(--color-whiteblur)'

      : 'var(--colors-white00)',

    o: isOpen ? 1 : 0,

    onRest: () => {

      if (isOpen && onOpenCallback) {

        onOpenCallback()

      }

    },

  })



  return (

    <Dialog.Root>

      <Overlay style={{ backgroundColor }} />

      <Modal
        style={{
          x,
          backgroundColor: o.to(o => 'rgba(255,255,255,' + o + ')'),
        }}
      />

    </Dialog.Root>

  )

}

Join our community
Share thoughts and join in with active discussions
Discord

Ask questions, share tips & tricks

Github

Report issues, submit ideas and contribute

Twitter

Keep up to date with all things Poimandres

Check out the ecosystem
See more fantastic tools from Poimandres
‚ö°Ô∏è
react-three-fiber

A React renderer for Three.js

ü§ô
@use-gesture

Bread n butter utility for component-tied mouse/touch gestures in React and Vanilla Javascript.

üåã
leva

React-first components GUI

üêª
zustand

Bear necessities for state management in React

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/examples

Enable light mode
Enable dark mode
Examples

Got an example you want to see here & share with the community? Check out this guide.

Alternatively, check out examples by
Tags
or
Components
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Springy Boxes
Colorful boxes changing position with spring physics
physics
webgl
react-three-fiber
threejs
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure
WebGL Switch
Animating both the dom as well as the canvas with a single spring.
gltf
webgl
physics
threejs
react-three-fiber
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/imperative-api

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Comparison
Methods
Upgrading from v8
Imperative API

The imperative API enables you to update your animations without requiring a react-render to occur. This is useful for animations that are not tied to a component's lifecycle, such as animations that are triggered by user input.

In essence, it is simply a SpringRef with the hook's Controller attached to it. You can additionally add more Controllers to the SpringRef to create a multi-controller animation, similar to that of the useChain hook.

Comparison

What we can see from the below comparisons, is that using the api object either returned from your useSpring hook, or generated via useSpringRef and passed to the hook, means your components do not re-render when the animation runs.

Show Code
import { useState } from 'react'

import { useSpring, useSpringRef, animated } from '@react-spring/web'



const ApiComponent = () => {

  const api = useSpringRef()

  const springs = useSpring({

    ref: api,

    from: { x: 0 },

  })



  const handleClick = () => {

    api.start({

      to: {

        x: springs.x.get() === 100 ? 0 : 100,

      },

    })

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



const StateComponent = () => {

  const [forward, setForward] = useState(false)



  const springs = useSpring({

    x: forward ? 100 : 0,

  })



  const handleClick = () => {

    setForward(s => !s)

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



export default function MyComponent() {

  return (

    <div className="flex-container--column">

      <ApiComponent />

      <StateComponent />

    </div>

  )

}


This way of working with react-spring lets you handle updates quicker and more effectively such as the position of the user's mouse. It is the recommended approach for working with this library.

Warning

When using a SpringRef or api return from a hook, any updates to the hook's configuration object are treated as updates and therefore will not trigger the animation to run. You must call .start() to trigger the animation, thus flushing the update queue.

Methods

The entire list of methods & properties are visible here. It's API signature is similar to both the Controller and SpringValue class methods. This is done to create a single unified language across the library.

The most important methods you'll most likely use are start and set. However, if you are opting to use the Controller class manually as opposed to using our hooks/components, then you would have to manually handle the lifecycle of adding/removing Controllers.

Upgrading from v8

If you're upgrading from v8 of react-spring, then welcome! The imperative API is a new feature that has been added to v9. You're probably more used to an api signature like this:

const [styles, set, stop] = useSpring(() => ({ x: 0 }))



set({

  x: 1,

})


This was okay for at the time, but as Controllers have become more powerful, it became clear that we needed a way a more scalable way to add methods to the signature without extending the array too far.

The new api signature is like this:

const [styles, api] = useSpring(() => ({ x: 0 }))



api.start({

  x: 1,

})

Note

We've used start in the above example demonstrating migration, this is because set acts like:

api.start({

  x: 1,

  immediate: true,

})

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Component APIs
Hooks vs Components

As with all our APIs we have a component and hook version. We personally recommend using the hook version as it is more inline with react's vision of the future of react. However, we understand there are codebases out there that still use class components and we want to support those too.

The typical format for importing the component version is to remove the use part of the name, e.g.

import { useSpring } from '@react-spring/web'



// becomes



import { Spring } from '@react-spring/web'


All the props remain the same. It's just a light wrapper and uses a render props method:

import { Spring } from '@react-spring/web'



const MyComponent = () => {

  return (

    <Spring from={{ opacity: 0 }} to={{ opacity: 1 }}>

      {style => <animated.div style={style} />}

    </Spring>

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer

[2/3] Downloaded @react-spring/web (8/9)

Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-resize

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
useResize

A small abstraction around the useSpring hook. It returns a SpringValues object with the width and height of the element it's attached to & doesn't necessarily have to be attached to the window, by passing a container you can observe that element's size instead.

Usage
import { useResize, animated } from '@react-spring/web'



function MyComponent() {

  const { width, height } = useResize()



  return <animated.div style={{ width, height }}>Hello World</animated.div>

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement | null | undefined>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useResize(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs#overview

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Overview

Welcome to the react-spring docs site!

Getting Started

Learn about how to use react-spring with step by step explanations

Read more
Guides & Tutorials

Read up on step-by-step tutorials for common use cases exploring our different hooks

Coming soon!
Examples

Be inspired by exploring all our examples, why not contribute your own?

Read more
What is this?

Our old documentation was lacking in features & clarity. So, based on community feedback, we've made an endeavor to improve our documentation with a few key differences:

We want to explain more of our codebase conceptually e.g what is an animated component
All our content will be searchable so no more running around in the dark
Step-by-step tutorials on how to achieve common use-cases
How can I help?

Thank you for being interested in helping! It means a lot, if you want to provide generic feedback please do so here. Otherwise, each page has it's own feedback button you can use to give an up or down vote, followed by the option to then add written feedback.

If you're interested in adding an example to the site then why not check out the specific contributing guide.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs#what-is-this

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Overview

Welcome to the react-spring docs site!

Getting Started

Learn about how to use react-spring with step by step explanations

Read more
Guides & Tutorials

Read up on step-by-step tutorials for common use cases exploring our different hooks

Coming soon!
Examples

Be inspired by exploring all our examples, why not contribute your own?

Read more
What is this?

Our old documentation was lacking in features & clarity. So, based on community feedback, we've made an endeavor to improve our documentation with a few key differences:

We want to explain more of our codebase conceptually e.g what is an animated component
All our content will be searchable so no more running around in the dark
Step-by-step tutorials on how to achieve common use-cases
How can I help?

Thank you for being interested in helping! It means a lot, if you want to provide generic feedback please do so here. Otherwise, each page has it's own feedback button you can use to give an up or down vote, followed by the option to then add written feedback.

If you're interested in adding an example to the site then why not check out the specific contributing guide.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs#how-can-i-help

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Overview

Welcome to the react-spring docs site!

Getting Started

Learn about how to use react-spring with step by step explanations

Read more
Guides & Tutorials

Read up on step-by-step tutorials for common use cases exploring our different hooks

Coming soon!
Examples

Be inspired by exploring all our examples, why not contribute your own?

Read more
What is this?

Our old documentation was lacking in features & clarity. So, based on community feedback, we've made an endeavor to improve our documentation with a few key differences:

We want to explain more of our codebase conceptually e.g what is an animated component
All our content will be searchable so no more running around in the dark
Step-by-step tutorials on how to achieve common use-cases
How can I help?

Thank you for being interested in helping! It means a lot, if you want to provide generic feedback please do so here. Otherwise, each page has it's own feedback button you can use to give an up or down vote, followed by the option to then add written feedback.

If you're interested in adding an example to the site then why not check out the specific contributing guide.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#install

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#the-animated-element

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#the-hook

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#your-first-animation

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#reacting-to-events

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#next-steps

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/getting-started#getting-started

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Install
The Animated Element
The Hook
Your First Animation
Reacting to events
Next Steps
Getting started

React Spring is a library for building interactive, data-driven, and animated UI components. It can animate HTML, SVG, Native Elements, Three.js, and more.

By the end of this quick guide, you'll have installed React Spring and created your first web-based animation! This animation will see a normal div move across the screen.

Install

React Spring can be installed with any package manager. Here's how to install it with Yarn:

Copy yarn add @react-spring/web
yarn add @react-spring/web

The Animated Element

The actual component that handles animation is our animated component. This is just a higher-order component (HOC) if you're familiar with that pattern. If you're not see this explanation from the react.js docs:

a higher-order component is a function that takes a component and returns a new component.

So really, it's just a fancy wrapper. To use it, we need to import it:

Copy import { animated } from '@react-spring/web'
import { animated } from '@react-spring/web'


We use our animated component like any other JSX element and to ensure we can see it, we'll add some styling:

import { animated } from '@react-spring/web'



export default function MyComponent() {

  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


Now we're ready to add our hook & animate the component!

The Hook

Meet your first hook, our signature hook really ‚Äì useSpring, first we need to import it:

Copy import { useSpring, animated } from '@react-spring/web'
import { useSpring, animated } from '@react-spring/web'


To use useSpring, we treat it like any other hook:

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
      }}
    />

  )

}


We use the keywords from and to to define the start and end values of our animation. So in this instance, we're starting with an x value of 0 and ending with a value of 100.

Your First Animation

useSpring doesn't actually animate anything though. It just returns SpringValues that we pass to our animated component. So that when the springs are applied and the component is mounted it will move to the right. These springs are passed to the animated component like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { x: 0 },

    to: { x: 100 },

  })



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


And there we have it! Your first animated component.

Reacting to events

Very rarely do you find yourself only needing an animation to occur only on mount, we normally want animations to occur on a user interaction. Whether that's mouseenter, click, keydown or any event that could occur. So how do we do this very common use-case?

useSpring can take two types of first argument, a config object and a function. We're going to explore the latter in more detail, we'll start by changing the notation of our hook.

import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  return (

    <animated.div
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


When we provide a function to useSpring we get an array returned, with the first argument as our springs which we're already used to (as this is returned when you provide only a config object) and the second argument is the api that controls these springs.

We'll start with a very basic user interaction, the onClick event by creating a handler and in that handler we'll use the api.start method. The start method starts our animation with the configuration we provide to it, like so:

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    from: { x: 0 },

  }))



  const handleClick = () => {

    api.start({

      from: {

        x: 0,

      },

      to: {

        x: 100,

      },

    })

  }



  return (

    <animated.div
      onClick={handleClick}
      style={{
        width: 80,
        height: 80,
        background: '#ff6d6d',
        borderRadius: 8,
        ...springs,
      }}
    />

  )

}


The api value has many different methods that we can use to control our animation. We can stop our animations, we can set them (to change the value without animation) and much more.

Next Steps

Whilst this was a brief introduction to react-spring, through this tutorial you've learnt about these three key areas:

the animated component and how to use it with HTML elements
the useSpring hook with either a configuration object or with a function
how to use the api object to control your animation and react to events

From here, you could learn how to use our other hooks or more about the configuration objects we pass to the animation hooks.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#what-are-they

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#animating-elements

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#animating-components

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#example-using-stitches--radixui

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#deep-dive

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#animated-elements

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#example-using-stitches--radix-ui

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#how-does-it-work

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#how-does-it-update-the-native-element-without-causing-a-react-render

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#Controller

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/animated-elements#how-can-i-make-my-own-animated-components

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What are they?
Animating elements
Animating components
Example: using stitches & radix-ui
Deep dive
Animated Elements
What are they?

The basis of react-spring depends on two things, SpringValues & animated components. Let's explore the latter. An animated component receives SpringValues through the style prop and updates the element without causing a React render. It works because it is a Higher-Order component (HOC) assigned to a dictionary of elements depending on the target you've selected thus being able to pass the props you desire for your application but also containing the logic to interpolate the SpringValues from the hook you've used.

Animating elements

The animated component can be imported from any of our targets. However, an animated component is specific to the target because it uses the native elements of said target. These native elements are elements that are understood by the react-reconciler of choice: e.g. @react-three/fiber is a reconciler for three.js elements. Therefore, any element that the reconciler understands can be animated.

import { animated } from '@react-spring/web'



// ‚úÖ This will work because `div` is a web element

<animated.div />



// ‚ùå This will not work because `mesh` is not a web element.

<animated.mesh />


If you used framer-motion before, you will most likely be familiar with the dot notation of accessing a dictionary of components.

So, while being able to use animated.element is useful, in most cases you'll want to style said element. react-spring has no preference about styling techniques: common techniques like css modules or tailwind all work, because every animated element accepts the properties of the native element, e.g. className.

If you're using a CSS-in-JS library to style your components, you'll typically have access to a styled function. Just like composing components you can compose your animated element with the styled function:

import { styled } from '@stitches/react'



const MyModal = styled(animated.div, {

  width: '40vw',

  height: '20vh',

  borderRadius: '8px',

  backgroundColor: '$white80',

})

Animating components

Sometimes it's impossible to animate an element directly because it comes from another library, like radix-ui. Because animated is a HOC, we can simply wrap our components with it, assuming the component you're wrapping passes to the style prop to the native element.

// This comes from another library e.g. radix-ui

const ExternalComponent = props => {

  return <div {...props} />

}



// MyApp.js

import { ExternalComponent } from 'external-library'

import { animated, useSpring } from '@react-spring/web'



const AnimatedDialog = animated(ExternalComponent)



const App = () => {

  const styles = useSpring({

    from: {

      opacity: 0,

      y: '6%',

    },

    to: {

      opacity: 1,

      y: 0,

    },

  })



  return <AnimatedDialog style={styles} />

}


If the component you are wrapping does not pass this element then nothing will animate.

Example: using stitches & radix-ui
Show Code
import { useState } from 'react'

import { useTransition, animated } from '@react-spring/web'

import { styled } from '@stitches/react'

import * as Dialog from '@radix-ui/react-dialog'



export default function () {

  const [isOpen, setIsOpen] = useState(false)



  const handleDialogChange = (isOpen: boolean) => setIsOpen(isOpen)



  const transition = useTransition(isOpen, {

    from: {

      scale: 0,

      opacity: 0,

    },

    enter: {

      scale: 1,

      opacity: 1,

    },

    leave: {

      scale: 0,

      opacity: 0,

    },

  })



  return (

    <Dialog.Root open={isOpen} onOpenChange={handleDialogChange}>

      <Trigger>

        <TriggerShadow />

        <TriggerEdge />

        <TriggerLabel>Open Modal</TriggerLabel>

      </Trigger>

      <Dialog.Portal forceMount>

        {transition((style, isOpen) => (

          <>

            {isOpen ? (

              <OverlayBackground style={{ opacity: style.opacity }} />

            ) : null}

            {isOpen ? (

              <Content forceMount style={style}>

                <DialogHeader>

                  <CloseButton>

                    <svg
                      width="32"
                      height="32"
                      viewBox="0 0 32 32"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg">

                      <path
                        d="M15.9574 14.1689L8.59651 6.75098L6.73232 8.59598L14.1313 16.071L6.71338 23.4129L8.5964 25.2769L15.9574 17.8779L23.3943 25.2769L25.2392 23.4129L17.8213 16.071L25.2202 8.59598L23.3752 6.75098L15.9574 14.1689Z"
                        fill="currentColor"
                      />

                    </svg>

                  </CloseButton>

                </DialogHeader>

                <Title>Aha you found me!</Title>

              </Content>

            ) : null}

          </>

        ))}

      </Dialog.Portal>

    </Dialog.Root>

  )

}



const TriggerPart = styled('span', {

  position: 'absolute',

  top: 0,

  left: 0,

  width: '100%',

  height: '100%',

  borderRadius: 8,

})



const TriggerShadow = styled(TriggerPart, {

  background: 'hsl(0deg 0% 0% / 0.1)',

  transform: 'translateY(2px)',

  transition: 'transform 250ms ease-out',

})



const TriggerEdge = styled(TriggerPart, {

  background: `linear-gradient(
      to left,
      hsl(0deg 0% 69%) 0%,
      hsl(0deg 0% 85%) 8%,
      hsl(0deg 0% 85%) 92%,
      hsl(0deg 0% 69%) 100%
    )`,

})



const TriggerLabel = styled('span', {

  display: 'block',

  position: 'relative',

  borderRadius: 8,

  color: '#569AFF',

  fontSize: '14px',

  padding: '16px 24px',

  background: '#fafafa',

  transform: 'translateY(-4px)',

  width: '100%',

  userSelect: 'none',

  transition: 'transform 250ms ease-out',

})



const Trigger = styled(Dialog.Trigger, {

  border: 'none',

  fontWeight: 600,

  cursor: 'pointer',

  background: 'transparent',

  position: 'relative',

  padding: 0,

  cursor: 'pointer',

  transition: 'filter 250ms ease-out',



  '&:hover': {

    filter: 'brightness(110%)',



    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-6px)',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(4px)',

    },

  },



  '&:active': {

    [`& ${TriggerLabel}`]: {

      transform: 'translateY(-2px)',

      transition: 'transform 34ms',

    },



    [`& ${TriggerShadow}`]: {

      transform: 'translateY(1px)',

      transition: 'transform 34ms',

    },

  },

})



const OverlayBackground = styled(animated(Dialog.Overlay), {

  width: '100vw',

  height: '100vh',

  backgroundColor: 'rgba(0, 0, 0, 0.5)',

  pointerEvents: 'all',

  position: 'fixed',

  inset: 0,

})



const Content = styled(animated(Dialog.Content), {

  position: 'absolute',

  width: '50vw',

  height: '60vh',

  backgroundColor: '#fafafa',

  borderRadius: 8,

  padding: '24px 24px 32px',

})



const DialogHeader = styled('header', {

  display: 'flex',

  justifyContent: 'flex-end',

  marginBottom: 16,

})



const CloseButton = styled(Dialog.Close, {

  backgroundColor: 'transparent',

  border: 'none',

  position: 'absolute',

  top: 16,

  right: 16,

  cursor: 'pointer',

  color: '#1B1A22',

})



const Title = styled(Dialog.Title, {

  fontSize: 20,

})

Deep dive
How does it work?

Higher-order components have access to the props you're passing to the child. Therefore, the animated component can scan through the passed style prop and handle said values. How the component handles the style prop is dependent on the target you're using. Let's concentrate on the web target for the sake of explanation.

We start by extracting the whole style prop and wrapping it in an AnimatedStyle class; this class is unique to the web target and handles the shorthands for transformations and in theory could handle a multitude of interpolations if we were to add them. Once we performed the specific target alterations to the style prop we call the super of its class AnimatedObject, which then runs through the object making the values "animated".

How does it update the native element without causing a react render?

Similar to how the style prop is handled in a target-specific manner, how we apply the animated values to the native element is also specific to the target. In the instance of the web target, during the process of wrapping the element in the animated HOC we attach a ref to the element.

We are then able to directly change the DOM node imperatively. For further reading, check out Controller.

How can I make my own animated components?

Because animated components belong to the target, to create your own registry of animated components e.g. for a D3 react renderer, you would need to use the createHost function exported from the @react-spring/animated package. Its signature looks like this:

interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}



type AnimatableComponent = string | Exclude<React.ElementType<any>, string>



type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}


See targets for more information.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#what-you-know

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#controller

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#spring-value

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#frame-value

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#fluids

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#what-you-learnt

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/controllers-and-springs#controllers--springs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What you know
Controller
Spring value
Frame value
Fluids
What you learnt
Controllers & Springs
Note

This is an advanced guide into the workings of react-spring with some prerequisites of your own knowledge. You should be confident with classes & Typescript before reading this.

What you know

If you've already used the useSpring hook then you'll be familiar with the following code:

const [styles, api] = useSpring(() => ({

  x: 0,

  y: 0,

  backgroundColor: '#ff0000',

  scale: [1, 1, 1],

  config: {

    precision: 0.0001,

  },

}))


If we look only at the return value from our hook we can see it's an array with two items styles and api. We'll initially focus on what styles are. This is an object of SpringValues where the key of said object correlates to the animatable keys referenced in the config object you passed (either in the way above or as part of the from config object). The value of said key is a SpringValue.

Explained in typescript terms the signature looks like:

type SpringValues<SpringConfig extends Record<string, any>> = {

  [Key in keyof OnlyAnimatableKeys<SpringConfig>]: SpringValue

}


In the example above, OnlyAnimatableKeys would narrow SpringConfig to only include the keys x, y, backgroundColor, scale. Then because we know they're animatable, they will therefore be SpringValues note this is a simplified version of the types in the library.

The second item in the array, api is a SpringRef which is an abstraction around the methods of the Controller class. However, a SpringRef can manage multiple Controllers. For more information, see Imperative Api.

Controller

So where does the Controller come into all this? Well, every "spring" is in fact, a Controller. Therefore, when you use the hook useSpring you initialise a new Controller class and when you pass the number X to the useSprings hook, you're creating X amount of Controllers.

These Controllers manage the SpringValues you create in your config object. It's methods are very similar to that of the SpringValue class, the primary methods used such as start, stop, pause run through the array of managed SpringValues and call the exact same method:

// The set method from the Controller class

set(values) {

  for (const key in values) {

    const value = values[key]

    if (!is.und(value)) {

      this.springs[key].set(value)

    }

  }

}



// Would be used like this

controller.set({

  x: 0,

  scale: [0,0,0]

})


The signature of useSpring hook's config object is identical to the Controller class constructor first argument. You can therefore draw the conclusion that the useSpring hook handles the lifecycle of the Controller class in the react environment and adds the controllers to a provided (or generated in the hook) SpringRef, providing a very straight forward and clear interface for managing one or more Controller classes. Meaning, if you so choose, you could omit using a hook and instead use Controller class directly!

For a more detailed API description, see the advanced api reference entry for Controller.

Spring value

SpringValues are what you normally interact with, they're the props that are specifically passed to the animated component, they can be interpolated and don't necessarily need to be named after properties of the element they're being used on:

const {

  backgroundColor, // SpringValue<string>

  o, // SpringValue<number>

  trans, // SpringValue<number[]>

} = useSpring({

  backgroundColor: '#00ff00',

  o: 0,

  trans: [0, 1, 2],

})


This is because the names you give are just the keys used in the Controller and the SpringValue only cares about the type of value you're passing. Inside the SpringValue class we have the entire lifecycle of the animation, from the event handlers being called to the type of advancement being used (e.g. spring physics or duration) the SpringValue is the driving force for your animation.

In addition to controlling a "Fluid value" ‚Äì a value that changes over time (see Fluids for more information). SpringValues also apply their updates to the animated node they're passed to. You might recall if you had read the animated elements concept page that on creation of the animated component, we convert any SpringValues into AnimatedValues which seems like a one way direction, in fact we attach this AnimatedValue to the original SpringValue, which allows the spring to update the animated node (e.g. <animated.p>.) via the animated value when the advance function is called on the SpringValue via our rafz package. SpringValue is able to do this because it extends the FrameValue which is a kind of FluidValue.

// Taken from `@react-spring/core/src/SpringValue.ts

class SpringValue<T = any> extends FrameValue<T>



// Taken from `@react-spring/core/src/FrameValue.ts

abstract class FrameValue<T = any> extends FluidValue<
  T,
  FrameValue.Event<T>
>



// Taken from `@react-spring/shared/src/FluidValue.ts`

abstract class FluidValue<T = any, E extends FluidEvent<T> = any>


Similar to the Controller class because it does not rely on react internals (this is how we animate outside the react render system) you can use this class directly, however the lifecycle events that are associated with Controllers & hooks will not be applied and is something you would need to manage yourself. For a more detailed API description of SpringValue, see the advanced api reference entry for SpringValue.

Frame value

The first thing you'll notice about the FrameValue class is that is considered "abstract", this is a feature unique typescript and means that you cannot instantiate the class directly. The point of an abstract class is to provide a base class that other classes can extend from in their shape (methods / properties) but usually require some additional implementation. In the case of FrameValue we have the advance method which is abstract, the SpringValue class extends FrameValue and implements it's own advance method. You can read more about abstract classes here.

Fluids

Fluids is a small glue layer for observable events. It allows parent nodes send events to their children creating an event-driven system. Therefore, when a FluidObserver has an event observered, it can perform an action. In the case of SpringValue, the _start function is called, thus animating the SpringValue's value, which in turn animates the animated node you're passing this value too.

Fluids are used all over this library, in the case of our animated HOC, we use Fluids to schedule animated updates with our rafz package.

If you want to learn more about Fluids, I recommend looking at our source code!

What you learnt

You've probably learnt alot about how the internals of react-spring works! But more importantly, you've specifically learnt about these things:

How the useSpring hook works under the hood
What is a Controller & SpringValue
How we have an event-driven system embeded in the library!
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/imperative-api#comparison

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Comparison
Methods
Upgrading from v8
Imperative API

The imperative API enables you to update your animations without requiring a react-render to occur. This is useful for animations that are not tied to a component's lifecycle, such as animations that are triggered by user input.

In essence, it is simply a SpringRef with the hook's Controller attached to it. You can additionally add more Controllers to the SpringRef to create a multi-controller animation, similar to that of the useChain hook.

Comparison

What we can see from the below comparisons, is that using the api object either returned from your useSpring hook, or generated via useSpringRef and passed to the hook, means your components do not re-render when the animation runs.

Show Code
import { useState } from 'react'

import { useSpring, useSpringRef, animated } from '@react-spring/web'



const ApiComponent = () => {

  const api = useSpringRef()

  const springs = useSpring({

    ref: api,

    from: { x: 0 },

  })



  const handleClick = () => {

    api.start({

      to: {

        x: springs.x.get() === 100 ? 0 : 100,

      },

    })

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



const StateComponent = () => {

  const [forward, setForward] = useState(false)



  const springs = useSpring({

    x: forward ? 100 : 0,

  })



  const handleClick = () => {

    setForward(s => !s)

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



export default function MyComponent() {

  return (

    <div className="flex-container--column">

      <ApiComponent />

      <StateComponent />

    </div>

  )

}


This way of working with react-spring lets you handle updates quicker and more effectively such as the position of the user's mouse. It is the recommended approach for working with this library.

Warning

When using a SpringRef or api return from a hook, any updates to the hook's configuration object are treated as updates and therefore will not trigger the animation to run. You must call .start() to trigger the animation, thus flushing the update queue.

Methods

The entire list of methods & properties are visible here. It's API signature is similar to both the Controller and SpringValue class methods. This is done to create a single unified language across the library.

The most important methods you'll most likely use are start and set. However, if you are opting to use the Controller class manually as opposed to using our hooks/components, then you would have to manually handle the lifecycle of adding/removing Controllers.

Upgrading from v8

If you're upgrading from v8 of react-spring, then welcome! The imperative API is a new feature that has been added to v9. You're probably more used to an api signature like this:

const [styles, set, stop] = useSpring(() => ({ x: 0 }))



set({

  x: 1,

})


This was okay for at the time, but as Controllers have become more powerful, it became clear that we needed a way a more scalable way to add methods to the signature without extending the array too far.

The new api signature is like this:

const [styles, api] = useSpring(() => ({ x: 0 }))



api.start({

  x: 1,

})

Note

We've used start in the above example demonstrating migration, this is because set acts like:

api.start({

  x: 1,

  immediate: true,

})

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/imperative-api#methods

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Comparison
Methods
Upgrading from v8
Imperative API

The imperative API enables you to update your animations without requiring a react-render to occur. This is useful for animations that are not tied to a component's lifecycle, such as animations that are triggered by user input.

In essence, it is simply a SpringRef with the hook's Controller attached to it. You can additionally add more Controllers to the SpringRef to create a multi-controller animation, similar to that of the useChain hook.

Comparison

What we can see from the below comparisons, is that using the api object either returned from your useSpring hook, or generated via useSpringRef and passed to the hook, means your components do not re-render when the animation runs.

Show Code
import { useState } from 'react'

import { useSpring, useSpringRef, animated } from '@react-spring/web'



const ApiComponent = () => {

  const api = useSpringRef()

  const springs = useSpring({

    ref: api,

    from: { x: 0 },

  })



  const handleClick = () => {

    api.start({

      to: {

        x: springs.x.get() === 100 ? 0 : 100,

      },

    })

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



const StateComponent = () => {

  const [forward, setForward] = useState(false)



  const springs = useSpring({

    x: forward ? 100 : 0,

  })



  const handleClick = () => {

    setForward(s => !s)

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



export default function MyComponent() {

  return (

    <div className="flex-container--column">

      <ApiComponent />

      <StateComponent />

    </div>

  )

}


This way of working with react-spring lets you handle updates quicker and more effectively such as the position of the user's mouse. It is the recommended approach for working with this library.

Warning

When using a SpringRef or api return from a hook, any updates to the hook's configuration object are treated as updates and therefore will not trigger the animation to run. You must call .start() to trigger the animation, thus flushing the update queue.

Methods

The entire list of methods & properties are visible here. It's API signature is similar to both the Controller and SpringValue class methods. This is done to create a single unified language across the library.

The most important methods you'll most likely use are start and set. However, if you are opting to use the Controller class manually as opposed to using our hooks/components, then you would have to manually handle the lifecycle of adding/removing Controllers.

Upgrading from v8

If you're upgrading from v8 of react-spring, then welcome! The imperative API is a new feature that has been added to v9. You're probably more used to an api signature like this:

const [styles, set, stop] = useSpring(() => ({ x: 0 }))



set({

  x: 1,

})


This was okay for at the time, but as Controllers have become more powerful, it became clear that we needed a way a more scalable way to add methods to the signature without extending the array too far.

The new api signature is like this:

const [styles, api] = useSpring(() => ({ x: 0 }))



api.start({

  x: 1,

})

Note

We've used start in the above example demonstrating migration, this is because set acts like:

api.start({

  x: 1,

  immediate: true,

})

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/imperative-api#upgrading-from-v8

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Comparison
Methods
Upgrading from v8
Imperative API

The imperative API enables you to update your animations without requiring a react-render to occur. This is useful for animations that are not tied to a component's lifecycle, such as animations that are triggered by user input.

In essence, it is simply a SpringRef with the hook's Controller attached to it. You can additionally add more Controllers to the SpringRef to create a multi-controller animation, similar to that of the useChain hook.

Comparison

What we can see from the below comparisons, is that using the api object either returned from your useSpring hook, or generated via useSpringRef and passed to the hook, means your components do not re-render when the animation runs.

Show Code
import { useState } from 'react'

import { useSpring, useSpringRef, animated } from '@react-spring/web'



const ApiComponent = () => {

  const api = useSpringRef()

  const springs = useSpring({

    ref: api,

    from: { x: 0 },

  })



  const handleClick = () => {

    api.start({

      to: {

        x: springs.x.get() === 100 ? 0 : 100,

      },

    })

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



const StateComponent = () => {

  const [forward, setForward] = useState(false)



  const springs = useSpring({

    x: forward ? 100 : 0,

  })



  const handleClick = () => {

    setForward(s => !s)

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



export default function MyComponent() {

  return (

    <div className="flex-container--column">

      <ApiComponent />

      <StateComponent />

    </div>

  )

}


This way of working with react-spring lets you handle updates quicker and more effectively such as the position of the user's mouse. It is the recommended approach for working with this library.

Warning

When using a SpringRef or api return from a hook, any updates to the hook's configuration object are treated as updates and therefore will not trigger the animation to run. You must call .start() to trigger the animation, thus flushing the update queue.

Methods

The entire list of methods & properties are visible here. It's API signature is similar to both the Controller and SpringValue class methods. This is done to create a single unified language across the library.

The most important methods you'll most likely use are start and set. However, if you are opting to use the Controller class manually as opposed to using our hooks/components, then you would have to manually handle the lifecycle of adding/removing Controllers.

Upgrading from v8

If you're upgrading from v8 of react-spring, then welcome! The imperative API is a new feature that has been added to v9. You're probably more used to an api signature like this:

const [styles, set, stop] = useSpring(() => ({ x: 0 }))



set({

  x: 1,

})


This was okay for at the time, but as Controllers have become more powerful, it became clear that we needed a way a more scalable way to add methods to the signature without extending the array too far.

The new api signature is like this:

const [styles, api] = useSpring(() => ({ x: 0 }))



api.start({

  x: 1,

})

Note

We've used start in the above example demonstrating migration, this is because set acts like:

api.start({

  x: 1,

  immediate: true,

})

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/imperative-api#imperative-api

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Comparison
Methods
Upgrading from v8
Imperative API

The imperative API enables you to update your animations without requiring a react-render to occur. This is useful for animations that are not tied to a component's lifecycle, such as animations that are triggered by user input.

In essence, it is simply a SpringRef with the hook's Controller attached to it. You can additionally add more Controllers to the SpringRef to create a multi-controller animation, similar to that of the useChain hook.

Comparison

What we can see from the below comparisons, is that using the api object either returned from your useSpring hook, or generated via useSpringRef and passed to the hook, means your components do not re-render when the animation runs.

Show Code
import { useState } from 'react'

import { useSpring, useSpringRef, animated } from '@react-spring/web'



const ApiComponent = () => {

  const api = useSpringRef()

  const springs = useSpring({

    ref: api,

    from: { x: 0 },

  })



  const handleClick = () => {

    api.start({

      to: {

        x: springs.x.get() === 100 ? 0 : 100,

      },

    })

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



const StateComponent = () => {

  const [forward, setForward] = useState(false)



  const springs = useSpring({

    x: forward ? 100 : 0,

  })



  const handleClick = () => {

    setForward(s => !s)

  }



  return (

    <div className="flex-container">

      <animated.div
        onClick={handleClick}
        style={{
          width: 80,
          height: 80,
          background: '#ff6d6d',
          borderRadius: 8,
          ...springs,
        }}
      />

      <span>Render ID ‚Äì {Math.random()}</span>

    </div>

  )

}



export default function MyComponent() {

  return (

    <div className="flex-container--column">

      <ApiComponent />

      <StateComponent />

    </div>

  )

}


This way of working with react-spring lets you handle updates quicker and more effectively such as the position of the user's mouse. It is the recommended approach for working with this library.

Warning

When using a SpringRef or api return from a hook, any updates to the hook's configuration object are treated as updates and therefore will not trigger the animation to run. You must call .start() to trigger the animation, thus flushing the update queue.

Methods

The entire list of methods & properties are visible here. It's API signature is similar to both the Controller and SpringValue class methods. This is done to create a single unified language across the library.

The most important methods you'll most likely use are start and set. However, if you are opting to use the Controller class manually as opposed to using our hooks/components, then you would have to manually handle the lifecycle of adding/removing Controllers.

Upgrading from v8

If you're upgrading from v8 of react-spring, then welcome! The imperative API is a new feature that has been added to v9. You're probably more used to an api signature like this:

const [styles, set, stop] = useSpring(() => ({ x: 0 }))



set({

  x: 1,

})


This was okay for at the time, but as Controllers have become more powerful, it became clear that we needed a way a more scalable way to add methods to the signature without extending the array too far.

The new api signature is like this:

const [styles, api] = useSpring(() => ({ x: 0 }))



api.start({

  x: 1,

})

Note

We've used start in the above example demonstrating migration, this is because set acts like:

api.start({

  x: 1,

  immediate: true,

})

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#start

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#set

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets#what-is-a-target

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets#adding-a-target

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets#targets

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets#animatablecomponent

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/concepts/targets#hostconfig

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is a target?
Adding a target
Targets
What is a target?

When a target is discussed it is sometimes in reference to the platform, e.g. you create a client side react application chances are it's targeted at the browser. However, if you write a server-side application then you're targeting node. Whilst react-spring does support the targets web and native and can be server-side rendered. This is not the type of target we're referring to.

A target in react-spring is a react reconciler a.k.a react renderer. That is, a custom renderer that can process different JSX components, it's duty is to create / update and remove these elements from the browser. react-dom is a prime example of a reconciler, it handles DOM elements exclusively and understands how to apply attributes to those DOM nodes via react props.

Therefore, in react-spring we have the following targets that correspond to their respective reconcilers:

web - react-dom
native - react-native
three - react-three-fiber
konva - react-konva
zdog - react-zdog

To download a target you can use the @react-spring/[target] format:

yarn add @react-spring/web

Adding a target

To create your own target, we offer the createHost function. This function returns the animated components related to the specific target, e.g. the host created in @react-spring/web returns the animated dom components such as animated.div.

The signature for createHost function looks like this:

type CreateHost = (

  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },

  config: Partial<HostConfig>

) => {

  animated: WithAnimated

}

AnimatableComponent

The first argument AnimatableComponent[] | { [key: string]: AnimatableComponent }, is a list of strings that relate the native elements of the renderer you're targeting. Using the same example of @react-spring/web, the components would include the strings 'div', 'li' etc. These components are then created into Animated components in the createHost function via the withAnimated HOC.

HostConfig
interface HostConfig {

  /** Provide custom logic for native updates */

  applyAnimatedValues: (node: any, props: Lookup) => boolean | void

  /** Wrap the `style` prop with an animated node */

  createAnimatedStyle: (style: Lookup) => Animated

  /** Intercept props before they're passed to an animated component */

  getComponentProps: (props: Lookup) => typeof props

}


Whilst the entire config object is wrapped in Partial, meaning that the keys are optional, realistically applyAnimatedValues is required. This is the logic for how the Animated components apply their SpringValues, this typically would come from the reconciler either attached to the instance in the case of react-konva or an exported function like in @react-three/fiber.

The createAnimatedStyle key of the config object by default takes wraps the style prop in an AnimatedObject instance which has generic rules on applying keys. In the case of @react-spring/web, we pass a custom function which is how we support shorthands for transformation styles.

The getComponentProps is a middleware function that allows you to intercept props before they're passed to the animated component, therefore you could omit props e.g. scrollTop for the web because @react-spring/web expects this to be in the style object.

For more information on animated elements, see here.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components#component-apis

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Component APIs
Hooks vs Components

As with all our APIs we have a component and hook version. We personally recommend using the hook version as it is more inline with react's vision of the future of react. However, we understand there are codebases out there that still use class components and we want to support those too.

The typical format for importing the component version is to remove the use part of the name, e.g.

import { useSpring } from '@react-spring/web'



// becomes



import { Spring } from '@react-spring/web'


All the props remain the same. It's just a light wrapper and uses a render props method:

import { Spring } from '@react-spring/web'



const MyComponent = () => {

  return (

    <Spring from={{ opacity: 0 }} to={{ opacity: 1 }}>

      {style => <animated.div style={style} />}

    </Spring>

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components#hooks-vs-components

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Component APIs
Hooks vs Components

As with all our APIs we have a component and hook version. We personally recommend using the hook version as it is more inline with react's vision of the future of react. However, we understand there are codebases out there that still use class components and we want to support those too.

The typical format for importing the component version is to remove the use part of the name, e.g.

import { useSpring } from '@react-spring/web'



// becomes



import { Spring } from '@react-spring/web'


All the props remain the same. It's just a light wrapper and uses a render props method:

import { Spring } from '@react-spring/web'



const MyComponent = () => {

  return (

    <Spring from={{ opacity: 0 }} to={{ opacity: 1 }}>

      {style => <animated.div style={style} />}

    </Spring>

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#usespring

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#with-a-function--deps

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#with-a-config-object

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring#ts-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSpring

Our flagship hook. Applicable to most use-cases. If you want to orchestrate many of these hooks, consider using useSprings.

Usage

Whether you're using a function or not, it's all about passing a config object to the hook.

With a function & deps
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const [props, api] = useSpring(

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return <animated.div style={props}>Hello World</animated.div>

}

With a config object
import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSpring(configuration: ConfigObject): SpringValues



function useSpring(

  configurationFn: () => ConfigObject,

  deps?: any[]

): [springs: SpringValues, api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Animating Auto
Animating widths with react-spring, use-measure and interpolation
auto
useMeasure
width
interpolation
useSpring
Async CSS variables
Using CSS variables with the useSpring hook and animation chains
loop
async
variables
css
useSpring
Card
Animating images on a card with react-spring and use-gesture.
scrolling
useSpring
interpolation
useGesture
cards
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
CSS Gradients
Use interpolations & easings to create the CSS gradients you've been seeing all over the web.
interpolation
gradients
css
useSpring
leva
CSS Keyframes
Simulating CSS keyframes with interpolations
css
interpolation
useSpring
keyframes
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Flip Card
Using interpolations & CSS 3D create a flip card effect
useSpring
css
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Native Slide
A native-esque slider component animated with useSpring and useDrag
useDrag
interpolation
useSpring
native
Noise
Create noise with just a small image and useSpring
steps
easing
useSpring
interpolation
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview
Rocket decay
Create intertia with the velocity and decay config options combined with interpolation
velocity
useSpring
intertia
interpolation
decay
Svg Filter
Animating SVG filter nodes to distort a path
filters
useSpring
svg
path
Tree List
Animated tree styled menu list
list
tree
useSpring
menu
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#springvalues

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#usesprings

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#with-a-function--deps

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#with-a-config-object

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-springs#ts-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useSprings

If you want to orchestrate multiple springs with a unified API, this is probably the best hook for you.

Usage

useSprings differs because we supply the amount of springs we want and then pass our configuration, whether you're using a function or not.

With a function & deps
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const [springs, api] = useSprings(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useSprings, animated } from '@react-spring/web'



function MyComponent() {

  const springs = useSprings(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {springs.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useSprings(count: number, configuration: ConfigObject): SpringValues[]



function useSprings(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Cards Stack
Animating a stack of cards with @use-gesture/react's useDrag hook, useSprings and interpolation
use-gesture
cards
useDrag
interpolation
useSprings
Draggable List
Using @use-gesture/react with react-spring to create a draggable re-orderable list
list
useSprings
draggable
useDrag
interpolation
Floating Button
A small floating button like Facebook's desktop messenger built with radix & stitches
interpolation
useSprings
useSpring
stitches
use-gesture
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Viewpager
Animating a viewport sized image carousel with useDrag, useMeasure and useSprings
useDrag
useSprings
carousel
useMeasure

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#updating

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#usespringvalue

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/spring-value

Enable light mode
Enable dark mode
                                                    7%;;WW/                                                                                                                                             
                                                   (W HQXXXXXXX/                                                                                                                                        
                                                 /;NNXXXXXXXXXXX                                                                                                                                        
                                                 (7 WXXXXXXXXXXXA                                                                                                                                       
                                               %7;% QXXXXXXXXXXXXQ                                                                                                                                      
                                              X;<Y  XXXXXXXXXXXXXXB                                                                                                                                     
                                            A(<(%   XXXXXXXXXXXXXXXQ                                                                                                                                    
                                        /QY(;;A     XXXXXXXXXXXXXXXX(                                                                                                                                   
                                      X;&(&;YV      XXXXXXXXXXXXXXXXX                                                                                                                                   
                                    X;;;;(;(        XXXXXXXXXXXXXXXXXX                                                                                                                                  
                                  77bW;W<<X&        XXXXXXXXXXXXXXXXXXX7                                                                                                                                
                                    /Y 7W7 (       ;XXXXXXXXXXXXXXAWQWWQ                                                                                                                                
                                   /               cXXXXXXXXBQyvvvv&vvvvX7                                                                                                                              
                                                   %XXXW&vcWvvXvvvyvvvcYAA                                                                                                                              
                                                   Q@vvcvvvvvvyvvvvcv     X /                                                                                                                           
                                                     @vvvv&vvvvvQvX      @/Y                                                                                                                            
                                                    /vvXXvvvvvvvvvc%    QvWvcX                                                                                                                          
                                                     HvvvBvvvvvvvvvvvv%&vvvvvvc                                                                                                                         
                                                     BWvvyvvvvvvvvcQ((((((XHXy                                                                                                                          
                                                    (vvyvvvvvvv%QW((((((((((W                                                                                                                           
                                                   (vvvyWQvvvX(((((((((((((((((v(                                                                                                                       
                                                   yvXvvvvvvQ(vX%(((((((W((7(((7V                                                                                                                       
                                                   @c2vvQvvvvB((((((((((&                                                                                                                               
                                                  /@@@&vXvvvvQ(((((((A                                                                                                                                  
                                                  (@@@@@@@yvvv@(((%&                                                                                                                                    
                                                 /@@@@@@@@@@@@W/A@H@                                                                                                                                    
                                                7@@@@@@@@@@@@@@@@XXX@                                                                                                                                   
                                               @@@@@@@@@@@@@@@@@@XXWB                                                                                                                                   
                                              @@@@@@@@@@@@@@@@@@@XX@                                                                                                                                    
                                             @@@@@@@@@@@@@@@@@@@@@@@                                                                                                                                    
                                           <@@@@@@@@@@@@@@@@@@@@@@@@@@                c/@                                                                                                               
                                          ;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B              B/@                                                                                                              
                                          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@N         //@@                                                                                                             
                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@NN    @<c@                                                                                                            
                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%   <Q N                                                                                                           
                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@W;@/W Q/                                                                                                         
                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@/<;X;%   7                                                                                                        
                                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Nvv&Q(//y/@   B                                                                                                       
                                 WB7/////N@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@vvvy%@@@@7(@@@@@W7V(;                                                                                                 
                        @(<(A@@;/////<N@B%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@yvvWvv;<@(&/@<@(///////////////////////////////7&@W/                                                                   
                       &          &@@%/////@@@@@@@@NN@@@@@@@@@@@@@@@@@@@@@@@@@@@@vvvv@NBc//@&(@&//<<<(ccyQQ@@@N@NA&c7<////////<7cANHBcy7                                                                
                      %  /(%XBN@@QV((////////////////////////////////////////////////////////////////////////////////(<vv%yv&&&yv((//////BN                                                             
        <vQN@@@@A7/////////////////////////////////@/////////////////////////////////////////(7/////////////////////////////////////////////N                                                           
 (W//N/////////////////////////////////////////y/       //(v%A@@@@@@@@@@@@@@@@@@@NAAv(//        %////////////////////////////////////////////@                                                          
 &//&//////////////////////////////////////////Q y                                            ( @/////////////////////////////////////////////                                                          
A///@//////////////////////////////////////////                                                 c/////////////////////////////////////////////bQ                                                        
N///A/////////////////////////////////////////y                                                 //////////////////////////////////////////////@7                                                        
(///7/////////////////////////////////////////X                                                 /////////////////((yV&v(((////////////////////B@                                                        
///<//////////////////////////////////////////&                                                 ////////&@@@@@@@@@@@@@@@@@@@@@@ NH@@@@@@@@@Av (                                                         
///;//////////////////////////////////////////7                                                 Q///////@@@@@@@@@@@@@@@@@@@@@@@@7B  /     7 /X@                                                         
c///(///////////////////////////////////////////                                                @//////@@@@@@@@@X;(;((;(;B@@@@@@@@/////////////                                                         
@///A//////////////////////////////////////////N                                                7//////@@@@@@@W(%A//////W;(@@@@@@@@////////////                                                         
;///@//////////////////////<<//////////////////vV                                              b//////A@@@@@@b(N//////////7(W@@@@@@////////////                                                         
 @///c//////////////////@@@@N;N///////////@;c@N////@/%N@@@NW&7(////(<////77v&bWN@@@@NQy%<////@////////@@@@@@@;N////////////;(@@@@@@@//////////N                                                         
  /@BN/////////////////@@@@@((@////////////((@@@%//(/////////////////////////////////////////V////////cB@@@@N;B////////////y;N@@@@@    /%c(                                                             
         7N@@@@@N&&yyy@@@@@@v;@///////////<(;@@@@@@N@V;/////////////////////////////////////(////////cB@@@@@@(@////////////(;@@@@@@                                                                     
                      @@@@@@N(v(//////////@(N@@@@@/              ///v(vv(%XXA@@XX7vv//                 @@@@@@;(@//////////%(;@@@@@@                                                                     
                       @@@@@@V;(@////////B;X@@@@@@                                                     v@@@@@@;(7W//////@(;(@@@@@@                                                                      
                        @@N@@@@(;(X@@@@v(;@@@@@@@                                                       y@N@@@@@;(;((;(;(;N@@@@@@                                                                       
                         N@@@@@@@W(;;(;W@@@@B@@(                                                          @@@@@@@@@WV%X@@@@@@@@W                                                                        
                           @@@@@@@@@@@@@@@@@@@                                                              @@N@@@@@@@@@@@@@@@                                                                          
                             V@@@@@@@@@@@@@(                                                                  X@@@@@@@@@N@@(                                                                            
                                 /QQQQc                                                                                                                                                                 
                                                                                                                                                                                                        

404, not found
Go home

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#value-only

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-spring-value#with-configuration

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Updating
Reference
Typescript
Examples
useSpringValue

Love the imperative API but you need too many different springs running in parallel? Then this hook is for you! It's a simple wrapper around a SpringValue and therefore behaves the same, so you can access it's methods imperatively.

Usage
Value only
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0)



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

With configuration
import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  return <animated.div style={{ opacity }}>Hello World</animated.div>

}

Updating
Warning

Unlike our other hooks, this one will not react to updates in the component. This is by design. You must use the methods on the returned SpringValue to update said value.

import { useSpringValue, animated } from '@react-spring/web'



function MyComponent() {

  const opacity = useSpringValue(0, {

    config: {

      mass: 2,

      friction: 5,

      tension: 80,

    },

  })



  const handleClick = () => opacity.start(1)



  return (

    <animated.div onClick={handleClick} style={{ opacity }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
function useSpringValue<T>(value: T): SpringValue<T>



function useSpringValue<T>(value: T, config: ConfigObject): SpringValue<T>


Where ConfigObject is described above

Examples
MacOS Dock
A MacOS-esque dock created in HTML with all the animations you'd expect!
interpolation
useDrag
useSpringValue
useSpring
loop

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#usetransition

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#with-a-function--deps

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#with-a-config-object

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#transition-function

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-transition#ts-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTransition

This hook is best suited for animating in & out datasets or items you don't particularly want to be left in the DOM, e.g. a dialog.

Usage

useTransition depends on an array of data. That data can be anything you want, we use a lot of internals to track each datum including inferring the keys, this is the first argument. The second is a config object, which is different to useSpring or useSprings so take note!

With a function & deps
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const [transitions, api] = useTransition(data, () => ({

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  }))



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

With a config object
import { useTransition, animated } from '@react-spring/web'



function MyComponent({ data = [1, 2, 3] }) {

  const transitions = useTransition(data, {

    from: { opacity: 0 },

    enter: { opacity: 1 },

    leave: { opacity: 1 },

  })



  return transitions((style, item) => (

    <animated.div style={style}>{item}</animated.div>

  ))

}

Transition function

The transition function takes a render function as an argument. This is how we append keys. From the example above you can see we pass a style argument to the function, this style object relates to the state of the animation, e.g. if the animation is ENTERING then the we use the keys from the enter property of of your config object. For a deeper dive into the function signature see the Typescript section.

Reference

Item is defined a lot below, it's automatically inferred from what you pass as the content of the array you pass as the first argument to the hook. Therefore, if you passed [1, 2, 3] then Item would be number.

Prop	Type	Default
from	object | function

initial	object | function

enter
	object | object[] | function

update
	object | object[] | function

leave
	object | object[] | function

keys
	Array<string | number> | function | null

sort	function

trail	number
exitBeforeEnter	boolean
expires
	boolean | number | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTransition<Item extends any>(

  data: Item[],

  configuration: ConfigObject

): TransitionFn<Item>



function useTransition<Item extends any>(

  data: Item[],

  configurationFn: () => ConfigObject

  deps?: any[]

): [transition: TransitionFn<Item>, api: SpringRef]



type TransitionFn = (

  style: SpringValues,

  item: Item,

  transitionState: TransitionState<Item>,

  index: number

) => ReactNode


Where ConfigObject is described above

TS Glossary
TransitionState
Examples
Basic Transition
Basic viewport sized transition of cards animating with the imperative API
springref
imperative
useTransition
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Exit Before Enter
Showcasing the exitBeforeEnter prop and animated clip-paths to give a wipe effect
useTransition
useSpring
springref
exitbeforeenter
paths
Image Fade
Simple image fading illustrating the exitBeforeEnter prop on useTransition
onrest
exitbeforeenter
image
useTransition
List Reordering
Automatic list reordering with animation
useTransition
list
Masonry Grid
A pintrest-esque homepage with animations
masonry
pintrest
useTransition
Multistage Transitions
Async animation scripts for entering and leaving using useTransition
useTransition
scripts
async
Notification Hub
Creating toast notifications with useTransition
useTransition
toast
notifications

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#transitionstate

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#timesteps-explained

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-chain#usechain

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Timesteps Explained
Reference
Typescript
Examples
useChain

useChain is used to orchestrate animation hooks in sequence with one another. This is best used when you specifically want to orchestrate different types of animation hook e.g. useSpring & useTransition in sequence as opposed to multiple useSpring hooks where you could either use useSprings or create an async animation.

Usage

This will first run the useSpring hook and then the useTransition hook when the component has mounted and the useSpring has come to rest.

import {

  useTransition,

  useSpring,

  useChain,

  animated,

  useSpringRef,

} from '@react-spring/web'



const data = ['hi', 'there!']



function MyComponent() {

  const springRef = useSpringRef()

  const springs = useSpring({

    ref: springRef,

    from: { size: '20%' },

    to: { size: '50%' },

  })



  const transRef = useSpringRef()

  const transitions = useTransition(data, {

    ref: transRef,

    from: { scale: 0 },

    enter: { scale: 1 },

    leave: { scale: 0 },

  })



  useChain([springRef, transRef])



  return (

    <animated.div
      style={{
        height: springs.size,
        width: springs.size,
        background: 'blue',
      }}
    >

      {transitions((style, item) => (

        <animated.div
          style={{
            width: '120px',
            height: '120px',
            background: 'green',
            ...style,
          }}
        >

          {item}

        </animated.div>

      ))}

    </animated.div>

  )

}

Timesteps Explained

Using the previous as an example we can see that the transition is ran after the useSpring hook has come to rest. This is the default behaviour of the useChain hook.

However, they may be some instances where you want to define how long before the next spring is triggered. That's where timesteps come in.

Take this usage of useChain:

useChain([springRef, transRef], [0, 1], 1000)


We've added two additional arguments to the hooks, the first is a number array of timesteps (numbers must be in the range 0-1) that should model to the index of your SpringRefs and the second is a the timeframe (defaulting to 1000ms).

The way to think about the timesteps & timeframe is that the timestep of the hooks, multiplied by the timeframe is the delay you apply to your animations:

const refs = [springRef, transRef]

const timesteps = [0, 1]

const timeframe = 1000



refs.forEach((ref, index) => {

  /**

   * for the first ref this would be 0 because 0 * 1000 = 0

   * for the second ref this would be 1000 because 1 * 1000 = 1000

   */

  const time = timesteps[index] * timeframe



  // the delay is then applied to the animation.

  ref.delay = time

})


So therefore if you wanted your transition to come in after 400ms you could do this:

useChain([springRef, transRef], [0, 0.4])


Note, we omitted the timeframe argument here because it has a default of 1000.

Reference

This hook does not have a configuration object or take additional props.

Typescript
function useChain(refs: ReadonlyArray<SpringRef>): void



function useChain(refs: ReadonlyArray<SpringRef>, timeSteps: number[]): void



function useChain(

  refs: ReadonlyArray<SpringRef>,

  timeSteps: number[],

  timeFrame: number

): void

Examples
Chaining Transition and a Spring
Orchestrating a useTransition and useSpring hook with the useChain hook.
springref
useChain
useTransition
useSpring
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#usetrail

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#with-a-function--deps

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#with-a-config-object

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/use-trail#ts-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useTrail

useTrail has an identical API signature to useSprings the difference is the hook automatically orchestrates the springs to stagger one after the other.

Usage
With a function & deps
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const [trails, api] = useTrail(

    2,

    () => ({

      from: { opacity: 0 },

      to: { opacity: 1 },

    }),

    []

  )



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

With a config object
import { useTrail, animated } from '@react-spring/web'



export default function MyComponent() {

  const trails = useTrail(2, {

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return (

    <div>

      {trails.map(props => (

        <animated.div style={props}>Hello World</animated.div>

      ))}

    </div>

  )

}

Reference
Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

ref
	SpringRef
config
	object | function

events
	function
Typescript
function useTrail(count: number, configuration: ConfigObject): SpringValues[]



function useTrail(

  count: number,

  configurationFn: (springIndex: number) => ConfigObject,

  deps?: any[]

): [springs: SpringValues[], api: SpringRef]


Where ConfigObject is described above

TS Glossary
SpringValues
Examples
Basic Trail
Introduction to using the useTrail hook as part of a wrapper component
useTrail
configuration
basic
Goo Blobs
2D SVG metaballs animated with react-spring
filters
svg
useTrail
useMeasure
metaballs
Smile Grid
An animated SVG grid with a smiley face inside!
svg
useSprings
useTrail
useSpringRef
useChain
Wordle
Wordle tiles with useTrail
stitches
useTrail
interpolation

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax#ref

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax#parallax

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with ParallaxLayer to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

The Parallax component creates a scrollable container in which ParallaxLayers can be placed or React.Fragments whose only direct children are ParallaxLayers. Because Parallax is a scrollable container all scroll events are fired from the container itself therefore, listening for scroll on window won't work. However, if you want to attach additional events you can use ref.current.container

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
pages
	number
config
	object | function

enabled	boolean
horizontal	boolean
innerStyle	CSSProperties
Ref

Passing a ref to the Parallax component will give you access to the internal state of the Parallax component via ref.current:

interface IParallax {

  config: ConfigProp

  horizontal: boolean

  busy: boolean

  space: number

  offset: number

  current: number

  controller: Controller<{ scroll: number }>

  layers: Set<IParallaxLayer>

  container: React.MutableRefObject<any>

  content: React.MutableRefObject<any>

  scrollTo(offset: number): void

  update(): void

  stop(): void

}

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer#ref

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/components/parallax-layer#parallax

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Ref
Examples
Parallax

Used in collaboration with Parallax to create visual displacements declaratively and simply.

Usage
Note

This component is only available in the @react-spring/web package and is therefore only usable in the browser.

import { Parallax, ParallaxLayer } from '@react-spring/parallax'



function MyComponent() {

  return (

    <Parallax pages={1} style={{ top: '0', left: '0' }}>

      <ParallaxLayer offset={0} speed={2.5}>

        <p>Parallax</p>

      </ParallaxLayer>

    </Parallax>

  )

}

Reference

All props that can be passed to HTMLDivElement can be passed to Parallax.

Prop	Type	Default
horizontal	boolean
factor
	number
offset
	number
speed
	number
sticky
	StickyConfig
Ref

Passing a ref to the ParallaxLayer component will give you access to the layer state of the ParallaxLayer component via ref.current:

interface IParallaxLayer {

  horizontal: boolean

  sticky: StickyConfig

  isSticky: boolean

  setHeight(height: number, immediate?: boolean): void

  setPosition(height: number, scrollTop: number, immediate?: boolean): void

}



type StickyConfig = { start?: number; end?: number } | undefined

Examples

Can't find what you're looking for? Check out all our examples!

Horizontal Parallax
The real test of a parallax component, horizontal scrolling
Parallax
horizontal
Sticky Parallax
Showcasing the sticky prop used with the Parallax component
Parallax
sticky
Vertical Parallax
Showcasing a basic use of vertical parallax
vertical
Parallax
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#config-visualizer

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#easings

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#pitfalls

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#spring-configs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#basic-usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#config-per-springvalue

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#partial-updates

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#presets

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#why-springs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#available-generic-easings

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#steps-easing

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#my-animation-jumps-at-the-end

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/config#my-animation-is-bouncing-and-i-just-want-it-to-stop

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#keys-vs-springs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onstart

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onchange

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onrest

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onpause

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onresume

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onresolve

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#onprops

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#ondestroyed

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#events

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/events#a-note-on-item

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Keys vs Springs
onStart
onChange
onRest
onPause
onResume
onResolve
onProps
onDestroyed
Typescript
Events

There are a handful of events you can use to react to the state of animation at certain points in time.

Keys vs Springs

Every event function can either be a function on it's own or be an object to which it's keys correlate to the keys of the spring:

useSpring(

  () => ({

    x: 0,

    y: 0,

    // onStart is called when the animation of the spring starts

    onStart: () => console.log('the spring has started'),

  }),

  []

)



useSpring(

  () => ({

    x: 0,

    y: 0,

    onStart: {

      // onStart is called for each key when the animation starts

      x: () => console.log('x key has started'),

      y: () => console.log('y key has started'),

    },

  }),

  []

)


The latter form can be useful if for example you have different configs for different keys. Or you want to do different events based on different keys, e.g. you want to imperatively update an objects rotation based on the x key.

onStart

Called when the animation begins.

Warning

onStart is called after the first animation tick, this value is therefore considered dirty.

type OnStart = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onChange

Called on every frame.

type OnChange = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onRest

Called when the animation comes to a stand-still.

type OnRest = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onPause

Called when the animation is paused.

type OnPause = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResume

Called when the animation is resumed.

type OnResume = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onResolve

Called when the promise for the update is resolved.

type OnResolve = (

  result: AnimationResult,

  spring: Controller | SpringValue,

  item?: Item

) => void

onProps

Called after an animation is updated by new props, even if the animation remains idle.

type OnProps = (

  props: {[key: string]: any}

  spring: SpringValue,

) => void

onDestroyed

Called after a transition item is unmounted.

type OnDestroyed = (

  item: Item

  key: string | number

) => void

Typescript
interface AnimationResult {

    // Type inference will solve this for you.

    value: SpringValue | { [keyof SpringValues]: number} | number

    finished: boolean

    cancelled: boolean

}

A note on Item

The Item argument is only present when using the relevant events within the useTransition hook.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#properties

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#methods

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#controller

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#constructor-arguments

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#get

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#set

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#update

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#start

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#stop

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#pause

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#resume

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/controller#each

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
Controller

Manages SpringValues for our spring hooks.

Usage

Basic usage, the Controller class you initialise can be used as an imperative api to control your SpringValues. Meanwhile you pass Controller.springs to your animated component.

import { Component, createRef } from 'react'

import { Controller, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  animations = new Controller({ opacity: 0 })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Constructor Arguments

Below is the arguments that can passed to the constructor of the Controller class.

const ControllerProps = {

  ref,

  from,

  loop,

  onStart,

  onRest,

  onChange,

  onPause,

  onResume,

  onProps,

  onResolve,

}

Properties
Prop	Type	Default
idle
	SpringValues
item	any
queue
	ControllerQueue
ref
	SpringRef
springs
	SpringValues
Methods
Get

Gets the current values of our springs.

get(): State & UnknownProps;

Set

Set the current values without animating.

set(values: Partial<State>): void;

Update

Push an update onto the queue of each value.

update(props: ControllerUpdate<State> | Falsy): this;

Start

Start the queued animations for every spring, and resolve the returned promise once all queued animations have finished or been cancelled. When you pass a queue (instead of nothing), that queue is used instead of the queued animations added with the update method, which are left alone.

start(props?: OneOrMore<ControllerUpdate<State>> | null): AsyncResult<this>;

Stop

Stop all queued animations for every spring at the same time, or alternatively provide a selection of keys that should be stopped.

stop(): this;

stop(keys: OneOrMore<string>): this;

stop(cancel: boolean): this;

stop(cancel: boolean, keys: OneOrMore<string>): this;

stop(keys?: OneOrMore<string>): this;

stop(cancel: boolean, keys?: OneOrMore<string>): this;

Pause

Freeze the active animation in time.

pause(keys?: OneOrMore<string>): this;

Resume

Resume the animation if paused.

resume(keys?: OneOrMore<string>): this;

Each

Call a function once per spring value.

each(iterator: (spring: SpringValue, key: string) => void): void

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#properties

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#methods

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#ts-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#springvalue

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#advance

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#finish

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#pause

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#reset

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#resume

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#set

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#start

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#stop

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-value#update

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
TS Glossary
SpringValue

The very driving force of react-spring. It's a class that can be used to create a single value that can be animated.

Usage

Basic usage, the SpringValue class you initialise can be used just like our imperative api. Meanwhile you pass the SpringValue to your animated component. Any type is valid, but only certain types are actually animated. Types that cannot be animated are basically immediate: true animations. Such types include: a boolean, a display string like "none", etc.

import { Component, createRef } from 'react'

import { SpringValue, animated } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  springOpacity = new SpringValue(0)



  toggle = () => {

    this.springOpacity.start(isShowing ? 0 : 1)



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={{ opacity: this.springOpacity }}>

          I will fade

        </animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
animation	Animation
defaultProps
	SpringConfig
goal	any
hasAnimated
	boolean
idle
	boolean
isAnimating
	boolean
isDelayed
	boolean
isPaused
	boolean
key
	string | undefined
queue
	SpringUpdate[]
velocity	number | number[]
Methods
Advance

Advance the current animation by a number of milliseconds.

advance(dt: number): void;

Finish

Skip to the end of the current animation.

finish(): this;

Pause

Freeze the active animation in time, as well as any updates merged before resume is called.

pause(): void;

Reset

Restart the animation.

reset(): void;

Resume

Resume the animation if paused.

resume(): void;

Set

Set the current value, while stopping the current animation.

set(value: T | FluidValue<T>): this;

Start

Update this value's animation using the queue of pending props, and unpause the current animation (if one is frozen). When arguments are passed, a new animation is created, and the queued animations are left alone.

start(): AsyncResult<this>;

start(props: SpringUpdate<T>): AsyncResult<this>;

start(to: T, props?: SpringProps<T>): AsyncResult<this>;

Stop

Stop the current animation, and cancel any delayed updates. Pass true to call onRest with cancelled: true.

stop(cancel?: boolean): this

Update

Push props into the pending queue.

update(props: SpringUpdate<T>): this;

TS Glossary
Animation
SpringUpdate
Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#animation

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#springupdate

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#properties

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#methods

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#springref

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#hook

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#function-call

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#add

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#delete

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#pause

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#resume

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#stop

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/spring-ref#update

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Properties
Methods
SpringRef

Our imperative API. You can initialise it via function call, or for better practice use the hook useSpringRef. For more contextual information for this function and why it's so important, see here.

Usage
Hook
import { animated, useSpring, useSpringRef } from '@react-spring/web'



function MyComponent() {

  const api = useSpringRef()



  const props = useSpring({

    ref: api,

    from: { opacity: 0 },

    to: { opacity: 1 },

  })



  return <animated.div style={props}>Hello World</animated.div>

}

Function call
import { Component, createRef } from 'react'

import { Controller, animated, SpringRef } from '@react-spring/web'



class AnimatedComponent extends Component {

  isShowing = createRef(false)

  api = SpringRef()

  animations = new Controller({ opacity: 0, ref: this.api })



  toggle = () => {

    this.animations.start({ opacity: this.isShowing ? 1 : 0 })



    this.isShowing = !this.isShowing

  }



  render() {

    return (

      <>

        <button onClick={this.toggle}>click</button>

        <animated.div style={this.animations.springs}>I will fade</animated.div>

      </>

    )

  }

}

Properties
Prop	Type	Default
current	Controller[]
Methods
Add

Add a controller to this ref.

add(ctrl: Controller<State>): void

Delete

Remove a controller from this ref.

delete(ctrl: Controller<State>): void

Pause

Pause some or all animations by passing SpringValue keys.

pause(): this

pause(keys: OneOrMore<string>): this

pause(keys?: OneOrMore<string>): this

Resume

Resume some or all animations by passing SpringValue keys.

resume(): this

resume(keys: OneOrMore<string>): this

resume(keys?: OneOrMore<string>): this

Set

Update the state of each controller without animating. Accepts either a partial state object or a function that returns a partial state object.

set(values: Partial<State>): void

set(values: (index: number, ctrl: Controller<State>) => Partial<State>): void

Start

Start the queued animations of each controller. Alternatively pass a ControllerUpdate object to update the state of each controller before starting the animations. Or pass a function to edit the ControllerUpdate depending on the specific Controller.

start(): AsyncResult<Controller<State>>[]

start(props: ControllerUpdate<State>): AsyncResult<Controller<State>>[]

start(props: ControllerUpdateFn<State>): AsyncResult<Controller<State>>[]

start(

props?: ControllerUpdate<State> | ControllerUpdateFn<State>

): AsyncResult<Controller<State>>[]

Stop

Stop some or all of the animations by passing SpringValue keys. Additionall, cancel those animations by passing a boolean as the first argument and the keys as the second.

stop(): this

stop(keys: OneOrMore<string>): this

stop(cancel: boolean): this

stop(cancel: boolean, keys: OneOrMore<string>): this

stop(keys?: OneOrMore<string>): this

stop(cancel: boolean, keys?: OneOrMore<string>): this

Update

Add the same props to each controller's update queue. Or alternatively generate separate props for each controller's update queue with a function.

update(props: ControllerUpdate<State>): this

update(props: ControllerUpdateFn<State>): this

update(props: ControllerUpdate<State> | ControllerUpdateFn<State>): this

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#what-is-one

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#basic-usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#advanced-usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#config

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#overriding-the-global-to-function

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#interpolation

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#extending-the-springvalue

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#using-the-to-function

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#combining-values

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/interpolation#ranges-and-outputs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
What is one?
Basic Usage
Advanced Usage
Config
Overriding the global to function
Typescript
Interpolation
What is one?

An interpolation typically is a function that takes a value returns another value. You can even map ranges of values ‚Äì numbers are typically required as the input range. So for example, if you want to animate a value from 0 to 100, you can use an interpolation to map the range 0 to 1 to 0 to 100.

Basic Usage
Extending the SpringValue

The most common use of our interpolation is to convert the value of a SpringValue to another value. This is done by using the to method.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: props.x.to(value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Using the to function

Similar to the example above, it's also possible to use our to function to convert SpringValues.

import { useSpring, animated, to } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 360 },

  })



  return (

    <animated.div
      style={{ transform: to(props.x, value => `rotateZ(${value}deg)`) }}
    >

      Hello World

    </animated.div>

  )

}

Advanced Usage
Combining values

A more advanced use of our interpolation is to combine multiple SpringValues. This normally requires the use of our to function to create.

import { animated, to, useSpring } from '@react-spring/web'



export default function MyComponent() {

  const props = useSpring({

    from: { x: 0, y: 0, z: 0 },

    to: { x: 1, y: 1, z: 1 },

  })



  return (

    <animated.div
      style={{
        transform: to(
          [props.x, props.y, props.z],
          (x, y, z) => `rotate3d(${x}, ${y}, ${z}, 45deg)`
        ),
      }}
    >

      Hello World

    </animated.div>

  )

}

Ranges and Outputs

The to function also accepts a range of input values as the first argument and the output of that range. Interpolations can be chained, as seen in the example below we change a value 0-1 to 0-360 and then interpolate it to a rotateZ value.

import { useSpring, animated } from '@react-spring/web'



function MyComponent() {

  const props = useSpring({

    from: { x: 0 },

    to: { x: 1 },

  })



  return (

    <animated.div
      style={{
        transform: props.x
          .to([0, 1], [0, 360])
          .to(value => `rotateZ(${value}deg)`),
      }}
    >

      Hello World

    </animated.div>

  )

}

Config

An interpolation can also take a config object as the second argument if using the to function or the first argument when using the to method of a SpringValue.

Prop	Type	Default
extrapolateLeft	string

extrapolateRight	string

extrapolate	string

range
	number[]
output
	number[]
map
	function
Overriding the global to function

If you decide to, it is possible to override the global Interpolation factory which is what's called when to is used.

import { Globals } from '@react-spring/web'



Globals.assign({

  to: (source, args) => new CustomInterpolation(source, args),

})

Typescript
function to<Input extends ReadonlyArray<any>, Output>(

  parents: Input,

  interpolator: (...args: Interpolated<Input>) => Output

): Interpolation<Output>



function to<Input, Output>(

  parent: FluidValue<Input> | Input,

  interpolator: InterpolatorFn<Input, Output>

): Interpolation<Output>



function to<Out>(

  parents: FluidValue[],

  config: InterpolatorConfig<Out>

): Interpolation<Animatable<Out>>



function to<Out>(

  parents: Array<FluidValue<number>> | FluidValue<number[]>,

  range: readonly number[],

  output: readonly Constrain<Out, Animatable>[],

  extrapolate?: 'identity' | 'clamp' | 'extend'

): Interpolation<Animatable<Out>>

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations#arent-all-animations-async

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations#the-to-prop

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations#chaining-animations

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations#writing-animation-scripts

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/advanced/async-animations#async-animations

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Aren't all animations async?
The to prop
Chaining animations
Writing animation scripts
Async Animations
Note

This is an advanced guide. If you're new to react-spring, you should start with the getting started page and become familar with the library before jumping into async animations.

Aren't all animations async?

Well technically in react-spring yes, you could consider animations to be async? The start function of a Controller is async and therefore the imperative api is too, async. And then your styles are updated asynchronously... But that's not what this guide is referring too.

When we talk about async animations we refer to the ability to perform X amount of transformations with only one call of the APIs and each animation chunk will finish before the other begins. If you look at the example below, this animation has only a config object, loop prop and a to prop.

The to prop

If you've read any of the component pages, you'll know we accept a to prop, it's typically used as an object, but alternatively, you can also use an array (chaining the animations) or a function (writing an animation script).

When you consider the options you have as to what you can pass to the to prop, you'll begin to understand how complicated your animations can be, it's then a matter of understand what you're trying to achieve and applying the best solution.

Chaining animations

The array syntax is a middleground between total control of async animations and the simplicity of passing just an object. Just like the start method of the imperative api, you don't need to reference every key for each update. Each update will fire when the previous one has finished.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: [

      { x: 80, background: '#fff59a' },

      { y: 40, background: '#88DFAB' },

      { x: 0, background: '#569AFF' },

      { y: -40, background: '#ff6d6d' },

    ],

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Writing animation scripts

When you need most control of your animation, it's best to write a script by providing a function to the to prop. The function receives two arguments, the next function which accepts an object of updates, again similar to the start method of the imperative API and a cancel function which works the same as the stop method of the imperative API.

This therefore allows you to cancel scripts at any time meaning you can react to external events & conditions.

For further reading, see imperative API.

Hide Code
import { useSpring, animated } from '@react-spring/web'



export default function MyComponent() {

  const springs = useSpring({

    from: { background: '#ff6d6d', y: -40, x: 0 },

    to: async (next, cancel) => {

      await next({ x: 80, background: '#fff59a' })

      await next({ y: 40, background: '#88DFAB' })

      await next({ x: 0, background: '#569AFF' })

      await next({ y: -40, background: '#ff6d6d' })

    },

    loop: true,

  })



  return (

    <animated.div
      style={{
        width: 40,
        height: 40,
        borderRadius: 4,
        ...springs,
      }}
    />

  )

}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#introduction

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#why-use-the-library

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#use-the-imperative-api

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#syncing-spring-values

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#troubleshooting

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#react-three-fiber

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/react-three-fiber#experiencing-jank

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Why use the library?
Use the imperative API
Syncing spring values
Troubleshooting
React Three Fiber
Note

It's assumed you have a base understanding of react-spring and react-three-fiber. If you're new to either, check out our getting started or alternatively, the react-three-fiber docs.

Introduction

In this guide we'll explore why react-spring is a valuable addition to your react-three-fiber project, working with the imperative API to create performant animation updates on objects in the scene graph and with the event system of the library to update parts of your scene that are not wrapped in our animated HOC. To work with react-spring and react-three-fiber you'll need to install the @react-spring/three package.

yarn add @react-spring/three @react-three/fiber three

Why use the library?

A common question asked is why use react-spring with react-three-fiber when you can use the useFrame hook to update your meshes & objects instead without knowing another API. Well this is a great question ‚Äì its critical of motion design for animations to look realistic, and the beauty of react-spring is the animations are physically correct.

When we consider that the animations you create with react-spring can not be interrupted per se, that is when you edit the value you don't have the animation halt and start again, it responds to it's new goal value creating a seamless experience incredibly valuable to a 3D scene, you don't see items in real life free fall and when an external force is applied they stall, they react accordingly. The dampening of a spring gives you the additional feeling of real life physics whilst in combination of even the three most basic config parameter mass, tension and friction you can create a wide range of animations that belong to different objects in your scenes, you might have a metal-like sphere that needs to move slowly compared to your light translucent sphere that should be falling and bouncing around the scene.

Furthermore, the flexibility to start/stop and replay animations, particularly with state and device motion preferences, makes this a uniquely accessible library from both a DX and UX perspective. Lets take a look at a simple use-case.

I have a distortion blob and I want to it to change color on click. You could do this with useFrame to perform frame by frame updates, useRef to access the material object and use the THREE.Color.lerp function, slowly incrementing by the lerp value until the color is reached. But this then requires that I keep track of a THREE instance of Color which can lead to memory leaks if not handled correctly and not only that, but it would be a lot of code. Then you'd need to think about writing your own easing functions. With react-spring you can do this in a few lines of code.

Hide Code
import { useState } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { MeshDistortMaterial } from '@react-three/drei'

import { Canvas } from '@react-three/fiber'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const [clicked, setClicked] = useState(false)



  const springs = useSpring({

    color: clicked ? '#569AFF' : '#ff6d6d',

  })



  const handleClick = () => setClicked(s => !s)



  return (

    <mesh onClick={handleClick}>

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Use the imperative API

The example above demonstrates the declarative approach to using react-spring hooks by passing a config object to the hook. However, it can also receive a function argument instead, similar to react's useEffect hook.

In the example below, we use the power of the react-spring's api to lean into the imperative requirements of working with performant webGL scenes. The blob follows you round the canvas (lines 70-82) & scales on interaction (lines 46-56) without a single react render to cause these updates.

In addition we use the provide a function to the config prop instead of an object to deliver a more sticky config for the spring in general, but to give the blob a bouncy feel when the scale key is changed ‚Äì lines 18-30.

Finally, because we're using the position of the mouse which can be considered a Vector2 and the position of a mesh is a Vector3 we use a custom interpolation via the to method of a SpringValue to interpolate the array, this can be seen on line 97 (also see imperative API and interpolation).

Hide Code
import { useRef, useEffect, useCallback } from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = () => {

  const isOver = useRef(false)



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

}



export default function MyComponent() {

  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene />

    </Canvas>

  )

}

Syncing spring values

Sometimes, it's necessary to sync the state of a spring with an external source. This can be done with the event system built into react-spring.

Take the following example, we have multiple blobs on our screen that start in different places and a component higher in our scene graph needs to to know the position of each blob. Because the position is controlled by useSpring you can't simple submit springs.position to the store because you'll be dispatching the whole SpringValue object, which is unnecessary and can weigh down your external store.

Instead, you can use the onChange event handler to get the value of your springs and react to them accordingly. The code below is a convoluted example but demonstrates how you could use the onChange event handler to sync a THREE.Vector2 that is then returned when the parent component requires it via useImperativeHandle.

Hide Code
import {

  useRef,

  useEffect,

  useCallback,

  forwardRef,

  useState,

  useImperativeHandle,

} from 'react'

import { useSpring, animated } from '@react-spring/three'

import { Canvas, useThree } from '@react-three/fiber'

import { MeshDistortMaterial } from '@react-three/drei'

import { Vector2 } from 'three'



const AnimatedMeshDistortMaterial = animated(MeshDistortMaterial)



const MyScene = forwardRef(({}, ref) => {

  const isOver = useRef(false)

  const [vector2] = useState(() => new Vector2())



  const { width, height } = useThree(state => state.size)



  const [springs, api] = useSpring(

    () => ({

      scale: 1,

      position: [0, 0],

      color: '#ff6d6d',

      onChange: ({ value }) => {

        vector2.set(value.position[0], value.position[1])

      },

      config: key => {

        switch (key) {

          case 'scale':

            return {

              mass: 4,

              friction: 10,

            }

          case 'position':

            return { mass: 4, friction: 220 }

          default:

            return {}

        }

      },

    }),

    []

  )



  useImperativeHandle(ref, () => ({

    getCurrentPosition: () => vector2,

  }))



  const handleClick = useCallback(() => {

    let clicked = false



    return () => {

      clicked = !clicked

      api.start({

        color: clicked ? '#569AFF' : '#ff6d6d',

      })

    }

  }, [])



  const handlePointerEnter = () => {

    api.start({

      scale: 1.5,

    })

  }



  const handlePointerLeave = () => {

    api.start({

      scale: 1,

    })

  }



  const handleWindowPointerOver = useCallback(() => {

    isOver.current = true

  }, [])



  const handleWindowPointerOut = useCallback(() => {

    isOver.current = false



    api.start({

      position: [0, 0],

    })

  }, [])



  const handlePointerMove = useCallback(

    e => {

      if (isOver.current) {

        const x = (e.offsetX / width) * 2 - 1

        const y = (e.offsetY / height) * -2 + 1



        api.start({

          position: [x * 5, y * 2],

        })

      }

    },

    [api, width, height]

  )



  useEffect(() => {

    window.addEventListener('pointerover', handleWindowPointerOver)

    window.addEventListener('pointerout', handleWindowPointerOut)

    window.addEventListener('pointermove', handlePointerMove)



    return () => {

      window.removeEventListener('pointerover', handleWindowPointerOver)

      window.removeEventListener('pointerout', handleWindowPointerOut)

      window.removeEventListener('pointermove', handlePointerMove)

    }

  }, [handleWindowPointerOver, handleWindowPointerOut, handlePointerMove])



  return (

    <animated.mesh
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      onClick={handleClick()}
      scale={springs.scale}
      position={springs.position.to((x, y) => [x, y, 0])}
    >

      <sphereGeometry args={[1.5, 64, 32]} />

      <AnimatedMeshDistortMaterial
        speed={5}
        distort={0.5}
        color={springs.color}
      />

    </animated.mesh>

  )

})



export default function MyComponent() {

  const blobApi = useRef(null)



  useEffect(() => {

    const interval = setInterval(() => {

      if (blobApi.current) {

        const { x, y } = blobApi.current.getCurrentPosition()

        console.log('the blob is at position', { x, y })

      }

    }, 2000)



    return () => clearInterval(interval)

  }, [])



  return (

    <Canvas>

      <ambientLight intensity={0.8} />

      <pointLight intensity={1} position={[0, 6, 0]} />

      <MyScene ref={blobApi} />

    </Canvas>

  )

}

Troubleshooting
Experiencing Jank?

Whilst jank in react-three-fiber cannot be purely blamed on react-spring you might find toward the end of an animation that there's a subtle jump, which is visible in this demo. It's not pretty, is it?

Whilst by default it would be nice to have this issue resolved without you having to interact and this is something we'll consider for the next breaking change in the meantime what you can use is the precision config prop to avoid this.

import { useSpring } from '@react-spring/three'



export default function MyComponent() {

  const [springs, api] = useSpring(() => ({

    position: [0, 0, 0],

    config: {

      precision: 0.0001,

    },

  }))



  // ...

}


By setting the prop to a value like 0.0001 you can notice there is no jump towards 0. This is because the precision prop is used to figure out how close the animated value can get to the end goal before we consider the animated value to be equal to the end goal.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/common/configs#configs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Config Visualizer
Easings
Reference
Pitfalls
Spring Configs

Part of a component's configuration argument, the config prop is an object with many properties that can be used to customize & fine tune your animations. It directly controls how your springs behave and can customized on a spring by spring basis (e.g. opacity and scale could be different for one useSpring hook).

Usage
Basic Usage

Your most typical usage of the config prop is to edit the mass, friction and tension properties.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  return <animated.div style={springs} />

}

Config per SpringValue

The config prop can also be a function where the argument is the key of the spring value, this is great if you want one spring to control many elements or have properties behave in different ways like a smooth opacity change but a bouncy scale.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      backgroundColor: '#00ff00',

      y: 0,

      config: key => {

        if (key === 'y') {

          return {

            mass: 5,

            friction: 120,

            tension: 120,

          }

        }



        return {}

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


Returning an empty object will enforce the default config options: { mass: 1, tension: 170, friction: 26 }.

Partial Updates

When using the spring api you can partially update your configs. These partial configs are merged with the original config for each call of the api.

import { useSpring, animated } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        mass: 5,

        friction: 120,

        tension: 120,

      },

    }),

    []

  )



  const handleClick = () => {

    api.start({

      y: 20,

      config: {

        friction: 10,

      },

    })

  }



  return <animated.div onClick={handleClick} style={springs} />

}

Presets

Additionally to being able to configure your own spring, we export a small selection of presets enclosed in the config named export.

import { config } from '@react-spring/web'


The presets are:

default ‚Äì
{ tension: 170, friction: 26 }
gentle ‚Äì
{ tension: 120, friction: 14 }
wobbly ‚Äì
{ tension: 180, friction: 12 }
stiff ‚Äì
{ tension: 210, friction: 20 }
slow ‚Äì
{ tension: 280, friction: 60 }
molasses ‚Äì
{ tension: 280, friction: 120 }
Config Visualizer
Easings

Easings can only be used in conjunction with the duration property.

Why Springs?

We think of animation in terms of time and curves, but that causes most of the struggle we face when trying to make elements on the screen move naturally, because nothing in the real world moves like that. Springs don‚Äôt have a defined curve or a set duration.

As Andy Matuschak (ex Apple UI-Kit developer) expressed ‚Äì ‚ÄúAnimation APIs parameterized by duration and curve are fundamentally opposed to continuous, fluid interactivity.‚Äù

Available generic easings

All the following easings are part of the easings object imported like so:

import { easings } from '@react-spring/web'


easeInBack	easeOutBack	easeInOutBack
easeInBounce	easeOutBounce	easeOutBounce
easeInCirc	easeOutCirc	easeOutCirc
easeInCubic	easeOutCubic	easeOutCubic
easeInElastic	easeOutElastic	easeOutElastic
easeInExpo	easeOutExpo	easeOutExpo
easeInQuad	easeOutQuad	easeOutQuad
easeInQuart	easeOutQuart	easeOutQuart
easeInQuint	easeOutQuint	easeOutQuint
easeInSine	easeOutSine	easeOutSine
Steps easing

This unique easing function returns the standard EasingFunction a config object expects. Its still part of the easings object but you need to set it up before passing.

import { easings } from '@react-spring/web'



const MyComponent = () => {

  const [springs, api] = useSpring(

    () => ({

      y: 0,

      config: {

        easing: easings.steps(5),

      },

    }),

    []

  )



  return <animated.div style={springs} />

}


It can also take a Direction as a second argument, which can be either start or end. The signature for the function is shown below:

export function steps(

  steps: number,

  direction: Direction = 'end'

): EasingFunction

Reference
Prop	Type	Default
mass	number
tension	number
friction	number
bounce
	number
clamp
	boolean
precision
	number
round
	boolean
frequency
	number
damping
	number
velocity	number
restVelocity
	number
decay	number | boolean

duration
	number
easing	function

progress
	number
Pitfalls
My animation jumps at the end.

In some instances such as animating threejs the items can feel as if they skip the last couple of frames. This is because the precision prop has a default value of 0.01. Try editing this value to be 0.0001 to resolve this.

My animation is bouncing and I just want it to stop.

Sometimes you want a snapping feel so you create a sharp spring. When you animate the spring the animation bounces around, this is because of the physics. An easy solution to this is to set clamp to true. Your spring will stop animating at the point it hit's it's goal value.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#introduction

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#example

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#skipping-animations

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#fake-timers

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#troubleshooting

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#testing

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/guides/testing#esm-modules-not-handled-by-jest

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Introduction
Example
Skipping Animations
Fake Timers
Troubleshooting
Testing
Note

All the examples in this guide are using jest as the testing framework & react-testing-library. If you wish to see these examples using other testing frameworks or perhaps there are caveats that are specific to another testing framework, please open an issue or a PR.

Introduction

In this guide, we'll go through testing a basic component that uses useSpring and animated from the library:

const FadeIn = ({ isVisible, children }) => {

  const styles = useSpring({

    opacity: isVisible ? 1 : 0,

    y: isVisible ? 0 : 24,

  })



  return <animated.div style={styles}>{children}</animated.div>

}


Our component takes two props, children & more importantly, isVisible. When isVisible is true, we want to fade in the component and when it's false, we want to fade it out. We could test the y position of the element, but for the purposes of this guide, we'll focus on the opacity.

So, let's start by writing a test for this component.

Example
import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')

})


This initial test is pretty simple, we're just rendering the component and asserting that the opacity is 0 when the component is initially mounted, and by all means it will be pass. Now we want to look at testing that the opacity of element changes when the isVisible prop changes. So we modify our test to look like this:

import { render, screen } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  expect(element).toHaveStyle('opacity: 1')

})


This test will fail with an error that will look something like this:

expect(element).toHaveStyle()



- Expected



- opacity: 1;

+ opacity: 0;



  21 |   rerender(<FadeIn isVisible>Hello!</FadeIn>);

> 23 |   expect(element).toHaveStyle("opacity: 1");

  24 | });


And if you're familiar with how jest works you won't be surprised by this error. The problem is that useSpring animates values, that is the value isn't set immediately, but rather it's changed over time. So, we could wait for the animation to become what we expect by using waitFor:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring } from '@react-spring/web'



import { FadeIn } from './FadeIn'



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


And this would pass, but now we're waiting for the animation to change and update and this adds more time to your tests, time that's a bit unnecessary because we're not interested in the visual effects in this scenario, we want to know the updates are correctly made.

Skipping Animations

The solution to this problem is to skip animations when testing. This can be done by using the Globals object and calling the assign method setting skipAnimations to true. You can do this immediately in the setup file for your tests or if you want more granual control then you could use the beforeAll | beforeEach hooks to set it.

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  await waitFor(() => {

    expect(element).toHaveStyle('opacity: 1')

  })

})


This would then set the opacity immediate to 1 and the test would pass. However, we still are required to use waitFor because the update requires a tick of the environment to reflect the changes.

Fake Timers

Alternatively, if you want to keep your code simpler by avoiding an async call for waitFor you could opt to use jest.useFakeTimers and manually advance the environment:

import { render, screen, waitFor } from '@testing-library/react'

import { animated, useSpring, Globals } from '@react-spring/web'



import { FadeIn } from './FadeIn'



beforeAll(() => {

  Globals.assign({

    skipAnimation: true,

  })



  jest.useFakeTimers()

})



test('Correctly renders the FadeIn component', async () => {

  const { rerender } = render(<FadeIn>Hello!</FadeIn>)



  const element = screen.getByText('Hello!')



  expect(element).toHaveStyle('opacity: 0')



  rerender(<FadeIn isVisible>Hello!</FadeIn>)



  jest.advanceTimersByTime(1)



  expect(element).toHaveStyle('opacity: 1')

})

Troubleshooting
ESM modules not handled by jest
path/to/project/node_modules/@react-spring/web/react-spring-web.esm.js.js:1

    ({"Object.<anonymous>":function(module,exports,require,dirname,filename,global,jest){import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';


You may have come across this message when testing with jest. If you have, this is because jest is incorrectly resolving the correct file type for the library. It in fact wants to be using the cjs file type. To fix this, you can add the following to your jest.config.js file:

module.exports = {

  moduleNameMapper: {

    '@react-spring/web':

      '<rootDir>/node_modules/@react-spring/web/react-spring-web.cjs.js',

  },

}


This could be applicable to any target you're using e.g. @react-spring/native.

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect#why-do-we-need-this

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect#what-does-it-do

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-isomorphic-layout-effect#useisomorphiclayouteffect

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Why do we need this?
What does it do?
Typescript
useIsomorphicLayoutEffect
Usage
import { animated, useSpring, useIsomorphicLayoutEffect } from '@react-spring/web'



const MyComponent = ({position}) => {

    const [springs, api] = useSpring(() => {

        y: 0,

        x: 0,

    }, [])



    useIsomorphicLayoutEffect(() => {

        api.start({

            from: {

                x: 0,

                y: 0,

            },

            to: {

                x: position.x,

                y: position.y,

            }

        })

    },[position])



    return <animated.div style={springs} />

}

Why do we need this?

When we want to perform side-effects caused by rendering a component we need to use useEffect or useLayoutEffect. Now, the latter, useLayoutEffect in our opinion, is better for animations because it renders "before the browser has a chance to paint", therefore if you want to prepare a node e.g. a div for animation before actually animating it, it's probably better to ensure no paint happens, otherwise you might get a sort of UI tear where the item suddenly jumps to a new position.

Neither of the above effect hooks run on the server, however, useLayoutEffect causes react warnings when server-side rendering your pages (if you're using nextjs for example). So it encourages you to move the code to useEffect. However, as we described above this isn't best for animations.

What does it do?

This is where our useIsomorphicLayoutEffect utility hook comes in. By performing a simple (yet robust) check, the hook correctly returns useEffect for server-side environments and useLayoutEffect for client-side environments, thus the best of both worlds in this case.

Typescript

The type signature will be identical to the signatures of useEffect and useLayoutEffect installed in your project, but just to save you time, it's here below:

function useIsomorphicLayoutEffect(effect: () => (void | () => void), deps?: ReadonlyArray<unknown>)

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion#stopping-animations

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion#why-is-it-important

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-reduced-motion#usereducedmotion

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Stopping animations
Why is it important?
Typescript
useReducedMotion

A utility hook designed to stop the running of animations in react-spring through determining whether a user prefers reduced motion.

Usage

To get the most out of this hook, I recommend that you call it in the root of your app. However, you may need to directly know the preference to synchronize a third-party system e.g. autoplaying a video.

import { useReducedMotion } from '@react-spring/web'



export default function MyApp() {

  const reducedMotion = useReducedMotion()



  return (

    <main>

      <h1>Hello World</h1>

      {reducedMotion ? <p>You're using reduced motion!</p> : null}

    </main>

  )

}

Stopping animations

So how does this hook have the ability to stop all animations? react-spring has a Globals object, these global objects are used for to synchronize hooks across your application. One property that can be set is called skipAnimation. This property is a boolean and is checked by either the Controller or SpringValue to see if it should animate. If skipAnimation is set to true then the animation will "jump" to the goal value, similar to if the immediate prop is true.

The animation below has it's skipAnimation set to true so it will instantly jump to the goal value, check the code to learn more.

Show Code
import { useRef, useEffect } from 'react'

import { useSpring, animated, Globals } from '@react-spring/web'



export default function MyApp() {

  const isRight = useRef(false)



  const [springs, api] = useSpring(

    () => ({

      x: 0,

    }),

    []

  )



  const handleClick = () => {

    api.start({

      x: isRight.current ? 0 : 200,

      onRest: () => {

        isRight.current = !isRight.current

      },

    })

  }



  useEffect(() => {

    Globals.assign({

      skipAnimation: true,

    })



    return () => {

      Globals.assign({

        skipAnimation: false,

      })

    }

  })



  return (

    <animated.div onClick={handleClick} className="spring-box" style={springs}>

      Click me!

    </animated.div>

  )

}

Why is it important?

Vestibular dysfunction, a balance disorder of the inner ear, is surprisingly common among US adults. A study from the early 2000's found that approximately 69 million Americans had vestibular dysfunction which results in vertigo, nausea, migraines and hearing loss. Many people affected by vestibular dysfunction will choose to set the "Reduce motion" setting in their operating system.

Typescript
function useReducedMotion(): boolean

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-scroll#usescroll

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
Examples
useScroll

A small utility abstraction around our signature useSpring hook. It's a great way to create a scroll-linked animation. With either the raw value of distance or a 0-1 progress value. You can either use the scroll values of the whole document, or just a specific element.

Usage

The example below will start off with an opacity of 0 but when the user scrolls to the bottom of the page it will have reached an opacity of 1.

import { useScroll, animated } from '@react-spring/web'



function MyComponent() {

  const { scrollYProgress } = useScroll()



  return (

    <animated.div style={{ opacity: scrollYProgress }}>

      Hello World

    </animated.div>

  )

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useScroll(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Examples
Scrolling Wave
React to scroll progress and values to create exciting landing pages
events
interpolation
useSpring
useScroll

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-resize#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
useResize

A small abstraction around the useSpring hook. It returns a SpringValues object with the width and height of the element it's attached to & doesn't necessarily have to be attached to the window, by passing a container you can observe that element's size instead.

Usage
import { useResize, animated } from '@react-spring/web'



function MyComponent() {

  const { width, height } = useResize()



  return <animated.div style={{ width, height }}>Hello World</animated.div>

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement | null | undefined>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useResize(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-resize#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
useResize

A small abstraction around the useSpring hook. It returns a SpringValues object with the width and height of the element it's attached to & doesn't necessarily have to be attached to the window, by passing a container you can observe that element's size instead.

Usage
import { useResize, animated } from '@react-spring/web'



function MyComponent() {

  const { width, height } = useResize()



  return <animated.div style={{ width, height }}>Hello World</animated.div>

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement | null | undefined>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useResize(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-resize#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
useResize

A small abstraction around the useSpring hook. It returns a SpringValues object with the width and height of the element it's attached to & doesn't necessarily have to be attached to the window, by passing a container you can observe that element's size instead.

Usage
import { useResize, animated } from '@react-spring/web'



function MyComponent() {

  const { width, height } = useResize()



  return <animated.div style={{ width, height }}>Hello World</animated.div>

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement | null | undefined>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useResize(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-resize#useresize

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
Reference
Typescript
useResize

A small abstraction around the useSpring hook. It returns a SpringValues object with the width and height of the element it's attached to & doesn't necessarily have to be attached to the window, by passing a container you can observe that element's size instead.

Usage
import { useResize, animated } from '@react-spring/web'



function MyComponent() {

  const { width, height } = useResize()



  return <animated.div style={{ width, height }}>Hello World</animated.div>

}

Reference
Prop	Type	Default
container	React.MutableRefObject<HTMLElement | null | undefined>
delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
ref
	SpringRef
config
	object | function

events
	function
Typescript
function useResize(configuration: ConfigObject): SpringValues


Where ConfigObject is described above

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#usage

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#references

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#typescript

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#examples

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#useinview

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#passing-nothing-or-an-object

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#passing-a-function

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#intersectionargs

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#springprops

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/utilities/use-in-view#reference

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Usage
References
Typescript
Examples
useInView

A helpful utility hook tracking the visibility of an element in the viewport. Using the native IntersectionObserver, you can respond either to a boolean signifying that the element has "intersected" or instead pass it a function returning SpringValues to animate the element upon intersection.

Usage
Passing nothing or an object

Not passing a function as the first argument the hook therefore assumes you're passing arguments to intialize the IntersectionObserver. If you do pass a function, this argument becomes the second expected (see below).

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, inView] = useInView()



  return <animated.div ref={ref}>{inView ? 'Hello World' : null}</animated.div>

}

Passing a function
Warning

You must use the to and from prop to define your animation when returning it from the function. Passing regular props that typically "become" SpringValues will not work.

import { useInView, animated } from '@react-spring/web'



function MyComponent() {

  const [ref, springs] = useInView(

    () => ({

      from: {

        opacity: 0,

        y: 100,

      },

      to: {

        opacity: 1,

        y: 0,

      },

    }),

    {

      rootMargin: '-40% 0%',

    }

  )



  return (

    <animated.div ref={ref} style={springs}>

      Hello World

    </animated.div>

  )

}

References
IntersectionArgs

The below table describes the IntersectionArgs object the hook accepts.

Prop	Type	Default
amount	"any" | "all" | number | number[]
root	React.MutableRefObject
rootMargin	string
once	boolean
SpringProps

The reference below describes the return value of the optional function argument.

Prop	Type	Default
from	object
to
	object | object[] | function

loop	boolean | object | function

delay
	number | function

immediate
	boolean | function

reset
	boolean
reverse
	boolean
pause
	boolean
cancel	boolean | string | string[] | function

config
	object | function

events
	function
Typescript
interface IntersectionArgs

  extends Omit<IntersectionObserverInit, 'root' | 'threshold'> {

  root?: React.MutableRefObject<HTMLElement>

  once?: boolean

  amount?: 'any' | 'all' | number | number[]

}



function useInView(

  args?: IntersectionArgs

): [ref: RefObject<any>, isInView: boolean]



function useInView<Props extends object>(

  props: () => Props & Valid<Props, UseSpringProps<Props>>,

  args?: IntersectionArgs

): [ref: RefObject<any>, springs: SpringValues]


Where ConfigObject is described above

Examples
Popup Modal
Animate on intersections with the viewport
windows95
useSpring
styled-components
useInview

Can't find what you're looking for? Check out all our examples!

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#animationprops

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#controllerupdate

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#lookup

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#oneormore

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#unknownprops

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

# https://react-spring.dev/docs/typescript#typescript-glossary

Enable light mode
Enable dark mode
Search
K
Overview
Getting started
Concepts
Animated Elements
Controllers & Springs
Imperative API
Targets
Components
useSpring
useSprings
useSpringValue
New
useTransition
useChain
useTrail
Parallax
Parallax Layer
Advanced API
Spring Configs
Events
Controller
SpringValue
SpringRef
Interpolation
Async Animations
Guides
React Three Fiber
Testing
Utilities
useIsomorphicLayout
useReducedMotion
useScroll
New
useResize
New
useInView
New
Typescript
Changelog
Animation
AnimationProps
ControllerUpdate
Lookup
OneOrMore
SpringUpdate
SpringValues
TransitionState
UnknownProps
Typescript Glossary
Animation

An animation being executed by the frameloop. Normally found attached to a SpringValue.

class Animation<T = any> {

  changed: boolean

  values: readonly AnimatedValue[]

  toValues: readonly number[] | null

  fromValues: readonly number[]

  to: T | FluidValue<T>

  from: T | FluidValue<T>

  config: AnimationConfig

  immediate: boolean

}

AnimationProps

Most of the reserved animation props, except to, from, loop, and the event props.

interface AnimationProps<T = any> {

  config?: SpringConfig | ((key: StringKeys<T>) => SpringConfig)

  delay?: number | ((key: StringKeys<T>) => number)

  immediate?: MatchProp<T>

  cancel?: MatchProp<T>

  pause?: MatchProp<T>

  reset?: MatchProp<T>

  reverse?: boolean

  default?: boolean | SpringProps<T>

}

ControllerUpdate

A value that any SpringValue or Controller can animate to.

export declare type ControllerUpdate<
  State extends Lookup = Lookup,
  Item = undefined,
> = unknown & ToProps<State> & ControllerProps<State, Item>

Lookup

Lookup is typically inferred, so you probably won't need to use it. It's primarily used to infer the animatable properties from our hooks, e.g. opacity

interface Lookup<T = any> {

  [key: string]: T

}

OneOrMore
export type OneOrMore<T> = T | readonly T[]

SpringUpdate

The props of a useSpring call or its async update function. The T parameter can be a set of animated values (as an object type) or a primitive type for a single animated value.

type SpringUpdate<T = any> = ToProps<T> & SpringProps<T>

type SpringsUpdate<State extends Lookup = UnknownProps> =

  | OneOrMore<ControllerUpdate<State>>

  | ((index: number, ctrl: Controller<State>) => ControllerUpdate<State> | null)

SpringValues

SpringValues is contextual to the values you pass to your hook e.g. opacity. It's type signature is quite complicated, so it's easier to show how you use it.

type MySpringValues = SpringValues<{

  opacity: number

  y: string

}>

TransitionState

TransitionState is the internal state attached to a particular Item (a single datum from the data array you pass).

interface TransitionState<Item = any, State extends Lookup = Lookup> {

  key: any

  item: Item

  ctrl: Controller<State>

  phase: TransitionPhase

  expired?: boolean

  expirationId?: number

}

UnknownProps

Intersected with other object types to allow for unknown properties.

export interface UnknownProps extends Lookup<unknown> {}

Found this helpful?
Edit this page

Designed & built by Josh. Powered by ‚Äì Vercel, Remix, Algolia, Plausible, Vanilla Extract & more...

¬© 2025 react-spring

---

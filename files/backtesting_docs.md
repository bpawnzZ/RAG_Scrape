# https://kernc.github.io/backtesting.py/doc/

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Strategies%20Library.html

	
Library of Composable Base Strategies

This tutorial will show how to reuse composable base trading strategies that are part of backtesting.py software distribution. It is, henceforth, assumed you're already familiar with basic package usage.

We'll extend the same moving average cross-over strategy as in Quick Start User Guide, but we'll rewrite it as a vectorized signal strategy and add trailing stop-loss.

Again, we'll use our helper moving average function.

In [1]:	
from backtesting.test import SMA

	
BokehJS 3.6.2 successfully loaded.
	
	

Part of this software distribution is backtesting.lib module that contains various reusable utilities for strategy development. Some of those utilities are composable base strategies we can extend and build upon.

We import and extend two of those strategies here:

SignalStrategy which decides upon a single signal vector whether to buy into a position, akin to vectorized backtesting engines, and
TrailingStrategy which automatically trails the current price with a stop-loss order some multiple of average true range (ATR) away.
In [2]:	
import pandas as pd
from backtesting.lib import SignalStrategy, TrailingStrategy


class SmaCross(SignalStrategy,
               TrailingStrategy):
    n1 = 10
    n2 = 25
    
    def init(self):
        # In init() and in next() it is important to call the
        # super method to properly initialize the parent classes
        super().init()
        
        # Precompute the two moving averages
        sma1 = self.I(SMA, self.data.Close, self.n1)
        sma2 = self.I(SMA, self.data.Close, self.n2)
        
        # Where sma1 crosses sma2 upwards. Diff gives us [-1,0, *1*]
        signal = (pd.Series(sma1) > sma2).astype(int).diff().fillna(0)
        signal = signal.replace(-1, 0)  # Upwards/long only
        
        # Use 95% of available liquidity (at the time) on each order.
        # (Leaving a value of 1. would instead buy a single share.)
        entry_size = signal * .95
                
        # Set order entry sizes using the method provided by 
        # `SignalStrategy`. See the docs.
        self.set_signal(entry_size=entry_size)
        
        # Set trailing stop-loss to 2x ATR using
        # the method provided by `TrailingStrategy`
        self.set_trailing_sl(2)

	

Note, since the strategies in lib may require their own intialization and next-tick logic, be sure to always call super().init() and super().next() in your overridden methods.

Let's see how the example strategy fares on historical Google data.

In [3]:	
from backtesting import Backtest
from backtesting.test import GOOG

bt = Backtest(GOOG, SmaCross, commission=.002)

bt.run()
bt.plot()

	
	
Out[3]:	
GridPlot(	id = 'p1386', …)
	

Notice how managing risk with a trailing stop-loss secures our gains and limits our losses.

For other strategies of the sort, and other reusable utilities in general, see backtesting.lib module reference.

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Multiple%20Time%20Frames.html

	
Multiple Time Frames

Best trading strategies that rely on technical analysis might take into account price action on multiple time frames. This tutorial will show how to do that with backtesting.py, offloading most of the work to pandas resampling. It is assumed you're already familiar with basic framework usage.

We will put to the test this long-only, supposed 400%-a-year trading strategy, which uses daily and weekly relative strength index (RSI) values and moving averages (MA).

In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy, but among us, let's introduce the two indicators we'll be using.

In [1]:	
import pandas as pd


def SMA(array, n):
    """Simple moving average"""
    return pd.Series(array).rolling(n).mean()


def RSI(array, n):
    """Relative strength index"""
    # Approximate; good enough
    gain = pd.Series(array).diff()
    loss = gain.copy()
    gain[gain < 0] = 0
    loss[loss > 0] = 0
    rs = gain.ewm(n).mean() / loss.abs().ewm(n).mean()
    return 100 - 100 / (1 + rs)

	

The strategy roughly goes like this:

Buy a position when:

weekly RSI(30) 
≥
≥
 daily RSI(30) 
>
>
 70
Close 
>
>
 MA(10) 
>
>
 MA(20) 
>
>
 MA(50) 
>
>
 MA(100)

Close the position when:

Daily close is more than 2% below MA(10)
8% fixed stop loss is hit

We need to provide bars data in the lowest time frame (i.e. daily) and resample it to any higher time frame (i.e. weekly) that our strategy requires.

In [2]:	
from backtesting import Strategy, Backtest
from backtesting.lib import resample_apply


class System(Strategy):
    d_rsi = 30  # Daily RSI lookback periods
    w_rsi = 30  # Weekly
    level = 70
    
    def init(self):
        # Compute moving averages the strategy demands
        self.ma10 = self.I(SMA, self.data.Close, 10)
        self.ma20 = self.I(SMA, self.data.Close, 20)
        self.ma50 = self.I(SMA, self.data.Close, 50)
        self.ma100 = self.I(SMA, self.data.Close, 100)
        
        # Compute daily RSI(30)
        self.daily_rsi = self.I(RSI, self.data.Close, self.d_rsi)
        
        # To construct weekly RSI, we can use `resample_apply()`
        # helper function from the library
        self.weekly_rsi = resample_apply(
            'W-FRI', RSI, self.data.Close, self.w_rsi)
        
        
    def next(self):
        price = self.data.Close[-1]
        
        # If we don't already have a position, and
        # if all conditions are satisfied, enter long.
        if (not self.position and
            self.daily_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.daily_rsi[-1] and
            self.ma10[-1] > self.ma20[-1] > self.ma50[-1] > self.ma100[-1] and
            price > self.ma10[-1]):
            
            # Buy at market price on next open, but do
            # set 8% fixed stop loss.
            self.buy(sl=.92 * price)
        
        # If the price closes 2% or more below 10-day MA
        # close the position, if any.
        elif price < .98 * self.ma10[-1]:
            self.position.close()

	
BokehJS 3.6.2 successfully loaded.
	
	

Let's see how our strategy fares replayed on nine years of Google stock data.

In [3]:	
from backtesting.test import GOOG

backtest = Backtest(GOOG, System, commission=.002)
backtest.run()

Out[3]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                        2.79
Equity Final [$]                      9939.03
Equity Peak [$]                      10940.25
Commissions [$]                        156.64
Return [%]                              -0.61
Buy & Hold Return [%]                  313.30
Return (Ann.) [%]                       -0.07
Volatility (Ann.) [%]                    4.95
CAGR [%]                                -0.05
Sharpe Ratio                            -0.01
Sortino Ratio                           -0.02
Calmar Ratio                            -0.01
Max. Drawdown [%]                      -10.23
Avg. Drawdown [%]                       -9.54
Max. Drawdown Duration     2653 days 00:00:00
Avg. Drawdown Duration     1410 days 00:00:00
# Trades                                    4
Win Rate [%]                            25.00
Best Trade [%]                           9.91
Worst Trade [%]                         -4.27
Avg. Trade [%]                           0.28
Max. Trade Duration          35 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            1.21
Expectancy [%]                           0.43
SQN                                      0.08
Kelly Criterion                          0.03
_strategy                              System
_equity_curve                          Equ...
_trades                      Size  EntryBa...
dtype: object
	

Meager four trades in the span of nine years and with zero return? How about if we optimize the parameters a bit?

In [4]:	
%%time

backtest.optimize(d_rsi=range(10, 35, 5),
                  w_rsi=range(10, 35, 5),
                  level=range(30, 80, 10))

	
CPU times: user 8 s, sys: 405 ms, total: 8.41 s
Wall time: 7.98 s

Out[4]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       21.55
Equity Final [$]                     21903.22
Equity Peak [$]                      22500.98
Commissions [$]                       1343.28
Return [%]                             119.03
Buy & Hold Return [%]                  313.30
Return (Ann.) [%]                        9.63
Volatility (Ann.) [%]                   13.10
CAGR [%]                                 6.55
Sharpe Ratio                             0.74
Sortino Ratio                            1.23
Calmar Ratio                             0.48
Max. Drawdown [%]                      -19.93
Avg. Drawdown [%]                       -3.88
Max. Drawdown Duration      779 days 00:00:00
Avg. Drawdown Duration       97 days 00:00:00
# Trades                                   22
Win Rate [%]                            68.18
Best Trade [%]                          25.28
Worst Trade [%]                         -6.11
Avg. Trade [%]                           3.80
Max. Trade Duration          63 days 00:00:00
Avg. Trade Duration          30 days 00:00:00
Profit Factor                            5.22
Expectancy [%]                           4.08
SQN                                      2.53
Kelly Criterion                          0.54
_strategy                 System(d_rsi=30,...
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
In [5]:	
backtest.plot()

	
	
Out[5]:	
GridPlot(	id = 'p1455', …)
	

Better. While the strategy doesn't perform as well as simple buy & hold, it does so with significantly lower exposure (time in market).

In conclusion, to test strategies on multiple time frames, you need to pass in OHLC data in the lowest time frame, then resample it to higher time frames, apply the indicators, then resample back to the lower time frame, filling in the in-betweens. Which is what the function backtesting.lib.resample_apply() does for you.

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Parameter%20Heatmap%20&%20Optimization.html

	
Parameter Heatmap

This tutorial will show how to optimize strategies with multiple parameters and how to examine and reason about optimization results. It is assumed you're already familiar with basic backtesting.py usage.

First, let's again import our helper moving average function. In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy.

In [1]:	
from backtesting.test import SMA

	
BokehJS 3.6.2 successfully loaded.
	
	

Our strategy will be a similar moving average cross-over strategy to the one in Quick Start User Guide, but we will use four moving averages in total: two moving averages whose relationship determines a general trend (we only trade long when the shorter MA is above the longer one, and vice versa), and two moving averages whose cross-over with daily close prices determine the signal to enter or exit the position.

In [2]:	
from backtesting import Strategy
from backtesting.lib import crossover


class Sma4Cross(Strategy):
    n1 = 50
    n2 = 100
    n_enter = 20
    n_exit = 10
    
    def init(self):
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
        self.sma_enter = self.I(SMA, self.data.Close, self.n_enter)
        self.sma_exit = self.I(SMA, self.data.Close, self.n_exit)
        
    def next(self):
        
        if not self.position:
            
            # On upwards trend, if price closes above
            # "entry" MA, go long
            
            # Here, even though the operands are arrays, this
            # works by implicitly comparing the two last values
            if self.sma1 > self.sma2:
                if crossover(self.data.Close, self.sma_enter):
                    self.buy()
                    
            # On downwards trend, if price closes below
            # "entry" MA, go short
            
            else:
                if crossover(self.sma_enter, self.data.Close):
                    self.sell()
        
        # But if we already hold a position and the price
        # closes back below (above) "exit" MA, close the position
        
        else:
            if (self.position.is_long and
                crossover(self.sma_exit, self.data.Close)
                or
                self.position.is_short and
                crossover(self.data.Close, self.sma_exit)):
                
                self.position.close()

	

It's not a robust strategy, but we can optimize it.

Grid search is an exhaustive search through a set of specified sets of values of hyperparameters. One evaluates the performance for each set of parameters and finally selects the combination that performs best.

Let's optimize our strategy on Google stock data using randomized grid search over the parameter space, evaluating at most (approximately) 200 randomly chosen combinations:

In [3]:	
%%time 

from backtesting import Backtest
from backtesting.test import GOOG


backtest = Backtest(GOOG, Sma4Cross, commission=.002)

stats, heatmap = backtest.optimize(
    n1=range(10, 110, 10),
    n2=range(20, 210, 20),
    n_enter=range(15, 35, 5),
    n_exit=range(10, 25, 5),
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    max_tries=200,
    random_state=0,
    return_heatmap=True)

	
CPU times: user 12 s, sys: 1.6 s, total: 13.6 s
Wall time: 11.9 s

	

Notice return_heatmap=True parameter passed to Backtest.optimize(). It makes the function return a heatmap series along with the usual stats of the best run. heatmap is a pandas Series indexed with a MultiIndex, a cartesian product of all permissible (tried) parameter values. The series values are from the maximize= argument we provided.

In [4]:	
heatmap

Out[4]:	
n1   n2   n_enter  n_exit
20   60   15       10        8448.64
     80   15       10        8348.38
     100  15       10        9283.02
30   40   20       15       10331.51
          25       15       14441.14
                              ...   
100  200  15       10       10994.65
          20       10        9736.19
                   15       14234.93
          25       10        7732.77
          30       10        8806.70
Name: Equity Final [$], Length: 177, dtype: float64
	

This heatmap contains the results of all the runs, making it very easy to obtain parameter combinations for e.g. three best runs:

In [5]:	
heatmap.sort_values().iloc[-3:]

Out[5]:	
n1   n2   n_enter  n_exit
40   60   25       20       15618.15
100  160  20       15       16600.30
50   160  20       15       17149.91
Name: Equity Final [$], dtype: float64
	

But we use vision to make judgements on larger data sets much faster. Let's plot the whole heatmap by projecting it on two chosen dimensions. Say we're mostly interested in how parameters n1 and n2, on average, affect the outcome.

In [6]:	
hm = heatmap.groupby(['n1', 'n2']).mean().unstack()
hm = hm[::-1]
hm

Out[6]:	
n2	40	60	80	100	120	140	160	180	200
n1									
100	NaN	NaN	NaN	NaN	9694.92	6494.40	10063.31	9010.02	10301.05
90	NaN	NaN	NaN	8275.00	8427.48	8540.80	8771.71	9646.89	7884.19
80	NaN	NaN	NaN	9477.03	6846.68	8042.73	7919.79	9096.51	7900.53
70	NaN	NaN	12498.79	6417.25	9069.63	9034.70	7384.79	8576.84	8286.39
60	NaN	NaN	8027.70	7129.25	9436.62	11145.88	9273.17	8484.34	8491.34
50	NaN	7501.19	8909.36	9270.71	8017.69	12118.29	11939.28	10091.10	8868.40
40	NaN	12103.34	NaN	6930.31	9295.27	11125.64	9847.44	9538.79	9331.12
30	12386.32	10224.44	10360.19	13537.82	11160.57	9967.15	9841.65	9882.30	9331.49
20	NaN	8448.64	8348.38	9283.02	NaN	NaN	NaN	NaN	NaN
	

Let's plot this table as a heatmap:

In [7]:	
%matplotlib inline

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
im = ax.imshow(hm, cmap='viridis')
_ = (
    ax.set_xticks(range(len(hm.columns)), labels=hm.columns),
    ax.set_yticks(range(len(hm)), labels=hm.index),
    ax.set_xlabel('n2'),
    ax.set_ylabel('n1'),
    ax.figure.colorbar(im, ax=ax),
)

	
	

We see that, on average, we obtain the highest result using trend-determining parameters n1=30 and n2=100 or n1=70 and n2=80, and it's not like other nearby combinations work similarly well — for our particular strategy, these combinations really stand out.

Since our strategy contains several parameters, we might be interested in other relationships between their values. We can use backtesting.lib.plot_heatmaps() function to plot interactive heatmaps of all parameter combinations simultaneously.

In [8]:	
from backtesting.lib import plot_heatmaps


plot_heatmaps(heatmap, agg='mean')

	
	
Out[8]:	
GridPlot(	id = 'p1288', …)
	
Model-based optimization

Above, we used randomized grid search optimization method. Any kind of grid search, however, might be computationally expensive for large data sets. In the follwing example, we will use SAMBO Optimization package to guide our optimization better informed using forests of decision trees. The hyperparameter model is sequentially improved by evaluating the expensive function (the backtest) at the next best point, thereby hopefully converging to a set of optimal parameters with as few evaluations as possible.

So, with method="sambo":

In [9]:	
%%capture

! pip install sambo  # This is a run-time dependency

In [10]:	
#%%time

stats, heatmap, optimize_result = backtest.optimize(
    n1=[10, 100],      # Note: For method="sambo", we
    n2=[20, 200],      # only need interval end-points
    n_enter=[10, 40],
    n_exit=[10, 30],
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    method='sambo',
    max_tries=40,
    random_state=0,
    return_heatmap=True,
    return_optimization=True)

In [11]:	
heatmap.sort_values().iloc[-3:]

Out[11]:	
n1   n2   n_enter  n_exit
100  129  40       30       29628.09
54   84   38       25       37542.84
59   91   40       30       42416.82
Name: Equity Final [$], dtype: float64
	

Notice how the optimization runs somewhat slower even though max_tries= is lower. This is due to the sequential nature of the algorithm and should actually perform quite comparably even in cases of much larger parameter spaces where grid search would effectively blow up, likely reaching a better optimum than a simple randomized search would. A note of warning, again, to take steps to avoid overfitting insofar as possible.

Understanding the impact of each parameter on the computed objective function is easy in two dimensions, but as the number of dimensions grows, partial dependency plots are increasingly useful. Plotting tools from SAMBO take care of the more mundane things needed to make good and informative plots of the parameter space.

Note, because SAMBO internally only does minimization, the values in optimize_result are negated (less is better).

In [12]:	
from sambo.plot import plot_objective

names = ['n1', 'n2', 'n_enter', 'n_exit']
_ = plot_objective(optimize_result, names=names, estimator='et')

	
In [13]:	
from sambo.plot import plot_evaluations

_ = plot_evaluations(optimize_result, names=names)

	
	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Trading%20with%20Machine%20Learning.html

	
Trading with Machine Learning Models

This tutorial will show how to train and backtest a machine learning price forecast model with backtesting.py framework. It is assumed you're already familiar with basic framework usage and machine learning in general.

For this tutorial, we'll use almost a year's worth sample of hourly EUR/USD forex data:

In [1]:	
from backtesting.test import EURUSD, SMA

data = EURUSD.copy()
data

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2017-04-19 09:00:00	1.07	1.07	1.07	1.07	1413
2017-04-19 10:00:00	1.07	1.07	1.07	1.07	1241
2017-04-19 11:00:00	1.07	1.07	1.07	1.07	1025
2017-04-19 12:00:00	1.07	1.07	1.07	1.07	1460
2017-04-19 13:00:00	1.07	1.07	1.07	1.07	1554
...	...	...	...	...	...
2018-02-07 11:00:00	1.23	1.24	1.23	1.24	2203
2018-02-07 12:00:00	1.24	1.24	1.23	1.23	2325
2018-02-07 13:00:00	1.23	1.23	1.23	1.23	2824
2018-02-07 14:00:00	1.23	1.23	1.23	1.23	4065
2018-02-07 15:00:00	1.23	1.23	1.23	1.23	6143

5000 rows × 5 columns

	

In supervised machine learning, we try to learn a function that maps input feature vectors (independent variables) into known output values (dependent variable):

f
:
X
→
y
𝑓
:
𝑋
→
𝑦

That way, provided our model function is sufficient, we can predict future output values from the newly acquired input feature vectors to some degree of certainty. In our example, we'll try to map several price-derived features and common technical indicators to the price point two days in the future. We construct model design matrix 
X
𝑋
 below:

In [2]:	
def BBANDS(data, n_lookback, n_std):
    """Bollinger bands indicator"""
    hlc3 = (data.High + data.Low + data.Close) / 3
    mean, std = hlc3.rolling(n_lookback).mean(), hlc3.rolling(n_lookback).std()
    upper = mean + n_std*std
    lower = mean - n_std*std
    return upper, lower


close = data.Close.values
sma10 = SMA(data.Close, 10)
sma20 = SMA(data.Close, 20)
sma50 = SMA(data.Close, 50)
sma100 = SMA(data.Close, 100)
upper, lower = BBANDS(data, 20, 2)

# Design matrix / independent features:

# Price-derived features
data['X_SMA10'] = (close - sma10) / close
data['X_SMA20'] = (close - sma20) / close
data['X_SMA50'] = (close - sma50) / close
data['X_SMA100'] = (close - sma100) / close

data['X_DELTA_SMA10'] = (sma10 - sma20) / close
data['X_DELTA_SMA20'] = (sma20 - sma50) / close
data['X_DELTA_SMA50'] = (sma50 - sma100) / close

# Indicator features
data['X_MOM'] = data.Close.pct_change(periods=2)
data['X_BB_upper'] = (upper - close) / close
data['X_BB_lower'] = (lower - close) / close
data['X_BB_width'] = (upper - lower) / close
data['X_Sentiment'] = ~data.index.to_series().between('2017-09-27', '2017-12-14')

# Some datetime features for good measure
data['X_day'] = data.index.dayofweek
data['X_hour'] = data.index.hour

data = data.dropna().astype(float)

	

Since all our indicators work only with past values, we can safely precompute the design matrix in advance. Alternatively, we would reconstruct the matrix every time before training the model.

Notice the made-up sentiment feature. In real life, one would obtain similar features by parsing news sources, Twitter sentiment, Stocktwits or similar. This is just to show input data can contain all sorts of additional explanatory columns.

As mentioned, our dependent variable will be the price (return) two days in the future, simplified into values 
1
1
 when the return is positive (and significant), 
−
1
−
1
 when negative, or 
0
0
 when the return after two days is roughly around zero. Let's write some functions that return our model matrix 
X
𝑋
 and dependent, class variable 
y
𝑦
 as plain NumPy arrays:

In [3]:	
import numpy as np


def get_X(data):
    """Return model design matrix X"""
    return data.filter(like='X').values


def get_y(data):
    """Return dependent variable y"""
    y = data.Close.pct_change(48).shift(-48)  # Returns after roughly two days
    y[y.between(-.004, .004)] = 0             # Devalue returns smaller than 0.4%
    y[y > 0] = 1
    y[y < 0] = -1
    return y


def get_clean_Xy(df):
    """Return (X, y) cleaned of NaN values"""
    X = get_X(df)
    y = get_y(df).values
    isnan = np.isnan(y)
    X = X[~isnan]
    y = y[~isnan]
    return X, y

	

Let's see how our data performs modeled using a simple k-nearest neighbors (kNN) algorithm from the state of the art scikit-learn Python machine learning package. To avoid (or at least demonstrate) overfitting, always split your data into train and test sets; in particular, don't validate your model performance on the same data it was built on.

In [4]:	
import pandas as pd
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split

X, y = get_clean_Xy(data)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)

clf = KNeighborsClassifier(7)  # Model the output based on 7 "nearest" examples
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

_ = pd.DataFrame({'y_true': y_test, 'y_pred': y_pred}).plot(figsize=(15, 2), alpha=.7)
print('Classification accuracy: ', np.mean(y_test == y_pred))

	
Classification accuracy:  0.4210960032962505

	
	

We see the forecasts are all over the place (classification accuracy 42%), but is the model of any use under real backtesting?

Let's backtest a simple strategy that buys the asset for 20% of available equity with 20:1 leverage whenever the forecast is positive (the price in two days is predicted to go up), and sells under the same terms when the forecast is negative, all the while setting reasonable stop-loss and take-profit levels. Notice also the steady use of data.df accessor:

In [5]:	
%%time

from backtesting import Backtest, Strategy

N_TRAIN = 400


class MLTrainOnceStrategy(Strategy):
    price_delta = .004  # 0.4%

    def init(self):        
        # Init our model, a kNN classifier
        self.clf = KNeighborsClassifier(7)

        # Train the classifier in advance on the first N_TRAIN examples
        df = self.data.df.iloc[:N_TRAIN]
        X, y = get_clean_Xy(df)
        self.clf.fit(X, y)

        # Plot y for inspection
        self.I(get_y, self.data.df, name='y_true')

        # Prepare empty, all-NaN forecast indicator
        self.forecasts = self.I(lambda: np.repeat(np.nan, len(self.data)), name='forecast')

    def next(self):
        # Skip the training, in-sample data
        if len(self.data) < N_TRAIN:
            return

        # Proceed only with out-of-sample data. Prepare some variables
        high, low, close = self.data.High, self.data.Low, self.data.Close
        current_time = self.data.index[-1]

        # Forecast the next movement
        X = get_X(self.data.df.iloc[-1:])
        forecast = self.clf.predict(X)[0]

        # Update the plotted "forecast" indicator
        self.forecasts[-1] = forecast

        # If our forecast is upwards and we don't already hold a long position
        # place a long order for 20% of available account equity. Vice versa for short.
        # Also set target take-profit and stop-loss prices to be one price_delta
        # away from the current closing price.
        upper, lower = close[-1] * (1 + np.r_[1, -1]*self.price_delta)

        if forecast == 1 and not self.position.is_long:
            self.buy(size=.2, tp=upper, sl=lower)
        elif forecast == -1 and not self.position.is_short:
            self.sell(size=.2, tp=lower, sl=upper)

        # Additionally, set aggressive stop-loss on trades that have been open 
        # for more than two days
        for trade in self.trades:
            if current_time - trade.entry_time > pd.Timedelta('2 days'):
                if trade.is_long:
                    trade.sl = max(trade.sl, low)
                else:
                    trade.sl = min(trade.sl, high)


bt = Backtest(data, MLTrainOnceStrategy, commission=.0002, margin=.05)
bt.run()

	
CPU times: user 7.02 s, sys: 33.5 ms, total: 7.05 s
Wall time: 7.03 s

Out[5]:	
Start                     2017-04-25 12:00:00
End                       2018-02-07 15:00:00
Duration                    288 days 03:00:00
Exposure Time [%]                       79.41
Equity Final [$]                     11604.83
Equity Peak [$]                      12291.70
Commissions [$]                       4124.66
Return [%]                              16.05
Buy & Hold Return [%]                   10.12
Return (Ann.) [%]                       16.47
Volatility (Ann.) [%]                   22.02
CAGR [%]                                13.90
Sharpe Ratio                             0.75
Sortino Ratio                            1.28
Calmar Ratio                             1.44
Max. Drawdown [%]                      -11.44
Avg. Drawdown [%]                       -1.45
Max. Drawdown Duration       84 days 22:00:00
Avg. Drawdown Duration        5 days 08:00:00
# Trades                                  353
Win Rate [%]                            55.81
Best Trade [%]                           0.60
Worst Trade [%]                         -0.50
Avg. Trade [%]                           0.04
Max. Trade Duration           3 days 09:00:00
Avg. Trade Duration           0 days 19:00:00
Profit Factor                            1.43
Expectancy [%]                           0.04
SQN                                      2.84
Kelly Criterion                          0.18
_strategy                 MLTrainOnceStrategy
_equity_curve                             ...
_trades                         Size  Entr...
dtype: object
In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1414', …)
	

Despite our lousy win rate, the strategy seems profitable. Let's see how it performs under walk-forward optimization, akin to k-fold or leave-one-out cross-validation:

In [7]:	
%%time

class MLWalkForwardStrategy(MLTrainOnceStrategy):
    def next(self):
        # Skip the cold start period with too few values available
        if len(self.data) < N_TRAIN:
            return

        # Re-train the model only every 20 iterations.
        # Since 20 << N_TRAIN, we don't lose much in terms of
        # "recent training examples", but the speed-up is significant!
        if len(self.data) % 20:
            return super().next()

        # Retrain on last N_TRAIN values
        df = self.data.df[-N_TRAIN:]
        X, y = get_clean_Xy(df)
        self.clf.fit(X, y)

        # Now that the model is fitted, 
        # proceed the same as in MLTrainOnceStrategy
        super().next()


bt = Backtest(data, MLWalkForwardStrategy, commission=.0002, margin=.05)
bt.run()

	
CPU times: user 7.72 s, sys: 23 ms, total: 7.74 s
Wall time: 7.73 s

Out[7]:	
Start                     2017-04-25 12:00:00
End                       2018-02-07 15:00:00
Duration                    288 days 03:00:00
Exposure Time [%]                       71.72
Equity Final [$]                      4872.10
Equity Peak [$]                      10052.11
Commissions [$]                       2686.43
Return [%]                             -51.28
Buy & Hold Return [%]                   10.12
Return (Ann.) [%]                      -52.13
Volatility (Ann.) [%]                    8.94
CAGR [%]                               -46.68
Sharpe Ratio                            -5.83
Sortino Ratio                           -3.28
Calmar Ratio                            -1.01
Max. Drawdown [%]                      -51.53
Avg. Drawdown [%]                      -51.53
Max. Drawdown Duration      265 days 00:00:00
Avg. Drawdown Duration      265 days 00:00:00
# Trades                                  324
Win Rate [%]                            46.91
Best Trade [%]                           0.40
Worst Trade [%]                         -0.49
Avg. Trade [%]                          -0.03
Max. Trade Duration           3 days 07:00:00
Avg. Trade Duration           0 days 18:00:00
Profit Factor                            0.79
Expectancy [%]                          -0.03
SQN                                     -1.81
Kelly Criterion                         -0.15
_strategy                 MLWalkForwardStr...
_equity_curve                             ...
_trades                         Size  Entr...
dtype: object
In [8]:	
bt.plot()

	
	
Out[8]:	
GridPlot(	id = 'p1860', …)
	

Apparently, when repeatedly retrained on past N_TRAIN data points in a rolling manner, our basic model generalizes poorly and performs not quite as well.

This was a simple and contrived, tongue-in-cheek example that shows one way to use machine learning forecast models with backtesting.py framework. In reality, you will need a far better feature space, better models (cf. deep learning), and better money management strategies to achieve consistent profits in automated short-term forex trading. More proper data science is an exercise for the keen reader.

Some instant optimization tips that come to mind are:

Data is king. Make sure your design matrix features as best as possible model and correlate with your chosen target variable(s) and not just represent random noise.
Instead of modelling a single target variable 
y
𝑦
, model a multitude of target/class variables, possibly better designed than our "48-hour returns" above.
Model everything: forecast price, volume, time before it "takes off", SL/TP levels, optimal position size ...
Reduce false positives by increasing the conviction needed and imposing extra domain expertise and discretionary limitations before entering trades.

Also make sure to familiarize yourself with the full Backtesting.py API reference

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/

Backtesting.py
Backtest trading strategies in Python

Does it seem like you had missed getting rich during the recent crypto craze? Despair not—the international financial markets continue their move rightwards every day. You still have your chance. But successful traders all agree emotions have no place in trading — if you are ever to enjoy a fortune attained by trading, better first make sure your strategy or system is well-tested and working reliably toward consistent profits. Mechanical or algorithmic trading, they call it. They'll usually recommend signing up with a broker and trading on a demo account for a few months … But you know better. You know some programming.

It is far better to foresee even without certainty than not to foresee at all.

— Henri Poincare

Backtesting.py is a Python framework for inferring viability of trading strategies on historical (past) data. Of course, past performance is not indicative of future results, but a strategy that proves itself resilient in a multitude of market conditions can, with a little luck, remain just as reliable in the future. Improved upon the vision of Backtrader, and by all means surpassingly comparable to other accessible alternatives, Backtesting.py is lightweight, fast, user-friendly, intuitive, interactive, intelligent and, hopefully, future-proof. It is also documented well, including a handful of tutorials.

Compatible with forex, crypto, stocks, futures ...

Backtest any financial instrument for which you have access to historical candlestick data.

Blazing fast, convenient

Built on top of cutting-edge ecosystem libraries (i.e. Pandas, NumPy, Bokeh) for maximum speed and ergonomics.

Small, clean API

The API reference is easy to wrap your head around and fits on a single page.

Technical indicator library agnostic

Compatible with any sensible technical analysis library, such as TA-Lib, Tulip, pandas-ta ...

Built-in SAMBO optimizer

Test hundreds of strategy variants in mere seconds, resulting in heatmaps you can interpret at a glance.

High-level API

Think market timing, swing trading, money management, stop-loss and take-profit prices, leverage, machine learning ...

Interactive visualization

Simulated trading results in telling interactive charts you can zoom into. See Example.

Vectorized or event-based backtesting

Signal-driven or streaming, model your strategy enjoying the flexibility of both approaches.

Composable strategies

Contains a library of predefined utilities and general-purpose strategies that are made to stack.

Download
PyPI
GitHub
Docs

🛈 Backtesting.py works with Python 3. You need to know some Python to effectively use this software.

Example

The example shows a simple, unoptimized moving average cross-over strategy. It's a common introductory strategy and a pretty decent strategy overall, provided the market isn't whipsawing sideways.

We begin with 10,000 units of currency in cash, realistic 0.2% broker commission, and we trade through 9 years worth of Alphabet Inc. stock.

Whenever the fast, 10-period simple moving average of closing prices crosses above the slower, 20-period moving average, we go long, buying as many stocks as we can afford. When it crosses below, we close our long position and go short (assuming the underlying instrument is actually a CFD and can be shorted).

We record most significant statistics this simple system produces on our data, and we show a plot for further manual inspection.

from backtesting import Backtest, Strategy
from backtesting.lib import crossover

from backtesting.test import SMA, GOOG


class SmaCross(Strategy):
    n1 = 10
    n2 = 20

    def init(self):
        close = self.data.Close
        self.sma1 = self.I(SMA, close, self.n1)
        self.sma2 = self.I(SMA, close, self.n2)

    def next(self):
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()


bt = Backtest(GOOG, SmaCross,
              cash=10000, commission=.002,
              exclusive_orders=True)

output = bt.run()
bt.plot()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    94.27374
Equity Final [$]                     81812.37
Equity Peak [$]                      81879.03
Return [%]                           718.1237
Buy & Hold Return [%]               607.37036
Return (Ann.) [%]                    27.96479
Volatility (Ann.) [%]                39.08925
CAGR [%]                             18.52838
Sharpe Ratio                          0.71541
Sortino Ratio                         1.43503
Calmar Ratio                          0.85275
Max. Drawdown [%]                   -32.79366
Avg. Drawdown [%]                    -5.24919
Max. Drawdown Duration      680 days 00:00:00
Avg. Drawdown Duration       38 days 00:00:00
# Trades                                   93
Win Rate [%]                         54.83871
Best Trade [%]                       57.43355
Worst Trade [%]                     -16.39664
Avg. Trade [%]                        2.16381
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                         2.27119
Expectancy [%]                        2.69468
SQN                                   1.94546
Kelly Criterion                       0.25935
_strategy              SmaCross(n1=10, n2=20)

Find better examples, including executable Jupyter
notebooks, in the project documentation.

Documentation
What Users are Saying

 The proof of [this] program's value is its existence.

Alan Perlis

Some things are so unexpected that no one is prepared for them.

Leo Rosten

[...] When all else fails, read the instructions.

Cahn

The financial markets generally are unpredictable. So that one has to have different scenarios … The idea that you can actually predict what's going to happen contradicts my way of looking at the market.

George Soros

If you don’t find a way to make money while you sleep, you will work until you die.

Warren Buffet

卐

A good forecaster is not smarter than everyone else, he merely has his ignorance better organised.

卍

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#manuals

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#tutorials

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#example-strategies

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#faq

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#license

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#api-reference-documentation

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/#header-submodules

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Backtesting.py-Quick-Start-User-Guide

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Data

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Strategy

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.init

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.next

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Backtest

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Backtest.__init__

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.data

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.I

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.crossover

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Backtesting

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Backtest.run

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Backtest.plot

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Optimization

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Backtest.optimize

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html#Trade-data

	
Backtesting.py Quick Start User Guide

This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.

Backtesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.

Data

You bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns 'Open', 'High', 'Low', 'Close' and (optionally) 'Volume'. Such data is widely obtainable, e.g. with packages:

pandas-datareader,
Quandl,
findatapy,
yFinance,
investpy, etc.

Besides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.

DataFrame should ideally be indexed with a datetime index (convert it with pd.to_datetime()); otherwise a simple range index will do.

In [1]:	
# Example OHLC daily data for Google Inc.
from backtesting.test import GOOG

GOOG.tail()

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2013-02-25	802.30	808.41	790.49	790.77	2303900
2013-02-26	795.00	795.95	784.40	790.13	2202500
2013-02-27	794.80	804.75	791.11	799.78	2026100
2013-02-28	801.10	806.99	801.03	801.20	2265800
2013-03-01	797.80	807.14	796.15	806.19	2175400
	
Strategy

Let's create our first strategy to backtest on these Google data, a simple moving average (MA) cross-over strategy.

Backtesting.py doesn't ship its own set of technical analysis indicators. Users favoring TA should probably refer to functions from proven indicator libraries, such as TA-Lib or Tulipy, but for this example, we can define a simple helper moving average function ourselves:

In [2]:	
import pandas as pd


def SMA(values, n):
    """
    Return simple moving average of `values`, at
    each step taking into account `n` previous values.
    """
    return pd.Series(values).rolling(n).mean()

	

A new strategy needs to extend Strategy class and override its two abstract methods: init() and next().

Method init() is invoked before the strategy is run. Within it, one ideally precomputes in efficient, vectorized manner whatever indicators and signals the strategy depends on.

Method next() is then iteratively called by the Backtest instance, once for each data point (data frame row), simulating the incremental availability of each new full candlestick bar.

Note, backtesting.py cannot make decisions / trades within candlesticks — any new orders are executed on the next candle's open (or the current candle's close if trade_on_close=True). If you find yourself wishing to trade within candlesticks (e.g. daytrading), you instead need to begin with more fine-grained (e.g. hourly) data.

In [3]:	
from backtesting import Strategy
from backtesting.lib import crossover


class SmaCross(Strategy):
    # Define the two MA lags as *class variables*
    # for later optimization
    n1 = 10
    n2 = 20
    
    def init(self):
        # Precompute the two moving averages
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
    
    def next(self):
        # If sma1 crosses above sma2, close any existing
        # short trades, and buy the asset
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()

        # Else, if sma1 crosses below sma2, close any existing
        # long trades, and sell the asset
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()

	

In init() as well as in next(), the data the strategy is simulated on is available as an instance variable self.data.

In init(), we declare and compute indicators indirectly by wrapping them in self.I(). The wrapper is passed a function (our SMA function) along with any arguments to call it with (our close values and the MA lag). Indicators wrapped in this way will be automatically plotted, and their legend strings will be intelligently inferred.

In next(), we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so Backtesting.py assumes maximal possible position. We use backtesting.lib.crossover() function instead of writing more obscure and confusing conditions, such as:

In [4]:	
%%script echo

    def next(self):
        if (self.sma1[-2] < self.sma2[-2] and
                self.sma1[-1] > self.sma2[-1]):
            self.position.close()
            self.buy()

        elif (self.sma1[-2] > self.sma2[-2] and    # Ugh!
              self.sma1[-1] < self.sma2[-1]):
            self.position.close()
            self.sell()

	
	

In init(), the whole series of points was available, whereas in next(), the length of self.data and all declared indicators is adjusted on each next() call so that array[-1] (e.g. self.data.Close[-1] or self.sma1[-1]) always contains the most recent value, array[-2] the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).

Note: self.data and any indicators wrapped with self.I (e.g. self.sma1) are NumPy arrays for performance reasons. If you prefer pandas Series or DataFrame objects, use Strategy.data.<column>.s or Strategy.data.df accessors respectively. You could also construct the series manually, e.g. pd.Series(self.data.Close, index=self.data.index).

We might avoid self.position.close() calls if we primed the Backtest instance with Backtest(..., exclusive_orders=True).

	
Backtesting

Let's see how our strategy performs on historical Google data. The Backtest instance is initialized with OHLC data and a strategy class (see API reference for additional options), and we begin with 10,000 units of cash and set broker's commission to realistic 0.2%.

In [5]:	
from backtesting import Backtest

bt = Backtest(GOOG, SmaCross, cash=10_000, commission=.002)
stats = bt.run()
stats

Out[5]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       94.27
Equity Final [$]                     56263.52
Equity Peak [$]                      56309.06
Commissions [$]                      10563.95
Return [%]                             462.64
Buy & Hold Return [%]                  607.37
Return (Ann.) [%]                       22.47
Volatility (Ann.) [%]                   37.41
CAGR [%]                                14.99
Sharpe Ratio                             0.60
Sortino Ratio                            1.14
Calmar Ratio                             0.66
Max. Drawdown [%]                      -33.93
Avg. Drawdown [%]                       -6.16
Max. Drawdown Duration      830 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                   93
Win Rate [%]                            54.84
Best Trade [%]                          57.43
Worst Trade [%]                        -16.40
Avg. Trade [%]                           2.16
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                            2.27
Expectancy [%]                           2.69
SQN                                      2.01
Kelly Criterion                          0.26
_strategy                            SmaCross
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
	

Backtest.run() method returns a pandas Series of simulation results and statistics associated with our strategy. We see that this simple strategy makes almost 600% return in the period of 9 years, with maximum drawdown 33%, and with longest drawdown period spanning almost two years ...

Backtest.plot() method provides the same insights in a more visual form.

In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1338', …)
	
Optimization

We hard-coded the two lag parameters (n1 and n2) into our strategy above. However, the strategy may work better with 15–30 or some other cross-over. We declared the parameters as optimizable by making them class variables.

We optimize the two parameters by calling Backtest.optimize() method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter n1 is tested for values in range between 5 and 30 and parameter n2 for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. n1 should not be larger than or equal to n2. We limit admissible parameter combinations with an ad hoc constraint function, which takes in the parameters and returns True (i.e. admissible) whenever n1 is less than n2. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned stats series.

In [7]:	
%%time

stats = bt.optimize(n1=range(5, 30, 5),
                    n2=range(10, 70, 5),
                    maximize='Equity Final [$]',
                    constraint=lambda param: param.n1 < param.n2)
stats

	
CPU times: user 2.56 s, sys: 102 ms, total: 2.66 s
Wall time: 2.56 s

Out[7]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       98.14
Equity Final [$]                     77829.05
Equity Peak [$]                      84982.19
Commissions [$]                      30771.04
Return [%]                             678.29
Buy & Hold Return [%]                  687.99
Return (Ann.) [%]                       27.22
Volatility (Ann.) [%]                   43.21
CAGR [%]                                18.05
Sharpe Ratio                             0.63
Sortino Ratio                            1.28
Calmar Ratio                             0.61
Max. Drawdown [%]                      -44.55
Avg. Drawdown [%]                       -5.81
Max. Drawdown Duration     1558 days 00:00:00
Avg. Drawdown Duration       50 days 00:00:00
# Trades                                  152
Win Rate [%]                            53.29
Best Trade [%]                          61.89
Worst Trade [%]                        -19.54
Avg. Trade [%]                           1.72
Max. Trade Duration          83 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            2.12
Expectancy [%]                           2.16
SQN                                      1.92
Kelly Criterion                          0.20
_strategy                 SmaCross(n1=10,n...
_equity_curve                          Equ...
_trades                        Size  Entry...
dtype: object
	

We can look into stats['_strategy'] to access the Strategy instance and its optimal parameter values (10 and 15).

In [8]:	
stats._strategy

Out[8]:	
<Strategy SmaCross(n1=10,n2=15)>
In [9]:	
bt.plot(plot_volume=False, plot_pl=False)

	
	
Out[9]:	
GridPlot(	id = 'p1601', …)
	

Strategy optimization managed to up its initial performance on in-sample data by almost 50% and even beat simple buy & hold. In real life optimization, however, do take steps to avoid overfitting.

	
Trade data

In addition to backtest statistics returned by Backtest.run() shown above, you can look into individual trade returns and the changing equity curve and drawdown by inspecting the last few, internal keys in the result series.

In [10]:	
stats.tail()

Out[10]:	
SQN                                                             1.92
Kelly Criterion                                                 0.20
_strategy                                      SmaCross(n1=10,n2=15)
_equity_curve                   Equity  DrawdownPct DrawdownDurat...
_trades                 Size  EntryBar  ExitBar  EntryPrice  Exit...
dtype: object
	

The columns should be self-explanatory.

In [11]:	
stats['_equity_curve']  # Contains equity/drawdown curves. DrawdownDuration is only defined at ends of DD periods.

Out[11]:	
	Equity	DrawdownPct	DrawdownDuration
2004-08-19	10000.00	0.00	NaT
2004-08-20	10000.00	0.00	NaT
2004-08-23	10000.00	0.00	NaT
2004-08-24	10000.00	0.00	NaT
2004-08-25	10000.00	0.00	NaT
...	...	...	...
2013-02-25	76348.73	0.10	NaT
2013-02-26	76287.29	0.10	NaT
2013-02-27	77213.69	0.09	NaT
2013-02-28	77350.01	0.09	NaT
2013-03-01	77829.05	0.08	1558 days

2148 rows × 3 columns

In [12]:	
stats['_trades']  # Contains individual trade data

Out[12]:	
	Size	EntryBar	ExitBar	EntryPrice	ExitPrice	SL	TP	PnL	ReturnPct	EntryTime	ExitTime	Duration	Tag	Entry_SMA(C,10)	Exit_SMA(C,10)	Entry_SMA(C,15)	Exit_SMA(C,15)
0	87	20	60	114.42	185.23	None	None	6160.47	0.62	2004-09-17	2004-11-12	56 days	None	107.40	181.07	105.75	183.32
1	-86	60	69	185.23	175.80	None	None	810.98	0.05	2004-11-12	2004-11-26	14 days	None	181.07	173.56	183.32	173.14
2	95	69	71	175.80	180.71	None	None	466.45	0.03	2004-11-26	2004-11-30	4 days	None	173.56	173.18	173.14	174.55
3	-95	71	75	180.71	179.13	None	None	150.10	0.01	2004-11-30	2004-12-06	6 days	None	173.18	176.58	174.55	175.51
4	96	75	82	179.13	177.99	None	None	-109.44	-0.01	2004-12-06	2004-12-15	9 days	None	176.58	175.15	175.51	176.58
...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...	...
147	-90	2056	2085	740.13	687.78	None	None	4711.50	0.07	2012-10-16	2012-11-29	44 days	None	752.66	667.39	753.99	664.45
148	104	2085	2111	687.78	735.54	None	None	4967.04	0.07	2012-11-29	2013-01-08	40 days	None	667.39	718.50	664.45	719.00
149	-103	2111	2113	735.54	742.83	None	None	-750.87	-0.01	2013-01-08	2013-01-10	2 days	None	718.50	724.62	719.00	721.51
150	101	2113	2121	742.83	735.99	None	None	-690.84	-0.01	2013-01-10	2013-01-23	13 days	None	724.62	724.32	721.51	726.41
151	-100	2121	2127	735.99	750.51	None	None	-1452.00	-0.02	2013-01-23	2013-01-31	8 days	None	724.32	738.20	726.41	735.12

152 rows × 17 columns

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#tutorials

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#header-submodules

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Strategies%20Library.html#Library-of-Composable-Base-Strategies

	
Library of Composable Base Strategies

This tutorial will show how to reuse composable base trading strategies that are part of backtesting.py software distribution. It is, henceforth, assumed you're already familiar with basic package usage.

We'll extend the same moving average cross-over strategy as in Quick Start User Guide, but we'll rewrite it as a vectorized signal strategy and add trailing stop-loss.

Again, we'll use our helper moving average function.

In [1]:	
from backtesting.test import SMA

	
BokehJS 3.6.2 successfully loaded.
	
	

Part of this software distribution is backtesting.lib module that contains various reusable utilities for strategy development. Some of those utilities are composable base strategies we can extend and build upon.

We import and extend two of those strategies here:

SignalStrategy which decides upon a single signal vector whether to buy into a position, akin to vectorized backtesting engines, and
TrailingStrategy which automatically trails the current price with a stop-loss order some multiple of average true range (ATR) away.
In [2]:	
import pandas as pd
from backtesting.lib import SignalStrategy, TrailingStrategy


class SmaCross(SignalStrategy,
               TrailingStrategy):
    n1 = 10
    n2 = 25
    
    def init(self):
        # In init() and in next() it is important to call the
        # super method to properly initialize the parent classes
        super().init()
        
        # Precompute the two moving averages
        sma1 = self.I(SMA, self.data.Close, self.n1)
        sma2 = self.I(SMA, self.data.Close, self.n2)
        
        # Where sma1 crosses sma2 upwards. Diff gives us [-1,0, *1*]
        signal = (pd.Series(sma1) > sma2).astype(int).diff().fillna(0)
        signal = signal.replace(-1, 0)  # Upwards/long only
        
        # Use 95% of available liquidity (at the time) on each order.
        # (Leaving a value of 1. would instead buy a single share.)
        entry_size = signal * .95
                
        # Set order entry sizes using the method provided by 
        # `SignalStrategy`. See the docs.
        self.set_signal(entry_size=entry_size)
        
        # Set trailing stop-loss to 2x ATR using
        # the method provided by `TrailingStrategy`
        self.set_trailing_sl(2)

	

Note, since the strategies in lib may require their own intialization and next-tick logic, be sure to always call super().init() and super().next() in your overridden methods.

Let's see how the example strategy fares on historical Google data.

In [3]:	
from backtesting import Backtest
from backtesting.test import GOOG

bt = Backtest(GOOG, SmaCross, commission=.002)

bt.run()
bt.plot()

	
	
Out[3]:	
GridPlot(	id = 'p1386', …)
	

Notice how managing risk with a trailing stop-loss secures our gains and limits our losses.

For other strategies of the sort, and other reusable utilities in general, see backtesting.lib module reference.

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.SignalStrategy

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.TrailingStrategy

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Multiple%20Time%20Frames.html#Multiple-Time-Frames

	
Multiple Time Frames

Best trading strategies that rely on technical analysis might take into account price action on multiple time frames. This tutorial will show how to do that with backtesting.py, offloading most of the work to pandas resampling. It is assumed you're already familiar with basic framework usage.

We will put to the test this long-only, supposed 400%-a-year trading strategy, which uses daily and weekly relative strength index (RSI) values and moving averages (MA).

In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy, but among us, let's introduce the two indicators we'll be using.

In [1]:	
import pandas as pd


def SMA(array, n):
    """Simple moving average"""
    return pd.Series(array).rolling(n).mean()


def RSI(array, n):
    """Relative strength index"""
    # Approximate; good enough
    gain = pd.Series(array).diff()
    loss = gain.copy()
    gain[gain < 0] = 0
    loss[loss > 0] = 0
    rs = gain.ewm(n).mean() / loss.abs().ewm(n).mean()
    return 100 - 100 / (1 + rs)

	

The strategy roughly goes like this:

Buy a position when:

weekly RSI(30) 
≥
≥
 daily RSI(30) 
>
>
 70
Close 
>
>
 MA(10) 
>
>
 MA(20) 
>
>
 MA(50) 
>
>
 MA(100)

Close the position when:

Daily close is more than 2% below MA(10)
8% fixed stop loss is hit

We need to provide bars data in the lowest time frame (i.e. daily) and resample it to any higher time frame (i.e. weekly) that our strategy requires.

In [2]:	
from backtesting import Strategy, Backtest
from backtesting.lib import resample_apply


class System(Strategy):
    d_rsi = 30  # Daily RSI lookback periods
    w_rsi = 30  # Weekly
    level = 70
    
    def init(self):
        # Compute moving averages the strategy demands
        self.ma10 = self.I(SMA, self.data.Close, 10)
        self.ma20 = self.I(SMA, self.data.Close, 20)
        self.ma50 = self.I(SMA, self.data.Close, 50)
        self.ma100 = self.I(SMA, self.data.Close, 100)
        
        # Compute daily RSI(30)
        self.daily_rsi = self.I(RSI, self.data.Close, self.d_rsi)
        
        # To construct weekly RSI, we can use `resample_apply()`
        # helper function from the library
        self.weekly_rsi = resample_apply(
            'W-FRI', RSI, self.data.Close, self.w_rsi)
        
        
    def next(self):
        price = self.data.Close[-1]
        
        # If we don't already have a position, and
        # if all conditions are satisfied, enter long.
        if (not self.position and
            self.daily_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.level and
            self.weekly_rsi[-1] > self.daily_rsi[-1] and
            self.ma10[-1] > self.ma20[-1] > self.ma50[-1] > self.ma100[-1] and
            price > self.ma10[-1]):
            
            # Buy at market price on next open, but do
            # set 8% fixed stop loss.
            self.buy(sl=.92 * price)
        
        # If the price closes 2% or more below 10-day MA
        # close the position, if any.
        elif price < .98 * self.ma10[-1]:
            self.position.close()

	
BokehJS 3.6.2 successfully loaded.
	
	

Let's see how our strategy fares replayed on nine years of Google stock data.

In [3]:	
from backtesting.test import GOOG

backtest = Backtest(GOOG, System, commission=.002)
backtest.run()

Out[3]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                        2.79
Equity Final [$]                      9939.03
Equity Peak [$]                      10940.25
Commissions [$]                        156.64
Return [%]                              -0.61
Buy & Hold Return [%]                  313.30
Return (Ann.) [%]                       -0.07
Volatility (Ann.) [%]                    4.95
CAGR [%]                                -0.05
Sharpe Ratio                            -0.01
Sortino Ratio                           -0.02
Calmar Ratio                            -0.01
Max. Drawdown [%]                      -10.23
Avg. Drawdown [%]                       -9.54
Max. Drawdown Duration     2653 days 00:00:00
Avg. Drawdown Duration     1410 days 00:00:00
# Trades                                    4
Win Rate [%]                            25.00
Best Trade [%]                           9.91
Worst Trade [%]                         -4.27
Avg. Trade [%]                           0.28
Max. Trade Duration          35 days 00:00:00
Avg. Trade Duration          21 days 00:00:00
Profit Factor                            1.21
Expectancy [%]                           0.43
SQN                                      0.08
Kelly Criterion                          0.03
_strategy                              System
_equity_curve                          Equ...
_trades                      Size  EntryBa...
dtype: object
	

Meager four trades in the span of nine years and with zero return? How about if we optimize the parameters a bit?

In [4]:	
%%time

backtest.optimize(d_rsi=range(10, 35, 5),
                  w_rsi=range(10, 35, 5),
                  level=range(30, 80, 10))

	
CPU times: user 8 s, sys: 405 ms, total: 8.41 s
Wall time: 7.98 s

Out[4]:	
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                       21.55
Equity Final [$]                     21903.22
Equity Peak [$]                      22500.98
Commissions [$]                       1343.28
Return [%]                             119.03
Buy & Hold Return [%]                  313.30
Return (Ann.) [%]                        9.63
Volatility (Ann.) [%]                   13.10
CAGR [%]                                 6.55
Sharpe Ratio                             0.74
Sortino Ratio                            1.23
Calmar Ratio                             0.48
Max. Drawdown [%]                      -19.93
Avg. Drawdown [%]                       -3.88
Max. Drawdown Duration      779 days 00:00:00
Avg. Drawdown Duration       97 days 00:00:00
# Trades                                   22
Win Rate [%]                            68.18
Best Trade [%]                          25.28
Worst Trade [%]                         -6.11
Avg. Trade [%]                           3.80
Max. Trade Duration          63 days 00:00:00
Avg. Trade Duration          30 days 00:00:00
Profit Factor                            5.22
Expectancy [%]                           4.08
SQN                                      2.53
Kelly Criterion                          0.54
_strategy                 System(d_rsi=30,...
_equity_curve                          Equ...
_trades                       Size  EntryB...
dtype: object
In [5]:	
backtest.plot()

	
	
Out[5]:	
GridPlot(	id = 'p1455', …)
	

Better. While the strategy doesn't perform as well as simple buy & hold, it does so with significantly lower exposure (time in market).

In conclusion, to test strategies on multiple time frames, you need to pass in OHLC data in the lowest time frame, then resample it to higher time frames, apply the indicators, then resample back to the lower time frame, filling in the in-betweens. Which is what the function backtesting.lib.resample_apply() does for you.

	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.resample_apply

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Parameter%20Heatmap%20&%20Optimization.html#Parameter-Heatmap

	
Parameter Heatmap

This tutorial will show how to optimize strategies with multiple parameters and how to examine and reason about optimization results. It is assumed you're already familiar with basic backtesting.py usage.

First, let's again import our helper moving average function. In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy.

In [1]:	
from backtesting.test import SMA

	
BokehJS 3.6.2 successfully loaded.
	
	

Our strategy will be a similar moving average cross-over strategy to the one in Quick Start User Guide, but we will use four moving averages in total: two moving averages whose relationship determines a general trend (we only trade long when the shorter MA is above the longer one, and vice versa), and two moving averages whose cross-over with daily close prices determine the signal to enter or exit the position.

In [2]:	
from backtesting import Strategy
from backtesting.lib import crossover


class Sma4Cross(Strategy):
    n1 = 50
    n2 = 100
    n_enter = 20
    n_exit = 10
    
    def init(self):
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
        self.sma_enter = self.I(SMA, self.data.Close, self.n_enter)
        self.sma_exit = self.I(SMA, self.data.Close, self.n_exit)
        
    def next(self):
        
        if not self.position:
            
            # On upwards trend, if price closes above
            # "entry" MA, go long
            
            # Here, even though the operands are arrays, this
            # works by implicitly comparing the two last values
            if self.sma1 > self.sma2:
                if crossover(self.data.Close, self.sma_enter):
                    self.buy()
                    
            # On downwards trend, if price closes below
            # "entry" MA, go short
            
            else:
                if crossover(self.sma_enter, self.data.Close):
                    self.sell()
        
        # But if we already hold a position and the price
        # closes back below (above) "exit" MA, close the position
        
        else:
            if (self.position.is_long and
                crossover(self.sma_exit, self.data.Close)
                or
                self.position.is_short and
                crossover(self.data.Close, self.sma_exit)):
                
                self.position.close()

	

It's not a robust strategy, but we can optimize it.

Grid search is an exhaustive search through a set of specified sets of values of hyperparameters. One evaluates the performance for each set of parameters and finally selects the combination that performs best.

Let's optimize our strategy on Google stock data using randomized grid search over the parameter space, evaluating at most (approximately) 200 randomly chosen combinations:

In [3]:	
%%time 

from backtesting import Backtest
from backtesting.test import GOOG


backtest = Backtest(GOOG, Sma4Cross, commission=.002)

stats, heatmap = backtest.optimize(
    n1=range(10, 110, 10),
    n2=range(20, 210, 20),
    n_enter=range(15, 35, 5),
    n_exit=range(10, 25, 5),
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    max_tries=200,
    random_state=0,
    return_heatmap=True)

	
CPU times: user 12 s, sys: 1.6 s, total: 13.6 s
Wall time: 11.9 s

	

Notice return_heatmap=True parameter passed to Backtest.optimize(). It makes the function return a heatmap series along with the usual stats of the best run. heatmap is a pandas Series indexed with a MultiIndex, a cartesian product of all permissible (tried) parameter values. The series values are from the maximize= argument we provided.

In [4]:	
heatmap

Out[4]:	
n1   n2   n_enter  n_exit
20   60   15       10        8448.64
     80   15       10        8348.38
     100  15       10        9283.02
30   40   20       15       10331.51
          25       15       14441.14
                              ...   
100  200  15       10       10994.65
          20       10        9736.19
                   15       14234.93
          25       10        7732.77
          30       10        8806.70
Name: Equity Final [$], Length: 177, dtype: float64
	

This heatmap contains the results of all the runs, making it very easy to obtain parameter combinations for e.g. three best runs:

In [5]:	
heatmap.sort_values().iloc[-3:]

Out[5]:	
n1   n2   n_enter  n_exit
40   60   25       20       15618.15
100  160  20       15       16600.30
50   160  20       15       17149.91
Name: Equity Final [$], dtype: float64
	

But we use vision to make judgements on larger data sets much faster. Let's plot the whole heatmap by projecting it on two chosen dimensions. Say we're mostly interested in how parameters n1 and n2, on average, affect the outcome.

In [6]:	
hm = heatmap.groupby(['n1', 'n2']).mean().unstack()
hm = hm[::-1]
hm

Out[6]:	
n2	40	60	80	100	120	140	160	180	200
n1									
100	NaN	NaN	NaN	NaN	9694.92	6494.40	10063.31	9010.02	10301.05
90	NaN	NaN	NaN	8275.00	8427.48	8540.80	8771.71	9646.89	7884.19
80	NaN	NaN	NaN	9477.03	6846.68	8042.73	7919.79	9096.51	7900.53
70	NaN	NaN	12498.79	6417.25	9069.63	9034.70	7384.79	8576.84	8286.39
60	NaN	NaN	8027.70	7129.25	9436.62	11145.88	9273.17	8484.34	8491.34
50	NaN	7501.19	8909.36	9270.71	8017.69	12118.29	11939.28	10091.10	8868.40
40	NaN	12103.34	NaN	6930.31	9295.27	11125.64	9847.44	9538.79	9331.12
30	12386.32	10224.44	10360.19	13537.82	11160.57	9967.15	9841.65	9882.30	9331.49
20	NaN	8448.64	8348.38	9283.02	NaN	NaN	NaN	NaN	NaN
	

Let's plot this table as a heatmap:

In [7]:	
%matplotlib inline

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
im = ax.imshow(hm, cmap='viridis')
_ = (
    ax.set_xticks(range(len(hm.columns)), labels=hm.columns),
    ax.set_yticks(range(len(hm)), labels=hm.index),
    ax.set_xlabel('n2'),
    ax.set_ylabel('n1'),
    ax.figure.colorbar(im, ax=ax),
)

	
	

We see that, on average, we obtain the highest result using trend-determining parameters n1=30 and n2=100 or n1=70 and n2=80, and it's not like other nearby combinations work similarly well — for our particular strategy, these combinations really stand out.

Since our strategy contains several parameters, we might be interested in other relationships between their values. We can use backtesting.lib.plot_heatmaps() function to plot interactive heatmaps of all parameter combinations simultaneously.

In [8]:	
from backtesting.lib import plot_heatmaps


plot_heatmaps(heatmap, agg='mean')

	
	
Out[8]:	
GridPlot(	id = 'p1288', …)
	
Model-based optimization

Above, we used randomized grid search optimization method. Any kind of grid search, however, might be computationally expensive for large data sets. In the follwing example, we will use SAMBO Optimization package to guide our optimization better informed using forests of decision trees. The hyperparameter model is sequentially improved by evaluating the expensive function (the backtest) at the next best point, thereby hopefully converging to a set of optimal parameters with as few evaluations as possible.

So, with method="sambo":

In [9]:	
%%capture

! pip install sambo  # This is a run-time dependency

In [10]:	
#%%time

stats, heatmap, optimize_result = backtest.optimize(
    n1=[10, 100],      # Note: For method="sambo", we
    n2=[20, 200],      # only need interval end-points
    n_enter=[10, 40],
    n_exit=[10, 30],
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    method='sambo',
    max_tries=40,
    random_state=0,
    return_heatmap=True,
    return_optimization=True)

In [11]:	
heatmap.sort_values().iloc[-3:]

Out[11]:	
n1   n2   n_enter  n_exit
100  129  40       30       29628.09
54   84   38       25       37542.84
59   91   40       30       42416.82
Name: Equity Final [$], dtype: float64
	

Notice how the optimization runs somewhat slower even though max_tries= is lower. This is due to the sequential nature of the algorithm and should actually perform quite comparably even in cases of much larger parameter spaces where grid search would effectively blow up, likely reaching a better optimum than a simple randomized search would. A note of warning, again, to take steps to avoid overfitting insofar as possible.

Understanding the impact of each parameter on the computed objective function is easy in two dimensions, but as the number of dimensions grows, partial dependency plots are increasingly useful. Plotting tools from SAMBO take care of the more mundane things needed to make good and informative plots of the parameter space.

Note, because SAMBO internally only does minimization, the values in optimize_result are negated (less is better).

In [12]:	
from sambo.plot import plot_objective

names = ['n1', 'n2', 'n_enter', 'n_exit']
_ = plot_objective(optimize_result, names=names, estimator='et')

	
In [13]:	
from sambo.plot import plot_evaluations

_ = plot_evaluations(optimize_result, names=names)

	
	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.plot_heatmaps

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/examples/Parameter%20Heatmap%20&%20Optimization.html#Model-based-optimization

	
Parameter Heatmap

This tutorial will show how to optimize strategies with multiple parameters and how to examine and reason about optimization results. It is assumed you're already familiar with basic backtesting.py usage.

First, let's again import our helper moving average function. In practice, one should use functions from an indicator library, such as TA-Lib or Tulipy.

In [1]:	
from backtesting.test import SMA

	
BokehJS 3.6.2 successfully loaded.
	
	

Our strategy will be a similar moving average cross-over strategy to the one in Quick Start User Guide, but we will use four moving averages in total: two moving averages whose relationship determines a general trend (we only trade long when the shorter MA is above the longer one, and vice versa), and two moving averages whose cross-over with daily close prices determine the signal to enter or exit the position.

In [2]:	
from backtesting import Strategy
from backtesting.lib import crossover


class Sma4Cross(Strategy):
    n1 = 50
    n2 = 100
    n_enter = 20
    n_exit = 10
    
    def init(self):
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)
        self.sma_enter = self.I(SMA, self.data.Close, self.n_enter)
        self.sma_exit = self.I(SMA, self.data.Close, self.n_exit)
        
    def next(self):
        
        if not self.position:
            
            # On upwards trend, if price closes above
            # "entry" MA, go long
            
            # Here, even though the operands are arrays, this
            # works by implicitly comparing the two last values
            if self.sma1 > self.sma2:
                if crossover(self.data.Close, self.sma_enter):
                    self.buy()
                    
            # On downwards trend, if price closes below
            # "entry" MA, go short
            
            else:
                if crossover(self.sma_enter, self.data.Close):
                    self.sell()
        
        # But if we already hold a position and the price
        # closes back below (above) "exit" MA, close the position
        
        else:
            if (self.position.is_long and
                crossover(self.sma_exit, self.data.Close)
                or
                self.position.is_short and
                crossover(self.data.Close, self.sma_exit)):
                
                self.position.close()

	

It's not a robust strategy, but we can optimize it.

Grid search is an exhaustive search through a set of specified sets of values of hyperparameters. One evaluates the performance for each set of parameters and finally selects the combination that performs best.

Let's optimize our strategy on Google stock data using randomized grid search over the parameter space, evaluating at most (approximately) 200 randomly chosen combinations:

In [3]:	
%%time 

from backtesting import Backtest
from backtesting.test import GOOG


backtest = Backtest(GOOG, Sma4Cross, commission=.002)

stats, heatmap = backtest.optimize(
    n1=range(10, 110, 10),
    n2=range(20, 210, 20),
    n_enter=range(15, 35, 5),
    n_exit=range(10, 25, 5),
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    max_tries=200,
    random_state=0,
    return_heatmap=True)

	
CPU times: user 12 s, sys: 1.6 s, total: 13.6 s
Wall time: 11.9 s

	

Notice return_heatmap=True parameter passed to Backtest.optimize(). It makes the function return a heatmap series along with the usual stats of the best run. heatmap is a pandas Series indexed with a MultiIndex, a cartesian product of all permissible (tried) parameter values. The series values are from the maximize= argument we provided.

In [4]:	
heatmap

Out[4]:	
n1   n2   n_enter  n_exit
20   60   15       10        8448.64
     80   15       10        8348.38
     100  15       10        9283.02
30   40   20       15       10331.51
          25       15       14441.14
                              ...   
100  200  15       10       10994.65
          20       10        9736.19
                   15       14234.93
          25       10        7732.77
          30       10        8806.70
Name: Equity Final [$], Length: 177, dtype: float64
	

This heatmap contains the results of all the runs, making it very easy to obtain parameter combinations for e.g. three best runs:

In [5]:	
heatmap.sort_values().iloc[-3:]

Out[5]:	
n1   n2   n_enter  n_exit
40   60   25       20       15618.15
100  160  20       15       16600.30
50   160  20       15       17149.91
Name: Equity Final [$], dtype: float64
	

But we use vision to make judgements on larger data sets much faster. Let's plot the whole heatmap by projecting it on two chosen dimensions. Say we're mostly interested in how parameters n1 and n2, on average, affect the outcome.

In [6]:	
hm = heatmap.groupby(['n1', 'n2']).mean().unstack()
hm = hm[::-1]
hm

Out[6]:	
n2	40	60	80	100	120	140	160	180	200
n1									
100	NaN	NaN	NaN	NaN	9694.92	6494.40	10063.31	9010.02	10301.05
90	NaN	NaN	NaN	8275.00	8427.48	8540.80	8771.71	9646.89	7884.19
80	NaN	NaN	NaN	9477.03	6846.68	8042.73	7919.79	9096.51	7900.53
70	NaN	NaN	12498.79	6417.25	9069.63	9034.70	7384.79	8576.84	8286.39
60	NaN	NaN	8027.70	7129.25	9436.62	11145.88	9273.17	8484.34	8491.34
50	NaN	7501.19	8909.36	9270.71	8017.69	12118.29	11939.28	10091.10	8868.40
40	NaN	12103.34	NaN	6930.31	9295.27	11125.64	9847.44	9538.79	9331.12
30	12386.32	10224.44	10360.19	13537.82	11160.57	9967.15	9841.65	9882.30	9331.49
20	NaN	8448.64	8348.38	9283.02	NaN	NaN	NaN	NaN	NaN
	

Let's plot this table as a heatmap:

In [7]:	
%matplotlib inline

import matplotlib.pyplot as plt

fig, ax = plt.subplots()
im = ax.imshow(hm, cmap='viridis')
_ = (
    ax.set_xticks(range(len(hm.columns)), labels=hm.columns),
    ax.set_yticks(range(len(hm)), labels=hm.index),
    ax.set_xlabel('n2'),
    ax.set_ylabel('n1'),
    ax.figure.colorbar(im, ax=ax),
)

	
	

We see that, on average, we obtain the highest result using trend-determining parameters n1=30 and n2=100 or n1=70 and n2=80, and it's not like other nearby combinations work similarly well — for our particular strategy, these combinations really stand out.

Since our strategy contains several parameters, we might be interested in other relationships between their values. We can use backtesting.lib.plot_heatmaps() function to plot interactive heatmaps of all parameter combinations simultaneously.

In [8]:	
from backtesting.lib import plot_heatmaps


plot_heatmaps(heatmap, agg='mean')

	
	
Out[8]:	
GridPlot(	id = 'p1288', …)
	
Model-based optimization

Above, we used randomized grid search optimization method. Any kind of grid search, however, might be computationally expensive for large data sets. In the follwing example, we will use SAMBO Optimization package to guide our optimization better informed using forests of decision trees. The hyperparameter model is sequentially improved by evaluating the expensive function (the backtest) at the next best point, thereby hopefully converging to a set of optimal parameters with as few evaluations as possible.

So, with method="sambo":

In [9]:	
%%capture

! pip install sambo  # This is a run-time dependency

In [10]:	
#%%time

stats, heatmap, optimize_result = backtest.optimize(
    n1=[10, 100],      # Note: For method="sambo", we
    n2=[20, 200],      # only need interval end-points
    n_enter=[10, 40],
    n_exit=[10, 30],
    constraint=lambda p: p.n_exit < p.n_enter < p.n1 < p.n2,
    maximize='Equity Final [$]',
    method='sambo',
    max_tries=40,
    random_state=0,
    return_heatmap=True,
    return_optimization=True)

In [11]:	
heatmap.sort_values().iloc[-3:]

Out[11]:	
n1   n2   n_enter  n_exit
100  129  40       30       29628.09
54   84   38       25       37542.84
59   91   40       30       42416.82
Name: Equity Final [$], dtype: float64
	

Notice how the optimization runs somewhat slower even though max_tries= is lower. This is due to the sequential nature of the algorithm and should actually perform quite comparably even in cases of much larger parameter spaces where grid search would effectively blow up, likely reaching a better optimum than a simple randomized search would. A note of warning, again, to take steps to avoid overfitting insofar as possible.

Understanding the impact of each parameter on the computed objective function is easy in two dimensions, but as the number of dimensions grows, partial dependency plots are increasingly useful. Plotting tools from SAMBO take care of the more mundane things needed to make good and informative plots of the parameter space.

Note, because SAMBO internally only does minimization, the values in optimize_result are negated (less is better).

In [12]:	
from sambo.plot import plot_objective

names = ['n1', 'n2', 'n_enter', 'n_exit']
_ = plot_objective(optimize_result, names=names, estimator='et')

	
In [13]:	
from sambo.plot import plot_evaluations

_ = plot_evaluations(optimize_result, names=names)

	
	

Learn more by exploring further examples or find more framework options in the full API reference.

---

# https://kernc.github.io/backtesting.py/doc/examples/Trading%20with%20Machine%20Learning.html#Trading-with-Machine-Learning-Models

	
Trading with Machine Learning Models

This tutorial will show how to train and backtest a machine learning price forecast model with backtesting.py framework. It is assumed you're already familiar with basic framework usage and machine learning in general.

For this tutorial, we'll use almost a year's worth sample of hourly EUR/USD forex data:

In [1]:	
from backtesting.test import EURUSD, SMA

data = EURUSD.copy()
data

	
BokehJS 3.6.2 successfully loaded.
	
Out[1]:	
	Open	High	Low	Close	Volume
2017-04-19 09:00:00	1.07	1.07	1.07	1.07	1413
2017-04-19 10:00:00	1.07	1.07	1.07	1.07	1241
2017-04-19 11:00:00	1.07	1.07	1.07	1.07	1025
2017-04-19 12:00:00	1.07	1.07	1.07	1.07	1460
2017-04-19 13:00:00	1.07	1.07	1.07	1.07	1554
...	...	...	...	...	...
2018-02-07 11:00:00	1.23	1.24	1.23	1.24	2203
2018-02-07 12:00:00	1.24	1.24	1.23	1.23	2325
2018-02-07 13:00:00	1.23	1.23	1.23	1.23	2824
2018-02-07 14:00:00	1.23	1.23	1.23	1.23	4065
2018-02-07 15:00:00	1.23	1.23	1.23	1.23	6143

5000 rows × 5 columns

	

In supervised machine learning, we try to learn a function that maps input feature vectors (independent variables) into known output values (dependent variable):

f
:
X
→
y
𝑓
:
𝑋
→
𝑦

That way, provided our model function is sufficient, we can predict future output values from the newly acquired input feature vectors to some degree of certainty. In our example, we'll try to map several price-derived features and common technical indicators to the price point two days in the future. We construct model design matrix 
X
𝑋
 below:

In [2]:	
def BBANDS(data, n_lookback, n_std):
    """Bollinger bands indicator"""
    hlc3 = (data.High + data.Low + data.Close) / 3
    mean, std = hlc3.rolling(n_lookback).mean(), hlc3.rolling(n_lookback).std()
    upper = mean + n_std*std
    lower = mean - n_std*std
    return upper, lower


close = data.Close.values
sma10 = SMA(data.Close, 10)
sma20 = SMA(data.Close, 20)
sma50 = SMA(data.Close, 50)
sma100 = SMA(data.Close, 100)
upper, lower = BBANDS(data, 20, 2)

# Design matrix / independent features:

# Price-derived features
data['X_SMA10'] = (close - sma10) / close
data['X_SMA20'] = (close - sma20) / close
data['X_SMA50'] = (close - sma50) / close
data['X_SMA100'] = (close - sma100) / close

data['X_DELTA_SMA10'] = (sma10 - sma20) / close
data['X_DELTA_SMA20'] = (sma20 - sma50) / close
data['X_DELTA_SMA50'] = (sma50 - sma100) / close

# Indicator features
data['X_MOM'] = data.Close.pct_change(periods=2)
data['X_BB_upper'] = (upper - close) / close
data['X_BB_lower'] = (lower - close) / close
data['X_BB_width'] = (upper - lower) / close
data['X_Sentiment'] = ~data.index.to_series().between('2017-09-27', '2017-12-14')

# Some datetime features for good measure
data['X_day'] = data.index.dayofweek
data['X_hour'] = data.index.hour

data = data.dropna().astype(float)

	

Since all our indicators work only with past values, we can safely precompute the design matrix in advance. Alternatively, we would reconstruct the matrix every time before training the model.

Notice the made-up sentiment feature. In real life, one would obtain similar features by parsing news sources, Twitter sentiment, Stocktwits or similar. This is just to show input data can contain all sorts of additional explanatory columns.

As mentioned, our dependent variable will be the price (return) two days in the future, simplified into values 
1
1
 when the return is positive (and significant), 
−
1
−
1
 when negative, or 
0
0
 when the return after two days is roughly around zero. Let's write some functions that return our model matrix 
X
𝑋
 and dependent, class variable 
y
𝑦
 as plain NumPy arrays:

In [3]:	
import numpy as np


def get_X(data):
    """Return model design matrix X"""
    return data.filter(like='X').values


def get_y(data):
    """Return dependent variable y"""
    y = data.Close.pct_change(48).shift(-48)  # Returns after roughly two days
    y[y.between(-.004, .004)] = 0             # Devalue returns smaller than 0.4%
    y[y > 0] = 1
    y[y < 0] = -1
    return y


def get_clean_Xy(df):
    """Return (X, y) cleaned of NaN values"""
    X = get_X(df)
    y = get_y(df).values
    isnan = np.isnan(y)
    X = X[~isnan]
    y = y[~isnan]
    return X, y

	

Let's see how our data performs modeled using a simple k-nearest neighbors (kNN) algorithm from the state of the art scikit-learn Python machine learning package. To avoid (or at least demonstrate) overfitting, always split your data into train and test sets; in particular, don't validate your model performance on the same data it was built on.

In [4]:	
import pandas as pd
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split

X, y = get_clean_Xy(data)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.5, random_state=0)

clf = KNeighborsClassifier(7)  # Model the output based on 7 "nearest" examples
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

_ = pd.DataFrame({'y_true': y_test, 'y_pred': y_pred}).plot(figsize=(15, 2), alpha=.7)
print('Classification accuracy: ', np.mean(y_test == y_pred))

	
Classification accuracy:  0.4210960032962505

	
	

We see the forecasts are all over the place (classification accuracy 42%), but is the model of any use under real backtesting?

Let's backtest a simple strategy that buys the asset for 20% of available equity with 20:1 leverage whenever the forecast is positive (the price in two days is predicted to go up), and sells under the same terms when the forecast is negative, all the while setting reasonable stop-loss and take-profit levels. Notice also the steady use of data.df accessor:

In [5]:	
%%time

from backtesting import Backtest, Strategy

N_TRAIN = 400


class MLTrainOnceStrategy(Strategy):
    price_delta = .004  # 0.4%

    def init(self):        
        # Init our model, a kNN classifier
        self.clf = KNeighborsClassifier(7)

        # Train the classifier in advance on the first N_TRAIN examples
        df = self.data.df.iloc[:N_TRAIN]
        X, y = get_clean_Xy(df)
        self.clf.fit(X, y)

        # Plot y for inspection
        self.I(get_y, self.data.df, name='y_true')

        # Prepare empty, all-NaN forecast indicator
        self.forecasts = self.I(lambda: np.repeat(np.nan, len(self.data)), name='forecast')

    def next(self):
        # Skip the training, in-sample data
        if len(self.data) < N_TRAIN:
            return

        # Proceed only with out-of-sample data. Prepare some variables
        high, low, close = self.data.High, self.data.Low, self.data.Close
        current_time = self.data.index[-1]

        # Forecast the next movement
        X = get_X(self.data.df.iloc[-1:])
        forecast = self.clf.predict(X)[0]

        # Update the plotted "forecast" indicator
        self.forecasts[-1] = forecast

        # If our forecast is upwards and we don't already hold a long position
        # place a long order for 20% of available account equity. Vice versa for short.
        # Also set target take-profit and stop-loss prices to be one price_delta
        # away from the current closing price.
        upper, lower = close[-1] * (1 + np.r_[1, -1]*self.price_delta)

        if forecast == 1 and not self.position.is_long:
            self.buy(size=.2, tp=upper, sl=lower)
        elif forecast == -1 and not self.position.is_short:
            self.sell(size=.2, tp=lower, sl=upper)

        # Additionally, set aggressive stop-loss on trades that have been open 
        # for more than two days
        for trade in self.trades:
            if current_time - trade.entry_time > pd.Timedelta('2 days'):
                if trade.is_long:
                    trade.sl = max(trade.sl, low)
                else:
                    trade.sl = min(trade.sl, high)


bt = Backtest(data, MLTrainOnceStrategy, commission=.0002, margin=.05)
bt.run()

	
CPU times: user 7.02 s, sys: 33.5 ms, total: 7.05 s
Wall time: 7.03 s

Out[5]:	
Start                     2017-04-25 12:00:00
End                       2018-02-07 15:00:00
Duration                    288 days 03:00:00
Exposure Time [%]                       79.41
Equity Final [$]                     11604.83
Equity Peak [$]                      12291.70
Commissions [$]                       4124.66
Return [%]                              16.05
Buy & Hold Return [%]                   10.12
Return (Ann.) [%]                       16.47
Volatility (Ann.) [%]                   22.02
CAGR [%]                                13.90
Sharpe Ratio                             0.75
Sortino Ratio                            1.28
Calmar Ratio                             1.44
Max. Drawdown [%]                      -11.44
Avg. Drawdown [%]                       -1.45
Max. Drawdown Duration       84 days 22:00:00
Avg. Drawdown Duration        5 days 08:00:00
# Trades                                  353
Win Rate [%]                            55.81
Best Trade [%]                           0.60
Worst Trade [%]                         -0.50
Avg. Trade [%]                           0.04
Max. Trade Duration           3 days 09:00:00
Avg. Trade Duration           0 days 19:00:00
Profit Factor                            1.43
Expectancy [%]                           0.04
SQN                                      2.84
Kelly Criterion                          0.18
_strategy                 MLTrainOnceStrategy
_equity_curve                             ...
_trades                         Size  Entr...
dtype: object
In [6]:	
bt.plot()

	
	
Out[6]:	
GridPlot(	id = 'p1414', …)
	

Despite our lousy win rate, the strategy seems profitable. Let's see how it performs under walk-forward optimization, akin to k-fold or leave-one-out cross-validation:

In [7]:	
%%time

class MLWalkForwardStrategy(MLTrainOnceStrategy):
    def next(self):
        # Skip the cold start period with too few values available
        if len(self.data) < N_TRAIN:
            return

        # Re-train the model only every 20 iterations.
        # Since 20 << N_TRAIN, we don't lose much in terms of
        # "recent training examples", but the speed-up is significant!
        if len(self.data) % 20:
            return super().next()

        # Retrain on last N_TRAIN values
        df = self.data.df[-N_TRAIN:]
        X, y = get_clean_Xy(df)
        self.clf.fit(X, y)

        # Now that the model is fitted, 
        # proceed the same as in MLTrainOnceStrategy
        super().next()


bt = Backtest(data, MLWalkForwardStrategy, commission=.0002, margin=.05)
bt.run()

	
CPU times: user 7.72 s, sys: 23 ms, total: 7.74 s
Wall time: 7.73 s

Out[7]:	
Start                     2017-04-25 12:00:00
End                       2018-02-07 15:00:00
Duration                    288 days 03:00:00
Exposure Time [%]                       71.72
Equity Final [$]                      4872.10
Equity Peak [$]                      10052.11
Commissions [$]                       2686.43
Return [%]                             -51.28
Buy & Hold Return [%]                   10.12
Return (Ann.) [%]                      -52.13
Volatility (Ann.) [%]                    8.94
CAGR [%]                               -46.68
Sharpe Ratio                            -5.83
Sortino Ratio                           -3.28
Calmar Ratio                            -1.01
Max. Drawdown [%]                      -51.53
Avg. Drawdown [%]                      -51.53
Max. Drawdown Duration      265 days 00:00:00
Avg. Drawdown Duration      265 days 00:00:00
# Trades                                  324
Win Rate [%]                            46.91
Best Trade [%]                           0.40
Worst Trade [%]                         -0.49
Avg. Trade [%]                          -0.03
Max. Trade Duration           3 days 07:00:00
Avg. Trade Duration           0 days 18:00:00
Profit Factor                            0.79
Expectancy [%]                          -0.03
SQN                                     -1.81
Kelly Criterion                         -0.15
_strategy                 MLWalkForwardStr...
_equity_curve                             ...
_trades                         Size  Entr...
dtype: object
In [8]:	
bt.plot()

	
	
Out[8]:	
GridPlot(	id = 'p1860', …)
	

Apparently, when repeatedly retrained on past N_TRAIN data points in a rolling manner, our basic model generalizes poorly and performs not quite as well.

This was a simple and contrived, tongue-in-cheek example that shows one way to use machine learning forecast models with backtesting.py framework. In reality, you will need a far better feature space, better models (cf. deep learning), and better money management strategies to achieve consistent profits in automated short-term forex trading. More proper data science is an exercise for the keen reader.

Some instant optimization tips that come to mind are:

Data is king. Make sure your design matrix features as best as possible model and correlate with your chosen target variable(s) and not just represent random noise.
Instead of modelling a single target variable 
y
𝑦
, model a multitude of target/class variables, possibly better designed than our "48-hour returns" above.
Model everything: forecast price, volume, time before it "takes off", SL/TP levels, optimal position size ...
Reduce false positives by increasing the conviction needed and imposing extra domain expertise and discretionary limitations before entering trades.

Also make sure to familiarize yourself with the full Backtesting.py API reference

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.trades

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.TRADES_AGG

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.buy

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.sell

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.orders

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.sl

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.tp

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.pl

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.tag

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.position

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.close

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.close

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.closed_trades

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.tag

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#header-classes

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.cancel

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.is_contingent

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.is_long

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.is_short

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.limit

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.size

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.sl

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.stop

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Order.tp

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.is_long

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.is_short

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.pl_pct

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Position.size

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Strategy.equity

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.entry_bar

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.entry_price

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.entry_time

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.exit_bar

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.exit_price

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.exit_time

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.is_long

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.is_short

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.pl

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.pl_pct

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.size

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html#backtesting.backtesting.Trade.value

Module backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g.

from backtesting import Backtest, Strategy

Classes
class Backtest
(
data,
strategy,
*,
cash=10000,
spread=0.0,
commission=0.0,
margin=1.0,
trade_on_close=False,
hedging=False,
exclusive_orders=False,
finalize_trades=False)

Backtest a particular (parameterized) strategy on particular data.

Upon initialization, call method Backtest.run() to run a backtest instance, or Backtest.optimize() to optimize it.

Initialize a backtest. Requires data and a strategy to test.

data is a pd.DataFrame with columns: Open, High, Low, Close, and (optionally) Volume. If any columns are missing, set them to what you have available, e.g.

df['Open'] = df['High'] = df['Low'] = df['Close']


The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods).

strategy is a Strategy subclass (not an instance).

cash is the initial cash to start with.

spread is the the constant bid-ask spread rate (relative to the price). E.g. set it to 0.0002 for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price.

commission is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to 0.01. The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, commission can also be a tuple of floating values (fixed, relative). E.g. set it to (100, .01) if your broker charges minimum $100 + 1%. Additionally, commission can be a callable func(order_size: int, price: float) -> float (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates.

Note

Before v0.4.0, the commission was only applied once, like spread is now. If you want to keep the old behavior, simply set spread instead.

Note

With nonzero commission, long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633.

margin is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to 0.02 (1 / leverage).

If trade_on_close is True, market orders will be filled with respect to the current bar's closing price instead of the next bar's open.

If hedging is True, allow trades in both directions simultaneously. If False, the opposite-facing orders first close existing trades in a FIFO manner.

If exclusive_orders is True, each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time.

If finalize_trades is True, the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics.

Methods
def optimize
(
self,
*,
maximize='SQN',
method='grid',
max_tries=None,
constraint=None,
return_heatmap=False,
return_optimization=False,
random_state=None,
**kwargs)

Optimize strategy parameters to an optimal combination. Returns result pd.Series of the best run.

maximize is a string key from the Backtest.run()-returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number.

method is the optimization method. Currently two methods are supported:

"grid" which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and
"sambo" which finds close-to-optimal strategy parameters using model-based optimization, making at most max_tries evaluations.

max_tries is the maximal number of strategy runs to perform. If method="grid", this results in randomized grid search. If max_tries is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for method="sambo", max_tries is set to 200.

constraint is a function that accepts a dict-like object of parameters (with values) and returns True when the combination is admissible to test with. By default, any parameters combination is considered admissible.

If return_heatmap is True, besides returning the result series, an additional pd.Series is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see plot_heatmaps()).

If return_optimization is True and method = 'sambo', in addition to result series (and maybe heatmap), return raw scipy.optimize.OptimizeResult for further inspection, e.g. with SAMBO's plotting tools.

If you want reproducible optimization results, set random_state to a fixed integer random seed.

Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the "best" of the 7 admissible (of the 9 possible) parameter combinations:

backtest.optimize(sma1=[5, 10, 15], sma2=[10, 20, 40],
                  constraint=lambda p: p.sma1 < p.sma2)


TODO

Improve multiprocessing/parallel execution on Windos with start method 'spawn'.

def plot
(
self,
*,
results=None,
filename=None,
plot_width=None,
plot_equity=True,
plot_return=False,
plot_pl=True,
plot_volume=True,
plot_drawdown=False,
plot_trades=True,
smooth_equity=False,
relative_equity=True,
superimpose=True,
resample=True,
reverse_indicators=False,
show_legend=True,
open_browser=True)

Plot the progression of the last backtest run.

If results is provided, it should be a particular result pd.Series such as returned by Backtest.run() or Backtest.optimize(), otherwise the last run's results are used.

filename is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory.

plot_width is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable.

If plot_equity is True, the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plot_return plus initial 100%.

If plot_return is True, the resulting plot will contain a cumulative return graph section. This is the same as plot_equity minus initial 100%.

If plot_pl is True, the resulting plot will contain a profit/loss (P/L) indicator section.

If plot_volume is True, the resulting plot will contain a trade volume section.

If plot_drawdown is True, the resulting plot will contain a separate drawdown graph section.

If plot_trades is True, the stretches between trade entries and trade exits are marked by hash-marked tractor beams.

If smooth_equity is True, the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility.

If relative_equity is True, scale and label equity graph axis with return percent, not absolute cash-equivalent values.

If superimpose is True, superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. superimpose can also be a valid Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index.

If resample is True, the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's Javascript Error: Maximum call stack size exceeded or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. resample can also be a Pandas offset string, such as '5T' or '5min', in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index.

If reverse_indicators is True, the indicators below the OHLC chart are plotted in reverse order of declaration.

If show_legend is True, the resulting plot graphs will contain labeled legends.

If open_browser is True, the resulting filename will be opened in the default web browser.

def run
(
self, **kwargs)

Run the backtest. Returns pd.Series with results and statistics.

Keyword arguments are interpreted as strategy parameters.

>>> Backtest(GOOG, SmaCross).run()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    96.74115
Equity Final [$]                     51422.99
Equity Peak [$]                      75787.44
Return [%]                           414.2299
Buy & Hold Return [%]               703.45824
Return (Ann.) [%]                    21.18026
Volatility (Ann.) [%]                36.49391
CAGR [%]                             14.15984
Sharpe Ratio                          0.58038
Sortino Ratio                         1.08479
Calmar Ratio                          0.44144
Max. Drawdown [%]                   -47.98013
Avg. Drawdown [%]                    -5.92585
Max. Drawdown Duration      584 days 00:00:00
Avg. Drawdown Duration       41 days 00:00:00
# Trades                                   66
Win Rate [%]                          46.9697
Best Trade [%]                       53.59595
Worst Trade [%]                     -18.39887
Avg. Trade [%]                        2.53172
Max. Trade Duration         183 days 00:00:00
Avg. Trade Duration          46 days 00:00:00
Profit Factor                         2.16795
Expectancy [%]                        3.27481
SQN                                   1.07662
Kelly Criterion                       0.15187
_strategy                            SmaCross
_equity_curve                           Eq...
_trades                       Size  EntryB...
dtype: object


Warning

You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the Strategy.I() indicator which lags the most. Obviously, this can affect results.

class Order

Place new orders through Strategy.buy() and Strategy.sell(). Query existing orders through Strategy.orders.

When an order is executed or filled, it results in a Trade.

If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead.

All placed orders are Good 'Til Canceled.

Instance variables
prop is_contingent

True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent Trade is closed.

You can modify contingent orders through Trade.sl and Trade.tp.

prop is_long

True if the order is long (order size is positive).

prop is_short

True if the order is short (order size is negative).

prop limit

Order limit price for limit orders, or None for market orders, which are filled at next available price.

prop size

Order size (negative for short orders).

If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus Position.pl minus used margin). A value greater than or equal to 1 indicates an absolute number of units.

prop sl

A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the Trade following this order's execution. See also Trade.sl.

prop stop

Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit.

prop tag

Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated Trade (see Trade.tag).

prop tp

A take-profit price at which, if set, a new contingent limit order will be placed upon the Trade following this order's execution. See also Trade.tp.

Methods
def cancel
(
self)

Cancel the order.

class Position

Currently held asset position, available as Strategy.position within Strategy.next(). Can be used in boolean contexts, e.g.

if self.position:
    ...  # we have a position, either long or short

Instance variables
prop is_long

True if the position is long (position size is positive).

prop is_short

True if the position is short (position size is negative).

prop pl

Profit (positive) or loss (negative) of the current position in cash units.

prop pl_pct

Profit (positive) or loss (negative) of the current position in percent.

prop size

Position size in units of asset. Negative if position is short.

Methods
def close
(
self, portion=1.0)

Close portion of position by closing portion of each active trade. See Trade.close().

class Strategy

A trading strategy base class. Extend this class and override methods Strategy.init() and Strategy.next() to define your own strategy.

Subclasses
SignalStrategy TrailingStrategy
Instance variables
prop closed_trades

List of settled trades (see Trade).

prop data

Price data, roughly as passed into Backtest, but with two significant exceptions:

data is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, .index and length, it offers .pip property, the smallest price unit of change.
Within Strategy.init(), data arrays are available in full length, as passed into Backtest (for precomputing indicators and such). However, within Strategy.next(), data arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of Strategy.next() (iteratively called by Backtest internally), the last array value (e.g. data.Close[-1]) is always the most recent value.
If you need data arrays (e.g. data.Close) to be indexed Pandas series, you can call their .s accessor (e.g. data.Close.s). If you need the whole of data as a DataFrame, use .df accessor (i.e. data.df).
prop equity

Current account equity (cash plus assets).

prop orders

List of orders (see Order) waiting for execution.

prop position

Instance of Position.

prop trades

List of active trades (see Trade).

Methods
def I
(
self, func, *args, name=None, plot=True, overlay=None, color=None, scatter=False, **kwargs)

Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in Strategy.next() much like Strategy.data is. Returns np.ndarray of indicator values.

func is a function that returns the indicator array(s) of same length as Strategy.data.

In the plot legend, the indicator is labeled with function name, unless name overrides it. If func returns a tuple of arrays, name can be a sequence of strings, and its size must agree with the number of arrays returned.

If plot is True, the indicator is plotted on the resulting Backtest.plot().

If overlay is True, the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If False, the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time.

color can be string hex RGB triplet or X11 color name. By default, the next available color is assigned.

If scatter is True, the plotted indicator marker will be a circle instead of a connected line segment (default).

Additional *args and **kwargs are passed to func and can be used for parameters.

For example, using simple moving average function from TA-Lib:

def init():
    self.sma = self.I(ta.SMA, self.data.Close, self.n_sma)


Warning

Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results.

def buy
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new long order and return it. For explanation of parameters, see Order and its properties. Unless you're running Backtest(..., trade_on_close=True), market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met.

See Position.close() and Trade.close() for closing existing positions.

See also Strategy.sell().

def init
(
self)

Initialize the strategy. Override this method. Declare indicators (with Strategy.I()). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts.

If you extend composable strategies from backtesting.lib, make sure to call:

super().init()

def next
(
self)

Main strategy runtime method, called as each new Strategy.data instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in Strategy.init() take place.

If you extend composable strategies from backtesting.lib, make sure to call:

super().next()

def sell
(
self, *, size=.9999, limit=None, stop=None, sl=None, tp=None, tag=None)

Place a new short order and return it. For explanation of parameters, see Order and its properties.

Caution

Keep in mind that self.sell(size=.1) doesn't close existing self.buy(size=.1) trade unless the underlying asset price hasn't changed yet. Use Trade.close() or Position.close() to exit trades.

See also Strategy.buy().

Note

If you merely want to close an existing long position, use Position.close() or Trade.close().

class Trade

When an Order is filled, it results in an active Trade. Find active trades in Strategy.trades and closed, settled trades in Strategy.closed_trades.

Instance variables
prop entry_bar

Candlestick bar index of when the trade was entered.

prop entry_price

Trade entry price.

prop entry_time

Datetime of when the trade was entered.

prop exit_bar

Candlestick bar index of when the trade was exited (or None if the trade is still active).

prop exit_price

Trade exit price (or None if the trade is still active).

prop exit_time

Datetime of when the trade was exited.

prop is_long

True if the trade is long (trade size is positive).

prop is_short

True if the trade is short (trade size is negative).

prop pl

Trade profit (positive) or loss (negative) in cash units.

prop pl_pct

Trade profit (positive) or loss (negative) in percent.

prop size

Trade size (volume; negative for short trades).

prop sl

Stop-loss price at which to close the trade.

This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it None, you cancel it.

prop tag

A tag value inherited from the Order that opened this trade.

This can be used to track trades and apply conditional logic / subgroup analysis.

See also Order.tag.

prop tp

Take-profit price at which to close the trade.

This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it None, you cancel it.

prop value

Trade total value in cash (volume × price).

Methods
def close
(
self, portion=1.0)

Place new Order to close portion of the trade at next market price.

Backtesting.py
	
	
Super-module
backtesting
Classes
Backtest
optimize
plot
run
Order
cancel
is_contingent
is_long
is_short
limit
size
sl
stop
tag
tp
Position
close
is_long
is_short
pl
pl_pct
size
Strategy
I
buy
closed_trades
data
equity
init
next
orders
position
sell
trades
Trade
close
entry_bar
entry_price
entry_time
exit_bar
exit_price
exit_time
is_long
is_short
pl
pl_pct
size
sl
tag
tp
value

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.quantile

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.OHLCV_AGG

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.SignalStrategy.set_signal

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.TrailingStrategy.set_trailing_sl

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#header-variables

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#header-functions

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.barssince

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.compute_stats

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.cross

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.random_ohlc_data

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#header-classes

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/lib.html#backtesting.lib.TrailingStrategy.set_atr_periods

Module backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse.

Intended for simple missing-link procedures, not reinventing of better-suited, state-of-the-art, fast libraries, such as TA-Lib, Tulipy, PyAlgoTrade, NumPy, SciPy …

Please raise ideas for additions to this collection on the issue tracker.

Global variables
var OHLCV_AGG

Dictionary of rules for aggregating resampled OHLCV data frames, e.g.

df.resample('4H', label='right').agg(OHLCV_AGG).dropna()

var TRADES_AGG

Dictionary of rules for aggregating resampled trades data, e.g.

stats['_trades'].resample('1D', on='ExitTime',
                          label='right').agg(TRADES_AGG)

Functions
def barssince
(
condition, default=inf)

Return the number of bars since condition sequence was last True, or if never, return default.

>>> barssince(self.data.Close > self.data.Open)
3

def compute_stats
(
*, stats, data, trades=None, risk_free_rate=0.0)

(Re-)compute strategy performance metrics.

stats is the statistics series as returned by Backtest.run(). data is OHLC data as passed to the Backtest the stats were obtained in. trades can be a dataframe subset of stats._trades (e.g. only long trades). You can also tune risk_free_rate, used in calculation of Sharpe and Sortino ratios.

>>> stats = Backtest(GOOG, MyStrategy).run()
>>> only_long_trades = stats._trades[stats._trades.Size > 0]
>>> long_stats = compute_stats(stats=stats, trades=only_long_trades,
...                            data=GOOG, risk_free_rate=.02)

def cross
(
series1, series2)

Return True if series1 and series2 just crossed (above or below) each other.

>>> cross(self.data.Close, self.sma)
True

def crossover
(
series1, series2)

Return True if series1 just crossed over (above) series2.

>>> crossover(self.data.Close, self.sma)
True

def plot_heatmaps
(
heatmap, agg='max', *, ncols=3, plot_width=1200, filename='', open_browser=True)

Plots a grid of heatmaps, one for every pair of parameters in heatmap.

heatmap is a Series as returned by Backtest.optimize() when its parameter return_heatmap=True.

When projecting the n-dimensional heatmap onto 2D, the values are aggregated by 'max' function by default. This can be tweaked with agg parameter, which accepts any argument pandas knows how to aggregate by.

TODO

Lay heatmaps out lower-triangular instead of in a simple grid. Like sambo.plot.plot_objective() does.

def quantile
(
series, quantile=None)

If quantile() is None, return the quantile rank of the last value of series wrt former series values.

If quantile() is a value between 0 and 1, return the value of series at this quantile. If used to working with percentiles, just divide your percentile amount with 100 to obtain quantiles.

>>> quantile(self.data.Close[-20:], .1)
162.130
>>> quantile(self.data.Close)
0.13

def random_ohlc_data
(
example_data, *, frac=1.0, random_state=None)

OHLC data generator. The generated OHLC data has basic descriptive statistics similar to the provided example_data.

frac is a fraction of data to sample (with replacement). Values greater than 1 result in oversampling.

Such random data can be effectively used for stress testing trading strategy robustness, Monte Carlo simulations, significance testing, etc.

>>> from backtesting.test import EURUSD
>>> ohlc_generator = random_ohlc_data(EURUSD)
>>> next(ohlc_generator)  # returns new random data
...
>>> next(ohlc_generator)  # returns new random data
...

def resample_apply
(
rule, func, series, *args, agg=None, **kwargs)

Apply func (such as an indicator) to series, resampled to a time frame specified by rule. When called from inside Strategy.init(), the result (returned) series will be automatically wrapped in Strategy.I() wrapper method.

rule is a valid Pandas offset string indicating a time frame to resample series to.

func is the indicator function to apply on the resampled series.

series is a data series (or array), such as any of the Strategy.data series. Due to pandas resampling limitations, this only works when input series has a datetime index.

agg is the aggregation function to use on resampled groups of data. Valid values are anything accepted by pandas/resample/.agg(). Default value for dataframe input is OHLCV_AGG dictionary. Default value for series input is the appropriate entry from OHLCV_AGG if series has a matching name, or otherwise the value "last", which is suitable for closing prices, but you might prefer another (e.g. "max" for peaks, or similar).

Finally, any *args and **kwargs that are not already eaten by implicit Strategy.I() call are passed to func.

For example, if we have a typical moving average function SMA(values, lookback_period), hourly data source, and need to apply the moving average MA(10) on a daily time frame, but don't want to plot the resulting indicator, we can do:

class System(Strategy):
    def init(self):
        self.sma = resample_apply(
            'D', SMA, self.data.Close, 10, plot=False)


The above short snippet is roughly equivalent to:

class System(Strategy):
    def init(self):
        # Strategy exposes <code>self.data</code> as raw NumPy arrays.
        # Let's convert closing prices back to pandas Series.
        close = self.data.Close.s

        # Resample to daily resolution. Aggregate groups
        # using their last value (i.e. closing price at the end
        # of the day). Notice `label='right'`. If it were set to
        # 'left' (default), the strategy would exhibit
        # look-ahead bias.
        daily = close.resample('D', label='right').agg('last')

        # We apply SMA(10) to daily close prices,
        # then reindex it back to original hourly index,
        # forward-filling the missing values in each day.
        # We make a separate function that returns the final
        # indicator array.
        def SMA(series, n):
            from backtesting.test import SMA
            return SMA(series, n).reindex(close.index).ffill()

        # The result equivalent to the short example above:
        self.sma = self.I(SMA, daily, 10, plot=False)

Classes
class SignalStrategy

A simple helper strategy that operates on position entry/exit signals. This makes the backtest of the strategy simulate a vectorized backtest. See tutorials for usage examples.

To use this helper strategy, subclass it, override its Strategy.init() method, and set the signal vector by calling SignalStrategy.set_signal() method from within it.

class ExampleStrategy(SignalStrategy):
    def init(self):
        super().init()
        self.set_signal(sma1 > sma2, sma1 < sma2)


Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_signal
(
self, entry_size, exit_portion=None, *, plot=True)

Set entry/exit signal vectors (arrays).

A long entry signal is considered present wherever entry_size is greater than zero, and a short signal wherever entry_size is less than zero, following Order.size semantics.

If exit_portion is provided, a nonzero value closes portion the position (see Trade.close()) in the respective direction (positive values close long trades, negative short).

If plot is True, the signal entry/exit indicators are plotted when Backtest.plot() is called.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
class TrailingStrategy

A strategy with automatic trailing stop-loss, trailing the current price at distance of some multiple of average true range (ATR). Call TrailingStrategy.set_trailing_sl() to set said multiple (6 by default). See tutorials for usage examples.

Remember to call super().init() and super().next() in your overridden methods.

Ancestors
Strategy
Methods
def set_atr_periods
(
self, periods=100)

Set the lookback period for computing ATR. The default value of 100 ensures a stable ATR.

def set_trailing_sl
(
self, n_atr=6)

Sets the future trailing stop-loss as some multiple (n_atr) average true bar ranges away from the current price.

Inherited members
Strategy: I buy closed_trades data equity init next orders position sell trades
Backtesting.py
	
	
Super-module
backtesting
Global variables
OHLCV_AGG
TRADES_AGG
Functions
barssince
compute_stats
cross
crossover
plot_heatmaps
quantile
random_ohlc_data
resample_apply
Classes
SignalStrategy
set_signal
TrailingStrategy
set_atr_periods
set_trailing_sl

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html#header-variables

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html#backtesting.test.EURUSD

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html#backtesting.test.GOOG

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html#header-functions

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/test/index.html#backtesting.test.SMA

Module backtesting.test

Data and utilities for testing.

Global variables
var EURUSD

DataFrame of hourly EUR/USD forex data from April 2017 to February 2018.

var GOOG

DataFrame of daily NASDAQ:GOOG (Google/Alphabet) stock price data from 2004 to 2013.

Functions
def SMA
(
arr, n)

Returns n-period simple moving average of array arr.

Backtesting.py
	
	
Super-module
backtesting
Global variables
EURUSD
GOOG
Functions
SMA

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/#example

Backtesting.py
Backtest trading strategies in Python

Does it seem like you had missed getting rich during the recent crypto craze? Despair not—the international financial markets continue their move rightwards every day. You still have your chance. But successful traders all agree emotions have no place in trading — if you are ever to enjoy a fortune attained by trading, better first make sure your strategy or system is well-tested and working reliably toward consistent profits. Mechanical or algorithmic trading, they call it. They'll usually recommend signing up with a broker and trading on a demo account for a few months … But you know better. You know some programming.

It is far better to foresee even without certainty than not to foresee at all.

— Henri Poincare

Backtesting.py is a Python framework for inferring viability of trading strategies on historical (past) data. Of course, past performance is not indicative of future results, but a strategy that proves itself resilient in a multitude of market conditions can, with a little luck, remain just as reliable in the future. Improved upon the vision of Backtrader, and by all means surpassingly comparable to other accessible alternatives, Backtesting.py is lightweight, fast, user-friendly, intuitive, interactive, intelligent and, hopefully, future-proof. It is also documented well, including a handful of tutorials.

Compatible with forex, crypto, stocks, futures ...

Backtest any financial instrument for which you have access to historical candlestick data.

Blazing fast, convenient

Built on top of cutting-edge ecosystem libraries (i.e. Pandas, NumPy, Bokeh) for maximum speed and ergonomics.

Small, clean API

The API reference is easy to wrap your head around and fits on a single page.

Technical indicator library agnostic

Compatible with any sensible technical analysis library, such as TA-Lib, Tulip, pandas-ta ...

Built-in SAMBO optimizer

Test hundreds of strategy variants in mere seconds, resulting in heatmaps you can interpret at a glance.

High-level API

Think market timing, swing trading, money management, stop-loss and take-profit prices, leverage, machine learning ...

Interactive visualization

Simulated trading results in telling interactive charts you can zoom into. See Example.

Vectorized or event-based backtesting

Signal-driven or streaming, model your strategy enjoying the flexibility of both approaches.

Composable strategies

Contains a library of predefined utilities and general-purpose strategies that are made to stack.

Download
PyPI
GitHub
Docs

🛈 Backtesting.py works with Python 3. You need to know some Python to effectively use this software.

Example

The example shows a simple, unoptimized moving average cross-over strategy. It's a common introductory strategy and a pretty decent strategy overall, provided the market isn't whipsawing sideways.

We begin with 10,000 units of currency in cash, realistic 0.2% broker commission, and we trade through 9 years worth of Alphabet Inc. stock.

Whenever the fast, 10-period simple moving average of closing prices crosses above the slower, 20-period moving average, we go long, buying as many stocks as we can afford. When it crosses below, we close our long position and go short (assuming the underlying instrument is actually a CFD and can be shorted).

We record most significant statistics this simple system produces on our data, and we show a plot for further manual inspection.

from backtesting import Backtest, Strategy
from backtesting.lib import crossover

from backtesting.test import SMA, GOOG


class SmaCross(Strategy):
    n1 = 10
    n2 = 20

    def init(self):
        close = self.data.Close
        self.sma1 = self.I(SMA, close, self.n1)
        self.sma2 = self.I(SMA, close, self.n2)

    def next(self):
        if crossover(self.sma1, self.sma2):
            self.position.close()
            self.buy()
        elif crossover(self.sma2, self.sma1):
            self.position.close()
            self.sell()


bt = Backtest(GOOG, SmaCross,
              cash=10000, commission=.002,
              exclusive_orders=True)

output = bt.run()
bt.plot()
Start                     2004-08-19 00:00:00
End                       2013-03-01 00:00:00
Duration                   3116 days 00:00:00
Exposure Time [%]                    94.27374
Equity Final [$]                     81812.37
Equity Peak [$]                      81879.03
Return [%]                           718.1237
Buy & Hold Return [%]               607.37036
Return (Ann.) [%]                    27.96479
Volatility (Ann.) [%]                39.08925
CAGR [%]                             18.52838
Sharpe Ratio                          0.71541
Sortino Ratio                         1.43503
Calmar Ratio                          0.85275
Max. Drawdown [%]                   -32.79366
Avg. Drawdown [%]                    -5.24919
Max. Drawdown Duration      680 days 00:00:00
Avg. Drawdown Duration       38 days 00:00:00
# Trades                                   93
Win Rate [%]                         54.83871
Best Trade [%]                       57.43355
Worst Trade [%]                     -16.39664
Avg. Trade [%]                        2.16381
Max. Trade Duration         121 days 00:00:00
Avg. Trade Duration          32 days 00:00:00
Profit Factor                         2.27119
Expectancy [%]                        2.69468
SQN                                   1.94546
Kelly Criterion                       0.25935
_strategy              SmaCross(n1=10, n2=20)

Find better examples, including executable Jupyter
notebooks, in the project documentation.

Documentation
What Users are Saying

 The proof of [this] program's value is its existence.

Alan Perlis

Some things are so unexpected that no one is prepared for them.

Leo Rosten

[...] When all else fails, read the instructions.

Cahn

The financial markets generally are unpredictable. So that one has to have different scenarios … The idea that you can actually predict what's going to happen contradicts my way of looking at the market.

George Soros

If you don’t find a way to make money while you sleep, you will work until you die.

Warren Buffet

卐

A good forecaster is not smarter than everyone else, he merely has his ignorance better organised.

卍

---

# https://kernc.github.io/backtesting.py/doc/backtesting/

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#manuals

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#example-strategies

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#faq

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#license

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

# https://kernc.github.io/backtesting.py/doc/backtesting/index.html#api-reference-documentation

Package backtesting

Manuals
Quick Start User Guide
Tutorials

The tutorials encompass most framework features, so it's important and advisable to go through all of them. They are short.

Library of Utilities and Composable Base Strategies
Multiple Time Frames
Parameter Heatmap & Optimization
Trading with Machine Learning

These tutorials are also available as live Jupyter notebooks:  
In Colab, you might have to !pip install backtesting.

Example Strategies
(contributions welcome)

Tip

For an overview of recent changes, see What's New.

FAQ

Some answers to frequent and popular questions can be found on the issue tracker or on the discussion forum on GitHub. Please use the search!

License

This software is licensed under the terms of AGPL 3.0, meaning you can use it for any reasonable purpose and remain in complete ownership of all the excellent trading strategies you produce, but you are also encouraged to make sure any upgrades to Backtesting.py itself find their way back to the community.

API Reference Documentation
Sub-modules
backtesting.backtesting

Core framework data structures. Objects from this module can also be imported from the top-level module directly, e.g …

backtesting.lib

Collection of common building blocks, helper auxiliary functions and composable strategy classes for reuse …

backtesting.test

Data and utilities for testing.

Backtesting.py
	
	
Manuals
Tutorials
Example Strategies
FAQ
License
API Reference Documentation
Sub-modules
backtesting.backtesting
backtesting.lib
backtesting.test

backtesting 0.6.1 卐

 

Generated by pdoc 0.11.5.

---

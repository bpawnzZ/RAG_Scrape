# https://motion.dev/docs

Docs

Examples

Motion+

Documentation

Quick start

Motion is a JavaScript animation library that's easy to start and fun to master.

It's the only library with a hybrid engine, combining hardware accelerated DOM animations with the flexibility to animate anything that a browser can't, like independent transforms, gradients or Three.js.

Choose your flavour

Motion is available for both vanilla JavaScript and React.

JS
JavaScript
React

Or you can start with one of our platform-specific integration guides.

CSS
Vue
Framer
Webflow

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

         

---

# https://motion.dev/

Docs

Examples

Motion+

MOTION

A modern animation library for JavaScript and React

Quick start

Motion makes animation

simple, fun, and limitless.

Go beyond the browser with super smooth

springs, layout animations, timelines

and much, much more.

Free

Completely free to use and open-source under the MIT license.

Tiny

Mini animate is 90% smaller than its GSAP equivalent, scroll 75% smaller.

Production-ready

Written in TypeScript, with extensive test coverage.

Hybrid engine

The power of JS animations with the performance of hardware acceleration.

Simple

Motion One's pick-up-and-play API is easy to start and fun to master.

Examples:

Transforms

Go beyond CSS by animating transforms on every axis.

Examples:

Springs

Go beyond time-based animations with real spring physics for great-feeling animations.

Examples:

Scroll

Motion One uses browser APIs for beautiful scroll-linked and scroll-triggered animations.

Examples:

Exit animations

Motion One for React makes it easier than ever to animate elements as they exit the DOM.

Examples:

Layout animations

Animate between different layouts with Motion One's industry-leading layout animation engine.

Examples:

Gestures

Animate transforms on every axis independently, with full control over timing.

Examples:

Timeline

Animate transforms on every axis independently, with full control over timing.

Examples:

Our Sponsors

Motion is made possible thanks to our amazing sponsors.

Framer
Figma
Linear
Emil Kowalski
Tailwind
Liveblocks
Vercel
Luma

Become a sponsor

Courses

Motion for React has video and interactive courses built by the best educators in the world.

Animations on the Web

Taught by 

Emil Kowalski

The Joy of React

Taught by 

Josh W. Comeau

See all courses

Premium components

Motion+ grants access to premium React components, starting with Cursor and AnimateNumber.

All components are built in TypeScript and supported by a strong test suite. Install via npm, with source access via our private Github repo.

Showcase

All the beautiful sites featured in the Framer gallery are powered by Motion.

Here are some more amazing interactions made by developers with its flexible APIs.

Delight the web with Motion

Quick start

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

                 

---

# https://motion.dev/plus

Get instant access

Motion+

Level up your animations with the all-in membership.

Personal

$299

Exclusive examples

Premium components

Early access

Private Discord & Github

Free lifetime updates

Get instant access

One-time payment, no subscription

Team

$1,499

Motion+ for 10 team members

Power up your team

One-time payment, no subscription

Exclusive examples

Go beyond the basics with the source code to our exclusive Motion+ examples.

Copy/paste directly into your own project, or open directly in Vercel's AI code editor.

Ask your place of work about your education budget!

Premium components

Motion+ grants access to premium React components, starting with Cursor and AnimateNumber.

All components are built in TypeScript and supported by a strong test suite. Install via npm, with source access via our private Github repo.

Early access

All new features and guides go through early access so they can be tried out by Motion+ users first, before going on general release.

Currently in early access:

View animations

Learn how to use Motion's view() function to create incredible view transitions, layout animations and shared element transitions. Available in early access for Motion+ members.

Unlocks in:

52 Days 16 Hours 33 Minutes

View animations

Learn how to use Motion's view() function to create incredible view transitions, layout animations and shared element transitions. Available in early access for Motion+ members.

Unlocks in:

52 Days 16 Hours 33 Minutes

View animations

Learn how to use Motion's view() function to create incredible view transitions, layout animations and shared element transitions. Available in early access for Motion+ members.

Unlocks in:

52 Days 16 Hours 33 Minutes

View animations

Learn how to use Motion's view() function to create incredible view transitions, layout animations and shared element transitions. Available in early access for Motion+ members.

Unlocks in:

52 Days 16 Hours 33 Minutes

View animations

Learn how to use Motion's view() function to create incredible view transitions, layout animations and shared element transitions. Available in early access for Motion+ members.

Unlocks in:

52 Days 16 Hours 33 Minutes

Private Discord

Be the first to know about upcoming Motion releases.

Showcase your work to the community.

Get help and support from other members.

Wallpaper pack

For mobile, tablet and desktop. Two colourways celebrating Motion's history: Framer Motion dark and Motion One blue.

FAQs

What does "lifetime" access mean?

How does the Team package work?

How do I get access to the private Github?

What is your refund policy?

Delight the web with Motion+

Get instant access

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

         

---

# https://motion.dev/docs/quick-start

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/react-quick-start

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/css

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};

// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")

element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>

<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"

  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"

  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"

  const isOpen = ref(false)

  function openModal() {
    view(async () => {
      isOpen.value = true

      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>

<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"

const header = useTemplateRef("header")

const props = defineProps({
  opacity: { type: Number, default: 1 }
})

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/framer

Docs

Examples

Motion+

Documentation

React

Framer

Framer

Framer is the world's best no-code website builder. If you have a Framer website, all your animations are already powered by Motion.

Framer offers a number of animations, interactions and components that mean you usually never need to write any code to achieve amazing effects.

However, advanced users can write code components and overrides, which are custom React components that you can drop into your canvas.

The full Motion for React API is available to use in both.

Import

Import Motion for React via "framer-motion":

import { motion, useSpring } from "framer-motion"

Use "framer-motion" whenever the Motion docs instruct you to use "motion/react".

Next

With Motion set up in your Framer project, we recommend you follow the rest of the Quick Start guide to begin learning Motion for React.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/webflow

Docs

Examples

Motion+

Documentation

JavaScript

Webflow

Integrate Motion with Webflow

Webflow already comes with some animation capabilities, but it can be that you want to go that little bit further by introducing custom code:

Animate previously unanimatable values (like gradients and masks)




Hardware accelerated scroll animations




Complex timeline sequences




Three.js

If you're migrating from GSAP, you'll achieve better Lighthouse Performance scores, and you can even use Motion without a business license.

In this guide, we'll walk through how you can add Motion to your project, and give an overview of how to optionally generate custom scripts for even better performance.

Install

First, open the Pages dialog in your project and click "Edit page settings" on the page you want to add Motion to.

Scroll down until you find the "Before <body /> tag" dialog. In here, we can add our Motion code.

Here, you can add a new script block that imports Motion.

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/+esm"

  animate("header", { opacity: 1 })
</script>

You can replace 11.13.5 here with whichever version you want to install. The latest published version can be found on the npm package page.

This script contains all the Motion imports, but you can also achieve even greater filesize savings if you want to use just the mini version of the animate function, which is just 2.5kb, by importing from https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm:

<script type="module">
  import { animate } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm"
</script>
Custom scripts

By importing scripts directly from this URL, you're importing everything, even the bits of Motion you're not using. But, one of the great things about Motion is it's tree-shakable. This means you can use a bundler like Vite or Rollup to only include the bits you use.

In fact, this is a good practise for all of your Webflow custom code. It will ensure you package everything into one neat bundle and only package the bits you need.

For example, if you only wanted to use the animate function, you could replace the above code with this:

import { animate } from "motion"

animate("header", { opacity: 1 })

Building this with Rollup, uploading to a CDN, and then including with an async JS tag will boost SEO scores even further:

<script async src="https://yourdomain.com/my-script.js"></script>
Next

Now that you have Motion running in your Webflow project, you can follow our quick start guide to start making animations!

CSS

Integrate Motion with Vue 3

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/about

Docs

Examples

Motion+

About

Hello! I'm Matt Perry, creator of Motion.

I've been writing animation libraries for over a decade. You could call it a problem, but I'm enjoying myself 😅

I started writing my own animation libraries back in 2014 because I was unsatisfied with the feeling of the UIs I could create with CSS alone. 

For lack of a better word, they felt "webby", or a little janky.

CSS and native browser JavaScript APIs were really limited back then. So I was determined to make my first library, Popmotion, one where anything was possible.

From there, I joined Framer to make Framer Motion. With Framer Motion, I concentrated on the simplicity of the API, while retaining Popmotion's limitless possibilities.

Since then, browser APIs have come a long way, with new advances like the Web Animations API and Intersection Observer. 

Now, with Motion, I'm making an API that packages all the power and performance of these native browser animations into a user-friendly library, while also adding the superpowers of Framer Motion.

Let me know what you make!

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/blog

Docs

Examples

Motion+

Blog
Revealed: React's experimental animations API

Jan 13, 2025

React is experimenting with a new animation API based on the View Transition API. How does it work? What can it do? We reveal all in this blog post.

How to add cmd-k search shortcut to your Framer site

Nov 20, 2024

By default, the Framer Search component doesn't support the cmd-k keyboard shortcut. Here's how to add it to your Framer site.

Framer Motion is now independent, introducing Motion

Nov 12, 2024

Framer Motion is now independent. Introducing Motion, a new animation library for React and all JavaScript environments. Here's what it means for you.

Do you still need Framer Motion?

May 29, 2024

In the five years since Framer Motion was released, CSS animation APIs have come a long way. Do you still need to use Framer Motion?

When browsers throttle requestAnimationFrame

Oct 1, 2020

In specific situations Safari and Firefox may throttle requestAnimationFrame. Here’s why your JavaScript animations are janky.

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/sponsor

Docs

Examples

Motion+

Sponsor Motion

Motion is free and open source. Corporate sponsorships allow me to spend more time supporting the core library and keep the project sustainable in the years to come.

Every sponsorship comes with Motion+ memberships for your team. Motion+ members receive early access content, premium components, and access to our private support Discord.

Sponsorships can be cancelled at any time, with zero obligations. I’m super thankful for all support, past, present and future. It all makes a difference.

If you'd prefer to pay by invoice, or talk about a deeper sponsorship that could include priority support, feature development, or joining your company Slack, email me at matt@motion.dev.

Silver

$250

Per month (+ local tax)

Motion+ for 1

Small logo & link:

• Readme

• Sponsor page

Start sponsorship

Gold

$1,000

Per month (+ local tax)

Motion+ for 5

Medium logo & link:

• Readme

• Sponsor page

• Homepage

  (130k views/month)

Start sponsorship

Platinum

$2,000

Per month (+ local tax)

Motion+ for 10

Large logo & link:

• Readme

• Sponsor page

• Homepage

Mono logo & link in footer

(650k views/month)

Start sponsorship

Our Sponsors

Motion is made possible thanks to our amazing sponsors.

Framer
Figma
Linear
Emil Kowalski
Tailwind
Liveblocks
Vercel
Luma
Frontend.fyi
Statamic
Firecrawl
Puzzmo
Build UI
Hover

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

Privacy Policy

     

---

# https://motion.dev/docs/react-courses

Docs

Examples

Motion+

Documentation

React

Courses

Courses

Motion for React is supported by the world's best educators, who offer courses that go deeper than docs alone.

Each educator is different, specialising in respective parts of Motion and with different teaching styles. Therefore each course offers something unique, with one or more of them being ideal of you and your journey. 

Animations on the Web

Taught by

Emil Kowalski

Advanced

Animations on the Web is taught by one of the top interactive designers in the world, Emil Kowalski.

As such, this course will go into the theory and feelings behind great animation. Not just the how, but the why.

Enroll now

Crafting Beautiful Experiences with Motion

Taught by

Jeroen Reumkens

Beginner-friendly

Videos

Interactive code examples

Scroll animations

Layout animations

Variants

Crafting Beautiful Experiences with Motion is an extensive video and interactive course taught by Jeroen Reumkens.

It will guide you through many of the fundamental pillars of Motion for React, like variants, scroll, layout and exit animations.

It also goes into detail about Motion's superpower API, motion values. All using interactive code examples where you learn by doing.

Enroll now

The Joy of React

Taught by

Josh W. Comeau

Beginner-friendly

Interactive code examples

Layout animations

The Joy of React is an incredible course for React beginners and experts alike, made by Josh W. Comeau, craftsman of the world's most delightful UIs. 

It's a React-focused course, where you'll learn by building real-world UIs like toast notifications and interactive MDX blogs, all via interactive code examples.

The Ultimate Package comes with a special module that is the perfect primer on Motion's layout animations!

Enroll now

Motion for React Recipes

Taught by

Sam Selikoff 

Beginner-friendly

Videos

Code examples

Scroll animations

Layout animations

Variants

Motion for React Recipes is hosted by Motion expert Sam Selikoff, using both video and easy-reference articles.

By using real-world examples of UIs like email clients, multistep forms and carousels, you'll learn how to take any design to the next level.

This course covers many Motion features, like variants, scroll animations, exit animations and layout animations.

Enroll now

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

        

---

# https://motion.dev/docs/cursor

Docs

Examples

Motion+

Documentation

React

Cursor

Cursor

Motion+ Exclusive

Checking Motion+ status…

This content is exclusive to Motion+ members

Get Motion+ for instant access

One-time payment, no subscription

Already joined?

Login

Cursor is a creative cursor component for React. It makes it easy to build custom cursor and follow cursor effects.

With its default settings, it replaces the browser cursor with a dynamic cursor.

<Cursor />

This cursor automatically detects the types of content it's hovering over. When hovering a link or button, it grows. When it's pressed, it shrinks. It also detects disabled status.

When hovering selectable text, it transforms into a text selector that grows with the size of the text.

The cursor can be fully styled with CSS and animated using Motion's variants. Beyond that, it's also possible to set custom content when hovering over specific elements.

With only a prop, we can create a follow cursor effect. Great for previews or popup information.

<Cursor follow />

We can also render as many cursors as we like, all at the same time. Attaching them to the cursor with springs of varying strengths.

In this guide, we'll learn how to install Cursor, customise it with its various options and useCursorState hook.

AnimateNumber

LazyMotion

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/react-animate-number

Docs

Examples

Motion+

Documentation

React

AnimateNumber

AnimateNumber

Motion+ Exclusive

Checking Motion+ status…

This content is exclusive to Motion+ members

Get Motion+ for instant access

One-time payment, no subscription

Already joined?

Login

AnimateNumber creates beautiful number animations with Motion.

<AnimateNumber>{count}</AnimateNumber>

You can create a number of popular animation effects, like countdowns, engagement bars, or labelling user inputs.

It's a continuation of the original version of Max Barvian's NumberFlow component, which was built on Motion.

Because AnimateNumber leverages Motion's existing layout animations, it's only 2.5kb on top of Motion for React. It also means you can use Motion's existing transition settings.

However, being based on an older version of NumberFlow means it currently lacks a couple of its newer props like trend and plugins.

In this guide, we'll learn how to install AnimateNumber into our projects, and how to use it for a variety of number animation effects.

AnimatePresence

Cursor

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/view

Docs

Examples

Motion+

Documentation

JavaScript

view

View animations

Motion+ Early Access

Alpha

Checking Motion+ status…

Unlocks for everyone in

52 Days 16 Hours 33 Minutes

Or

Get Motion+ for instant access

One-time payment, no subscription

Already joined?

Login

Motion's view() function makes it simple to animate between two different views or layouts.

// Crossfade
view(update).enter({ opacity: 1 })

View animations have a number of unique superpowers:

Layout: Animate discrete changes in layout, like switching justify-content between "flex-start" and "flex-end".

Shared element transitions: Animate entirely different elements across two views. For example, this underline element moves like a single element, but each is generated entirely with CSS on the .selected tab.

Page effects: Add effects to the entire viewport, like wipes, slides and crossfades:

view() is built on the browser's native View Transition API for small filesize and great performance.

It aims to remove the complexity of the View Transition API for a cleaner and more robust codebase, as well as expanding on its limitations.

Important: view() is currently in alpha, which means the API might change. It's also exclusive to Motion+ members, who are encouraged to help us shape the API via our private Discord.

As an early access API, there are many more features to come, such as:

Smoother interruption handling




Automatic view-transition-name




Enter/exit animations







scroll

hover

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

         

---

# https://motion.dev/docs/quick-start#install

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/quick-start#package-manager

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/quick-start#script-tag

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/quick-start#create-an-animation

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))


// Elements
const boxes = document.querySelectorAll(".box")


animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/animate

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/quick-start#what-can-be-animated

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))


// Elements
const boxes = document.querySelectorAll(".box")


animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/quick-start#customising-animations

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))


// Elements
const boxes = document.querySelectorAll(".box")


animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"

animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/spring

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []

let isDone = false
let time = 0
const sampleDuration = 20 // ms

while (!isDone) {
  const { value, done } = generator.next(time)

  output.push(value)

  time += sampleDuration

  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/quick-start#stagger-animations

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"


animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/quick-start#what-s-next

Docs

Examples

Motion+

Documentation

JavaScript

Quick start

Quick start

Motion is an animation library that's easy to start and fun to master.

Its unique hybrid engine combines the performance of the browser with the limitless potential of a JavaScript engine. This means you can animate anything, like:

HTML/CSS




SVG (like path drawing animations) 




WebGL (3D graphics)

The best part? It's also tiny, with a mini HTML/SVG version of the animate() function that's just 2.5kb!

By the end of this quick guide, you'll have installed Motion and made your first animation.

Install

You can install Motion in two ways: 

A package manager like npm or Yarn (most popular)




HTML script tag

Package manager

Motion can be installed via the "motion" package.

npm install motion

Then imported in your JavaScript:

import { animate, scroll } from "motion"
script tag 

It's possible to import Motion directly using a script tag. This is perfect if you're working with a basic HTML page, or using a no-code tool like Webflow.

Import using the modern import syntax:

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@latest/+esm"
</script>

Or you can add Motion as a global variable using the legacy include:

<script src="https://cdn.jsdelivr.net/npm/motion@latest/dist/motion.js"></script>
<script>
  const { animate, scroll } = Motion
</script>

Note: It's best practise to replace "latest" in these URLs with a specific version, like 11.11.13. You can find the latest version at JSDelivr.

Create an animation

The "Hello world!" of any animation library is a simple transform animation. 

Let's start by importing the animate function.

import { animate } from "motion"

animate can animate one or more elements. You can either use a CSS selector (like ".my-class") or provide the elements directly:

// CSS selector
animate(".box", { rotate: 360 }))

// Elements
const boxes = document.querySelectorAll(".box")

animate(boxes, { rotate: 360 })

You can see here we're setting rotate to 360. This will rotate the element 360 degrees:

What can be animated?

Motion lets you animate anything:

CSS properties (like opacity, transform and filter)




SVG attributes and paths




Independent transforms  (x, rotateY etc)




JavaScript objects (containing strings/colors/numbers)

With Motion, you don't have to worry about achieving the best performance available. When a value can be hardware accelerated, like opacity, filter or transform, it will be.

animate isn't limited to HTML. It can animate single values or any kind of object. For example, the rotation of a Three.js object:

animate(
  cube.rotation,
  { y: rad(360), z: rad(360) },
  { duration: 10, repeat: Infinity, ease: "linear" }
)
Customising animations

Motion comes with smart defaults, so your animations should look and feel great out of the box. But you can further tweak options like:

Duration (how long the animation lasts)




Delay (how long it waits before starting)




Easing (how it speeds up and slows down)




Repeat (how it repeats, how many times, etc)

animate(
  element,
  { scale: [0.4, 1] },
  { ease: "circInOut", duration: 1.2 }
);

Motion also has amazing spring animations for natural, kinetic animations:

animate(
  element,
  { rotate: 90 },
  { type: "spring", stiffness: 300 }
);
Stagger animations

When animating multiple elements, it can feel more natural or lively to offset the animations of each. This is called staggering.

Motion provides a stagger function that can be used to dynamically set delay:

import { animate, stagger } from "motion"


animate(
  "li",
  { y: 0, opacity: 1 },
  { delay: stagger(0.1) }
)
What's next?

You've just learned the basics of Motion and created a simple animation. But there's so much more to discover, like:

Keyframes and sequences: Create more complex animations




Controls: Pause, resume or change animations




Scroll-linked animations: Link values to scroll position




Scroll-triggered animations: Trigger animations when elements enter the viewport

Or you can dive straight into our examples, which are clear, simple, and feature source code that can be easily copy/pasted, or opened straight into the v0 AI code editor.

animate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/scroll

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  

scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)

// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)

stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/react-quick-start#install

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#usage

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>


// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#enter-animation

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#gestures

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#scroll-animations

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()


return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#layout-animations

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()


return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-layout-animations

Docs

Examples

Motion+

Documentation

React

Layout

Layout animations

Motion's industry-leading layout animations makes it easy to animate between any two layouts, even between different elements.

It's as simple as a layout prop.

<motion.div layout />

One of the coolest things about layout animations is that they effectively make any CSS property transitionable. You can’t apply a CSS transition to flex-direction or grid-template-columns, but with layout animations, you can. Plus, the animation uses super-efficient transforms, so the motion will be smooth!

~ Josh W. Comeau, The Joy of React

This little prop can animate previously unanimatable CSS values, like switching justify-content between flex-start and flex-end.

<motion.div
  layout
  style={{ justifyContent: isOn ? "flex-start" : "flex-end" }}
/>

Or by using the layoutId prop, it's possible to match two elements and animate between them for some truly advanced animations.

<motion.li layoutId="item" />

It can handle anything from microinteractions to full page transitions.

Usage

Any layout change that happens as a result of a React re-render can be animated. 

<motion.div layout style={{ width: isOpen ? "80vw" : 0 }} />

Note that CSS changes should happen immediately via style, not animate, as layout will take care of the animation.

Layout changes can be anything, changing width/height, number of grid columns, reordering a list, or adding/removing new items:

Shared layout animations

When a new component is added that has a layoutId prop that matches an existing component, it will automatically animate out from the old component.

isSelected && <motion.div layoutId="underline" />

If the old component is still mounted when the new component enters, they will automatically crossfade from the old to the new.

When removing an element to animate back to its origin layout, AnimatePresence can be used to keep it in the DOM until its exit animation has finished.

<AnimatePresence>
  {isOpen && <motion.div layoutId="modal" />}
</AnimatePresence>
Setting a transition

Layout animations can be customised using the transition prop.

<motion.div layout transition={{ duration: 0.3 }} />

If you want to set a transition specifically for only the layout animation, you can specify a specific layout transition.

<motion.div
  layout
  animate={{ opacity: 0.5 }}
  transition={{
    default: { ease: "linear" },
    layout: { duration: 0.3 }
  }}
/>

When performing a shared layout animation, the transition defined for element we're animating to will be used.

<>
  <motion.button
    layoutId="modal"
    onClick={() => setIsOpen(true)}
    // This transition will be used when the modal closes
    transition={{ type: "spring" }}
  >
    Open
  </motion.button>
  <AnimatePresence>
    {isOn && (
      <motion.dialog
        layoutId="modal"
        // This transition will be used when the modal opens
        transition={{ duration: 0.3 }}
      />
    )}
  </AnimatePresence>
</>
Animating within scrollable element

To correctly animate layout within scrollable elements, we need to provide them the layoutScroll prop.

<motion.div layoutScroll style={{ overflow: "scroll" }} />

This lets Motion account for the element's scroll offset when measuring children.

Animating within fixed containers

To correctly animate layout within fixed elements, we need to provide them the layoutRoot prop.

<motion.div layoutRoot style={{ position: "fixed" }} />

This lets Motion account for the page's scroll offset when measuring children.

Group layout animations

Layout animations are triggered when a component re-renders and its layout has changed.

function Accordion() {
  const [isOpen, setOpen] = useState(false)
  
  return (
    <motion.div
      layout
      style={{ height: isOpen ? "100px" : "500px" }}
      onClick={() => setOpen(!isOpen)}
    />
  )
}

But what happens when we have two or more components that don't re-render at the same time, but do affect each other's layout?

function List() {
  return (
    <>
      <Accordion />
      <Accordion />
    </>  
  )
}

When one re-renders, for performance reasons the other won't be able to detect changes to its layout.

We can synchronise layout changes across multiple components by wrapping them in the LayoutGroup component.

import { LayoutGroup } from "motion/react"

function List() {
  return (
    <LayoutGroup>
      <Accordion />
      <Accordion />
    </LayoutGroup>  
  )
}

When layout changes are detected in any grouped motion component, layout animations will trigger across all of them.

Scale correction

All layout animations are performed using the transform style, resulting in smooth framerates.

Animating layout using transforms can sometimes visually distort children. To correct this distortion, the first child elements of the element can also be given layout property.

Open this sandbox and try removing layout from the pink dot to see the difference this will make:

Transforms can also distort boxShadow and borderRadius. The motion component will automatically correct this distortion on both props, as long as they're set as motion values.

If you're not animating these values, the easiest way to do this is to set them via style.

<motion.div layout style={{ borderRadius: 20 }} />
Troubleshooting
The component isn't animating

Ensure the component is not set to display: inline, as browsers don't apply transform to these elements.

Ensure the component is re-rendering when you expect the layout animation to start.

SVG layout animations are broken

SVG components aren't currently supported with layout animations. SVGs don't have layout systems so it's recommended to directly animate their attributes like cx etc.

The content stretches undesirably

This is a natural side-effect of animating width and height with scale.

Often, this can be fixed by providing these elements a layout animation and they'll be scale-corrected.

<motion.section layout>
  <motion.img layout />
</motion.section>

Some elements, like images or text that are changing between different aspect ratios, might be better animated with layout="position".

Border radius or box shadows are behaving strangely

Animating scale is performant but can distort some styles like border-radius and box-shadow.

Motion automatically corrects for scale distortion on these properties, but they must be set on the element via style.

<motion.div layout style={{ borderRadius: 20 }} />
Border looks stretched during animation

Elements with a border may look stretched during the animation. This is for two reasons:

Because changing border triggers layout recalculations, it defeats the performance benefits of animating via transform. You might as well animate width and height classically.




border can't render smaller than 1px, which limits the degree of scale correction that Motion can perform on this style.

A work around is to replace border with a parent element with padding that acts as a border.

<motion.div layout style={{ borderRadius: 10, padding: 5 }}>
  <motion.div layout style={{ borderRadius: 5 }} />
</motion.div>
Technical reading

Interested in the technical details behind layout animations? Nanda does an incredible job of explaining the challenges of animating layout with transforms using interactive examples. Matt, creator of Motion, did a talk at Vercel conference about the implementation details that is largely up to date. 

Differences with the View Transitions API

More browsers are starting to support the View Transitions API, which is similar to Motion's layout animations.

Benefits of View Transitions API

The main two benefits of View Transitions is that it's included in browsers and features a unique rendering system.

Filesize

Because the View Transitions API is already included in browsers, it's cheap to implement very simple crossfade animations.

However, the CSS complexity can scale quite quickly. Motion's layout animations are around 12kb but from there it's very cheap to change transitions, add springs, mark matching 

Rendering

Whereas Motion animates the elements as they exist on the page, View Transitions API does something quite unique in that it takes an image snapshot of the previous page state, and crossfades it with a live view of the new page state.

For shared elements, it does the same thing, taking little image snapshots and then crossfading those with a live view of the element's new state.

This can be leveraged to create interesting effects like full-screen wipes that aren't really in the scope of layout animations. Framer's Page Effects were built with the View Transitions API and it also extensively uses layout animations. The right tool for the right job.

Drawbacks to View Transitions API

There are quite a few drawbacks to the API vs layout animations:

Not interruptible: Interrupting an animation mid-way will snap the animation to the end before starting the next one. This feels very janky.




Blocks interaction: The animating elements overlay the "real" page underneath and block pointer events. Makes things feel quite sticky.




Difficult to manage IDs: Layout animations allow more than one element with a layoutId whereas View Transitions will break if the previous element isn't removed.




Less performant: View Transitions take an actual screenshot and animate via width/height vs layout animation's transform. This is measurably less performant when animating many elements.




Doesn't account for scroll: If the page scroll changes during a view transition, elements will incorrectly animate this delta.




No relative animations: If a nested element has a delay it will get "left behind" when its parent animates away, whereas Motion handles this kind of relative animation.




One animation at a time: View Transitions animate the whole screen, which means combining it with other animations is difficult and other view animations impossible.

All-in-all, each system offers something different and each might be a better fit for your needs. In the future it might be that Motion also offers an API based on View Transitions API.

Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving layout animations, including:

Scroll animations

motion

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#exit-animations

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-animate-presence

Docs

Examples

Motion+

Documentation

React

AnimatePresence

AnimatePresence

AnimatePresence makes exit animations easy. By wrapping one or more motion components with AnimatePresence, we gain access to the exit animation prop.

<AnimatePresence>
  {show && <motion.div key="modal" exit={{ opacity: 0 }} />}
</AnimatePresence>
Usage
Import
import { AnimatePresence } from "motion/react"
Exit animations

AnimatePresence works by detecting when its direct children are removed from the React tree.

This can be due to a component mounting/remounting:

<AnimatePresence>
  {show && <Modal key="modal" />}
</AnimatePresence>

Its key changing:

<AnimatePresence>
  <Slide key={activeItem.id} />
</AnimatePresence>

Or when children in a list are added/removed:

<AnimatePresence>
  {items.map(item => (
    <motion.li key={item.id} exit={{ opacity: 1 }} layout />
  ))}
</AnimatePresence>

Any motion components within the exiting component will fire animations defined on their exit props before the component is removed from the DOM.

function Slide({ img, description }) {
  return (
    <motion.div exit={{ opacity: 0 }}>
      <img src={img.src} />
      <motion.p exit={{ y: 10 }}>{description}</motion.p>
    </motion.div>
  )
}

Note: Direct children must each have a unique key prop so AnimatePresence can track their presence in the tree.

Like initial and animate, exit can be defined either as an object of values, or as a variant label.

const modalVariants = {
  visible: { opacity: 1, transition: { when: "beforeChildren" } },
  hidden: { opacity: 0, transition: { when: "afterChildren" } }
}

function Modal({ children }) {
  return (
    <motion.div initial="hidden" animate="visible" exit="hidden">
      {children}
    </motion.div>
  )
}
Changing key

Changing a key prop makes React create an entirely new component. So by changing the key of a single child of AnimatePresence, we can easily make components like slideshows.

export const Slideshow = ({ image }) => (
  <AnimatePresence>
    <motion.img
      key={image.src}
      src={image.src}
      initial={{ x: 300, opacity: 0 }}
      animate={{ x: 0, opacity: 1 }}
      exit={{ x: -300, opacity: 0 }}
    />
  </AnimatePresence>
)
Access presence state

Any child of AnimatePresence can access presence state with the useIsPresence hook.

import { useIsPresent } from "motion/react"

function Component() {
  const isPresent = useIsPresent()

  return isPresent ? "Here!" : "Exiting..."
}

This allows you to change content or styles when a component is no longer rendered.

Access presence data

When a component has been removed from the React tree, its props can no longer be updated. We can use AnimatePresence's custom prop to pass new data down through the tree, even into exiting components.

<AnimatePresence custom={swipeDirection}>
  <Slide key={activeSlideId}>

Then later we can extract that using usePresenceData.

import { AnimatePresence, usePresenceData } from "motion/react"

function Slide() {
  const isPresent = useIsPresent()
  const direction = usePresenceData()

  return (
    <motion.div exit={{ opacity: 0 }}>
      {isPresent ? "Here!" : "Exiting " + direction}
    </motion.div>
  )
}
Manual usage

It's also possible to manually tell AnimatePresence when a component is safe to remove with the usePresence hook.

This returns both isPresent state and a callback, safeToRemove, that should be called when you're ready to remove the component from the DOM (for instance after a manual animation or other timeout).

import { usePresence } from "motion/react"

function Component() {
  const [isPresent, safeToRemove] = usePresence()

  useEffect(() => {
    // Remove from DOM 1000ms after being removed from React
    !isPresent && setTimeout(safeToRemove, 1000)
  }, [isPresent])

  return <div />
}
Propagate exit animations

By default, AnimatePresence controls the exit animations on all of its children, until another AnimatePresence component is rendered.

<AnimatePresence>
  {show ? (
    <motion.section exit={{ opacity: 0 }}>
      <AnimatePresence>
        {/*
          * When `show` becomes `false`, exit animations
          * on these children will not fire.
          */}
        {children}
      </AnimatePresence>
    </motion.section>
  ) : null}
</AnimatePresence>

By setting an AnimatePresence component's propagate prop to true, when it's removed from another AnimatePresence it will fire all of its children's exit animations.

<AnimatePresence>
  {show ? (
    <motion.section exit={{ opacity: 0 }}>
      <AnimatePresence propagate>
        {/*
          * When `show` becomes `false`, exit animations
          * on these children **will** fire.
          */}
        {children}
      </AnimatePresence>
    </motion.section>
  ) : null}
</AnimatePresence>
Props
initial

By passing initial={false}, AnimatePresence will disable any initial animations on children that are present when the component is first rendered.

<AnimatePresence initial={false}>
  <Slide key={activeItem.id} />
</AnimatePresence>
custom

When a component is removed, there's no longer a chance to update its props (because it's no longer in the React tree). Therefore we can't update its exit animation with the same render that removed the component.

By passing a value through AnimatePresence's custom prop, we can use dynamic variants to change the exit animation.

const variants = {
  hidden: (direction) => ({
    opacity: 0,
    x: direction === 1 ? -300 : 300
  }),
  visible: { opacity: 1, x: 0 }
}

export const Slideshow = ({ image, direction }) => (
  <AnimatePresence custom={direction}>
    <motion.img
      key={image.src}
      src={image.src}
      variants={variants}
      initial="hidden"
      animate="visible"
      exit="hidden"
    />
  </AnimatePresence>
)

This data can be accessed by children via usePresenceData.

mode

Default: "sync"

Decides how AnimatePresence handles entering and exiting children.

"sync": Children animate in/out as soon as they're added/removed.




"wait": The entering child will wait until the exiting child has animated out. Note: Currently only renders a single child at a time.




"popLayout": Exiting children will be "popped" out of the page layout. This allows surrounding elements to move to their new layout immediately.

Custom component note: When using popLayout mode, any immediate child of AnimatePresence that's a custom component must be wrapped in React's forwardRef function, forwarding the provided ref to the DOM node you wish to pop out of the layout.

onExitComplete

Fires when all exiting nodes have completed animating out.

propagate

Default: false

If set to true, exit animations on children will also trigger when this AnimatePresence exits from a parent AnimatePresence.

<AnimatePresence>
  {show ? (
    <motion.section exit={{ opacity: 0 }}>
      <AnimatePresence propagate>
        {/* This exit prop will now fire when show is false */}
        <motion.div exit={{ x: -100 }} />
      </AnimatePresence>
    </motion.section>
  ) : null}
</AnimatePresence>
Troubleshooting
Exit animations aren't working

Ensure all immediate children get a unique key prop that remains the same for that component every render.

For instance, providing index as a key is bad because if the items reorder then the index will not be matched to the item:

<AnimatePresence>
  {items.map((item, index) => (
    <Component key={index} />
  ))}
</AnimatePresence>

It's preferred to pass something that's unique to that item, for instance an ID:

<AnimatePresence>
  {items.map((item) => (
    <Component key={item.id} />
  ))}
</AnimatePresence>

Also make sure AnimatePresence is outside of the code that unmounts the element. If AnimatePresence itself unmounts, then it can't control exit animations!

For example, this will not work:

isVisible && (
  <AnimatePresence>
    <Component />
  </AnimatePresence>
)

Instead, the conditional should be at the root of AnimatePresence:

<AnimatePresence>
  {isVisible && <Component />}
</AnimatePresence>
Layout animations not working with mode="sync"

When mixing layout and exit animations, it might be necessary to wrap the group in LayoutGroup to ensure that components outside of AnimatePresence know when to perform a layout animation.

<LayoutGroup>
  <motion.ul layout>
    <AnimatePresence>
      {items.map(item => (
        <motion.li layout key={item.id} />
      ))}
    </AnimatePresence>
  </motion.ul>
</LayoutGroup>
Layout animations not working with mode="popLayout"

When any HTML element has an active transform it temporarily becomes the offset parent of its children. This can cause children with position: "absolute" not to appear where you expect.

mode="popLayout" works by using position: "absolute". So to ensure consistent and expected positioning during a layout animation, ensure that the animating parent has a position other than "static".

<motion.ul layout style={{ position: "relative" }}>
  <AnimatePresence mode="popLayout">
    {items.map(item => (
      <motion.li layout key={item.id} />
    ))}
  </AnimatePresence>
</motion.ul>
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving AnimatePresence, including:

motion

AnimateNumber

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-quick-start#learn-next

Docs

Examples

Motion+

Documentation

React

Quick start

Quick start

Motion for React is a simple yet limitless animation library. It's the only animation library with a hybrid engine, capable of hardware accelerated animations.

It's also trusted by Framer to power its amazing no-code animations and gestures.

In this guide, we'll learn how to install Motion and take a whirlwind tour of its main features.

Install

Motion is available via npm:

npm install motion

Features can now be imported via "motion/react":

import { motion } from "motion/react"

Note: Motion for React contains APIs specifically tailored for React, but every feature from vanilla Motion is also compatible and available for advanced use-cases.

Usage

The core of Motion for React is the <motion /> component. It's a normal DOM element, supercharged with animation capabilities.

<motion.div />

Animating a motion component is as straightforward as setting values via the animate prop:

<motion.ul animate={{ rotate: 360 }} />

When values in animate change, the component will animate. Motion has great-feeling defaults, but animations can of course be configured via the transition prop.

<motion.div
  animate={{
    scale: 2,
    transition: { duration: 2 }
  }}
/>
Enter animation

When a component enters the page, it will automatically animate from the rendered value, but you can provide different values via the initial prop.

<motion.button initial={{ scale: 0 }} animate={{ scale: 1 }} />

Or disable this initial animation entirely by setting initial to false.

<motion.button initial={false} animate={{ scale: 1 }} />
Gestures

<motion /> extends React's event system with powerful gesture recognises. It currently supports hover, tap, focus, and drag.

<motion.button
  whileHover={{ scale: 1.1 }}
  whileTap={{ scale: 0.95 }}
  onHoverStart={() => console.log('hover started!')}
/>

Motion's gestures are designed to feel better than using CSS alone. For instance, hover events are correctly not triggered by touch screen taps. Learn more about gestures.

Scroll animations

Motion supports both types of scroll animations, scroll-triggered and scroll-linked.

To trigger an animation on scroll, the whileInView prop defines a state to animate to/from when an element enters/leaves the viewport:

<motion.div
  initial={{ backgroundColor: "rgb(0, 255, 0)", opacity: 0 }}
  whileInView={{ backgroundColor: "rgb(255, 0, 0)", opacity: 1 }}
/>

Whereas to link a value directly to scroll position, it's possible to use MotionValues via useScroll.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

Learn more about Motion's scroll animations.

Layout animations

Motion has an industry-leading layout animation engine that supports animating between changes in layout, using only transforms, between the same or different elements, with full scale correction.

It's as easy as applying the layout prop.

<motion.div layout />

Or to animate between different elements, a layoutId:

<motion.div layoutId="underline" />

Learn more about layout animations.

Exit animations

Animating elements when they're removed from the DOM is usually messy.

By wrapping motion components with <AnimatePresence> we gain access to the exit prop. 

<AnimatePresence>
  {show ? <motion.div key="box" exit={{ opacity: 0 }} /> : null}
</AnimatePresence>

Learn more about AnimatePresence.

Learn next

That's a very quick overview of Motion for React's basic features. But there's a lot more to learn! 

Next, we recommend diving further into the the <motion /> component to learn more about its powerful features, like variants.

Or, you can dive straight in to our examples, where each example comes complete with full source code that you can copy/paste into your project.

Improvements to Web Animations API

Animation

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/improvements-to-the-web-animations-api-dx

Docs

Examples

Motion+

Documentation

JavaScript

Improvements to Web Animations API

Improvements to Web Animations API

Motion is the only animation library with a hybrid engine, meaning its capable of dynamically running animations either via requestAnimationFrame or via the Web Animations API (WAAPI).

This allows it to animate any value, for any render target (DOM, Three.js, canvas) while also retaining the ability to run animations with hardware acceleration.

Its animate function comes in two sizes, mini (2.5kb) and hybrid (17kb).

Both functions provide a number of improvements to the feature set and developer experience of WAAPI, in this guide we'll take a look at some.

Springs and custom easing functions

CSS and WAAPI only support in-built easing functions like "back-in", "ease-in-out" etc.

Motion extends that to support any custom easing function by automatically generating a linear() CSS easing definition in modern browsers, with a safe fallback in older browsers

animate(
  "li",
  { opacity: 1 },
  { ease: mirrorEasing(Math.sin) }
)

Additionally, it supports spring animations in animateStyle by compiling the spring into a linear() easing and computing the appropriate duration. Whereas in the animate function it will pre-calculate the actual keyframes for real physics-based animations.

import { animate } from "motion/dom"
import { spring } from "motion"


animate(
  "li",
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 400 }
)
Default value types

WAAPI always expects a unit type for various animatable values, which can be easy to forget.

element.animate({ width: "100px" })
element.animate({ width: 100 }) // Error!

Motion knows the default value type for all popular values.

animate(element, { width: 100 })
.finished Promise

As a newer part of the WAAPI spec, the animation.finished Promise isn't supported in every browser. Motion will polyfill it in those browsers:

const animation = animate("#box", { opacity: 0 })

// Async
await animation

// Promise
animation.then(() => {})
Durations as seconds

In WAAPI (and a subset of other JavaScript animation libraries), durations are set as milliseconds:

const animation = element.animate({ x: 50 }, { duration: 2000 })
animation.currentTime = 1000

During development of Framer Motion, user testing revealed that most of our audience find seconds a more approachable unit. So in Motion, durations are defined in seconds.

const animation = animate(element, { x: 50 }, { duration: 2 })
animation.currentTime = 1
Persisting animation state

In a typical animation library, when an animation has finished, the element (or other animated object) is left in the animation's final state.

But when you call WAAPI's animate function like this:

element.animate({ opacity: 0 })

This is the result:

Play

The animation ends in its initial state!

WAAPI has an option you can set to fix this behaviour. Called fill, when set to "forwards" it will persist the animation beyond its timeline.

element.animate({ opacity: 0 }, { fill: "forwards" })

But this is discouraged even in the official spec. fill: "forwards" doesn't exactly change the behaviour of the animation, it's better to think of it keeping the animation active indefinitely. As WAAPI animations have a higher priority than element.style, the only way to change the element's styles while these animations are active is with more animations!

Keeping all these useless animations around can also lead to memory leaks.

The spec offers two solutions. One, adding a Promise handler that manually sets the final keyframe target to element.style:

await element.animate({ opacity: 0 }, 200).finished
  
element.style.opacity = 0

The second is to immediately set element.style to the animation target, then animate from its current value and let the browser figure out the final keyframe itself.

const opacity = element.style.opacity
element.style.opacity = 1
element.animate({ opacity, offset: 0 }, 200)

Each approach has pros and cons. But a major con they both share is making the user decide. These are unintuitive fixes to an unintuitive behaviour, and whichever is chosen necessitates a wrapping library because repeating these brittle patterns is bad for readability and stability.

So instead, Motion's animate function will actually animate to a value, leaving in its target state once the animation is complete.

animate(element, { opacity: 0 })
Play
Stop animations

WAAPI's animate function returns an Animation, which contains a cancel method.

const animation = element.animate({ opacity: 0 }, { duration: 1000 })
setTimeout(() => { animation.cancel()}, 500)

When cancel is called, the animation is stopped and "removed". It's as if the animation never played at all:

Play

Motion adds a stop method. This cancels the animation but also leaves the element in its current state:

const animation = animate(element, { opacity: 0 }, { duration: 1000 })
setTimeout(() => { animation.stop()}, 500)
Play
Partial/inferred keyframes

In early versions of the WAAPI spec, two or more keyframes must be defined:

element.animate({ opacity: [0.2, 1] })

However, it was later changed to allow one keyframe. The browser will infer the initial keyframe based on the current visual state of the element.

element.animate({ opacity: 1 })

Some legacy browsers, including the common WAAPI polyfills, only support the old syntax. Which means if you try and use WAAPI as currently documented, it will throw an error in many older browsers.
Motion's animate function automatically detects these browsers and will generate an initial keyframe from window.getComputedStyle(element) where necessary.

Interrupting animations

WAAPI has no concept of "interrupting" existing animations. So if one animation starts while another is already playing on a specific value, the new animation simply "overrides" the existing animation.

If the old animation is still running when the new one finishes, the animating value will appear to "jump" back to the old animation.

element.animate(
  { transform: ["none", "translateX(300px)"] },
  { duration: 2000, iterations: Infinity, direction: "alternate" }
)
  
setTimeout(() => {
  element.animate({ transform: "none" }, { duration: 500 })
}, 500)
Interrupt

Motion automatically interrupts the animation of any values passed to animate and animates on to the new target:

animate(
  element,
  { transform: "translateX(300px)" },
  { duration: 2, iterations: Infinity }
)
  
setTimeout(() => {
  animate(element, { transform: "none" }, { duration: 500 })
}, 500)
Interrupt
Cubic bezier definitions

In WAAPI, cubic bezier easing is defined as a CSS string:

element.animate(
  { transform: "translateX(50px)" },
  { easing: "cubic-bezier(0.29, -0.13, 0.18, 1.18)" }
)

This kind of definition will work in Motion, but we also allow this shorthand array syntax:

animate(
  element,
  { transform: "translateX(50px)" },
  { ease: [0.29, -0.13, 0.18, 1.18] }
)
Independent transforms (animate-only)

Because CSS doesn't offer styles for x, scaleX etc, you can't animate these properties with WAAPI. Instead, you have to animate the full transform string:

element.animate({ transform: "translateX(50px) scaleX(2)" })

This isn't just a matter of developer aesthetics. It means it's literally impossible to animate these properties with separate animations, or with different animation options.

Some modern browsers allow translate, scale and rotate to be defined and animated separately, but even then you can't animate the axis of each.

Motion still allows the animation of transform, but adds the ability to animate all transforms individually, for all axes:

animate(element, { x: 50, scaleX: 2 })

Which means you can also animate them with different options:

animate(
  element,
  { x: 50, scaleX: 2 },
  { x: { duration 2 }, scaleX: { repeat: 1 } }
)

Migrate from GSAP to Motion

Quick start

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/react-animation

Docs

Examples

Motion+

Documentation

React

Overview

Animation

Motion for React offers a number of ways to animate your UI. Scaling from extremely simple prop-based animations, to more complex orchestration.

Basic animations

You'll perform almost all animations on a <motion /> component. This is basically a DOM element with motion superpowers.

import { motion } from "motion/react"

For basic animations, you can update values on the animate prop:

<motion.div animate={{ opacity: 1 }} />

When any value in its animate prop changes, the component will automatically animate to the new target.

Animatable values

Motion can animate any CSS value, even those that can't be animated by browsers, like mask-image. It supports:

Numbers: 0, 100 etc.




Strings containing numbers: "0vh", "10px" etc.




Colors: Hex, RGBA, HSLA.




Complex strings containing multiple numbers and/or colors (like box-shadow).




display: none/block and visibility: hidden/visible.

Value type conversion

In general, values can only be animated between two of the same type (i.e "0px" to "100px").

However, x, y, width, height, top, left, right and bottom can animate between different value types.

<motion.div
  initial={{ x: "100%" }}
  animate={{ x: "calc(100vw - 50%)" }}
/>

Additionally, hex, RGBA and HSLA can be animated between on another.

Transforms

Unlike CSS, Motion can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

motion components have enhanced style props, allowing you to set individual transforms:

<motion.section style={{ x: -20 }} />

Animating transforms independently provides great flexibility, especially around gestures.

<motion.button whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} />

Independent transforms perform great, but Motion's hybrid engine also uniquely offers hardware acceleration by setting transform directly.

<motion.li
  initial={{ transform: "translateX(-100px)" }}
  animate={{ transform: "translateX(0px)" }}
  transition={{ type: "spring" }}
/>

SVG note: For SVG components, x and y attributes can be set using attrX and attrY.

Transform origin

transform-origin has three shortcut values that can be set and animated individually:

originX




originY




originZ

If set as numbers, originX and Y default to a progress value between 0 and 1. originZ defaults to pixels.

<motion.div style={{ originX: 0.5 }} />
CSS variables

Motion for React can animate the value of CSS variables, and also use CSS variables as animation targets.

Animating CSS variables

Sometimes it's convenient to be able to animate a CSS variable to animate many children:

<motion.ul
  initial={{ '--rotate': '0deg' }}
  animate={{ '--rotate': '360deg' }}
  transition={{ duration: 2, repeat: Infinity }}
>
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
</motion.ul>

Note: Animating the value of a CSS variable always triggers paint, therefore it can be more performant to use MotionValues to setup this kind of animation.

CSS variables as animation targets

HTML motion components accept animation targets with CSS variables:

<motion.li animate={{ backgroundColor: "var(--action-bg)" }} />
SVG line drawing

Line drawing animations can be created with many different SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

<motion.path initial={{ pathLength: 0 }} animate={{ pathLength: 1 }} />

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Transitions

By default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.

For instance, physical properties like x or scale are animated with spring physics, whereas values like opacity or color are animated with duration-based easing curves.

However, you can define your own animations via the transition prop.

<motion.div
  animate={{ x: 100 }}
  transition={{ ease: "easeOut", duration: 2 }}
/>
Enter animations

When a motion component is first created, it'll automatically animate to the values in animate if they're different from those initially rendered, which you can either do via CSS or via the initial prop. 

<motion.li
  initial={{ opacity: 0, scale: 0 }}
  animate={{ opacity: 1, scale: 1 }}
/>

You can also disable the enter animation entirely by setting initial={false}. This will make the element render with the values defined in animate.

<motion.div initial={false} animate={{ y: 100 }} />
Exit animations

You can also easily animate elements as they exit the DOM.

In React, when a component is removed, it's usually removed instantly. Motion provides the AnimatePresence component which keeps elements in the DOM while they perform an exit animation.

<AnimatePresence>
  {isVisible && (
    <motion.div
      key="modal"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    />
  )}
</AnimatePresence>
Keyframes

Values in animate can be set as a series of keyframes. This will animate through each value in sequence.

<motion.div animate={{ x: [0, 100, 0] }} />

We can use a value's current state as the initial keyframe by setting it to null.

<motion.div animate={{ x: [null, 100, 0] }} />

This way, if a keyframe animation is interrupting another animation, the transition will feel more natural.

By default, each keyframe is spaced naturally throughout the animation. You can override this by setting the times option via transition.

times is an array of progress values between 0 and 1, defining where in the animation each keyframe should be positioned.

<motion.circle
  cx={500}
  animate={{
    cx: [null, 100, 200],
    transition={{ duration: 3, times: [0, 0.2, 1] }}
  }}
/>
Gesture animations

Motion for React has shortcut props for animating to/from a target when a gesture starts/ends.

<motion.button
  initial={{ opacity: 0 }}
  whileHover={{ backgroundColor: "rgba(220, 220, 220, 1)" }}
  whileTap={{ backgroundColor: "rgba(255, 255, 255, 1)" }}
  whileInView={{ opacity: 1 }}
/>

It supports hover, tap, drag, focus and inView.

Variants

Setting animate as a target is useful for simple, single-element animations. But sometimes we want to orchestrate animations that propagate throughout the DOM. We can do so with variants.

Variants are a set of named targets.

const variants = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

They're passed to motion components via the variants prop:

<motion.div variants={variants} />

These variants can now be referred to by a label, wherever you can define an animation target:

<motion.div
  variants={variants}
  initial="hidden"
  whileInView="visible"
/>

You can also define multiple variants via an array:

animate={["visible", "danger"]}

I love using variants alongside React state – just pass your state to animate, and now you've got a tidy place to define all your animation targets!

const [status, setStatus] = useState<"inactive" | "active" | "complete">(
  "inactive"
);

<motion.div
  animate={status} // pass in our React state!
  variants={{
    inactive: { scale: 0.9 color: "var(--gray-500)" },
    active: { scale: 1 color: "var(--blue-500)" },
    complete: { scale: 1 color: "var(--blue-500)" }
  }}
>
  <motion.svg
    path={checkmarkPath}
    variants={{
      inactive: { pathLength: 0 },
      active: { pathLength: 0 },
      complete: { pathLength: 1}
    }}
  />
</motion.div>

~ Sam Selikoff, Motion for React Recipes

Propagation

This is already useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.

Variants will flow down through motion components. So in this example when the ul enters the viewport, all of its children with a "visible" variant will also animate in:

const list = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

const item = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
}

return (
  <motion.ul
    initial="hidden"
    whileInView="visible"
    variants={list}
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
Orchestration

By default, this children animations will start simultaneously with the parent. But with variants we gain access to new transition props like when, delayChildren, staggerChildren and staggerDirection.

const list = {
  visible: {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      staggerChildren: 0.3, // Stagger children by .3 seconds
    },
  },
  hidden: {
    opacity: 0,
    transition: {
      when: "afterChildren",
    },
  },
}
Dynamic variants

Each variant can be defined as a function that resolves when a variant is made active.

const variants = {
  hidden: { opacity: 0 },
  visible: (index) => ({
    opacity: 1,
    transition: { delay: index * 0.3 }
  })
}

These functions are provided a single argument, which is passed via the custom prop:

items.map((item, index) => <motion.div custom={index} variants={variants} />)

This way, variants can be resolved differently for each animating element.

Animation controls

Declarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.

The useAnimate hook can be used for:

Animating any HTML/SVG element (not just motion components).




Complex animation sequences.




Controlling animations with time, speed, play(), pause() and other playback controls.

function MyComponent() {
  const [scope, animate] = useAnimate()

  useEffect(() => {
    const controls = animate([
      [scope.current, { x: "100%" }],
      ["li", { opacity: 1 }]
    ])

    controls.speed = 0.8

    return () => controls.stop()
  }, [])

  return (
    <ul ref={scope}>
      <li />
      <li />
      <li />
    </ul>
  )
}
Animate content

By passing a MotionValue as the child of a motion component, it will render its latest value in the HTML.

import { useMotionValue, motion, animate } from "motion/react"

function Counter() {
  const count = useMotionValue(0)

  useEffect(() => {
    const controls = animate(count, 100, { duration: 5 })
    return () => controls.stop()
  }, [])

  return <motion.pre>{count}</motion.pre>
}

This is more performant than setting React state as the motion component will set innerHTML directly.

Quick start

Transitions

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/css#import

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")

element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#overview

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")

element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/tailwind

Docs

Examples

Motion+

404 not found

Go home

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/docs/css#server-generation

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#react-server-components

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#client-generation

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#style-attribute

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#css-in-js

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#styled-components

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#tamagui

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#astro

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#vue

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/css#fallbacks

Docs

Examples

Motion+

Documentation

JavaScript

CSS

CSS

It's common to reach for a JavaScript library like Motion when you want to perform spring animations. But Motion is also capable of generating springs via CSS, both on the server and in the browser.

In this guide, we'll learn how to make spring animations with CSS, with a variety of libraries and frameworks:

React Server Components




Via the style attribute




CSS-in-JS (Styled Components, Tamagui)




Astro




React




Vue

We'll also learn how to fall back to either no animation or a different animation for cross-browser support.

Import

To generate our spring CSS rules, we're going to be using Motion's spring() function.

import { spring } from "motion"
Overview

spring has two features that makes it perfect for CSS generation.

A toString() method.




A spring(visualDuration, bounce) shorthand.

toString() returns the spring as a CSS duration and easing. The new shorthand makes it simpler than ever to make springs.

Put together, we can create CSS rules like this:

transition: transform ${spring(0.5, 0.2)};


// Outputs:
// transition: transform 800ms linear(...)

The generated duration can be longer than the one provided to spring because it accepts the new visualDuration option, which makes it easier to edit springs and coordinate them with other transitions:

transition:
  opacity 0.5s ease-out,
  transform ${spring(0.5, 0.2)};

Here, transform will actually take longer, but it will appear to take a similar amount of time to animate as opacity. This is because the visualDuration defines the amount of time the animation takes to first reach its target, not perform the "bouncy bit" after.

Server generation
React Server Components

With React Server Components (RSC), it's possible to set springs via the style prop.

<div style={{ transition: "all " + spring() }}>

This code will be run entirely server-side, with no runtime overhead.

It's also possible to use the style tag:

<style>{`
  button:hover {
    transition: transform ${spring(0.8, 0)};
    transform: scale(1.2);
  }
`}</style>
Client generation
style attribute

You can set transition on an element at runtime, before changing its other values.

const element = document.querySelector("button")


element.style.transition = "transform " + spring(0.3)
element.style.transform = "scale(1.2)"
CSS-in-JS

CSS-in-JS follows the same basic approach of string concatination, with the exact pattern depending on your library of choice:

Styled Components
const Button = styled.button`
  transition: opacity ${spring(0.5)};
`
Tamagui
export const RoundedSquare = styled(View, {
  transition: "opacity " + spring(0.5)
})
Astro

In Astro, you can define the spring as a CSS variable using JavaScript, and then in your CSS use that value with var():

<style define:vars={{ spring: spring(0.2, 0) }}>
  span {
    transition: transform var(--spring);
  }
</style>
Vue
const springTransition = ref(spring(0.3, 1))
<div :style="{ transition: 'filter ' + springTransition }"></div>
Fallbacks

By default, the browser will ignore your animation if it doesn't support the linear() easing function.

In CSS it's possible to set a second transition with a lower specificity to act as a fallback, though this might not be supported by all CSS generators (like setting via style):

transition: filter 0.3s ease-out;
transition: filter ${spring(0.3)};

This is another benefit of the spring() shorthand accepting visualDuration instead of duration - you can use the same duration for both of these animations and they'll feel like they take an equivalent time to complete.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#install

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"

  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"

  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"

  const isOpen = ref(false)

  function openModal() {
    view(async () => {
      isOpen.value = true

      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>

<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"

const header = useTemplateRef("header")

const props = defineProps({
  opacity: { type: Number, default: 1 }
})

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#enter-and-exit-animations

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"

  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"

  const isOpen = ref(false)

  function openModal() {
    view(async () => {
      isOpen.value = true

      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>

<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"

const header = useTemplateRef("header")

const props = defineProps({
  opacity: { type: Number, default: 1 }
})

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#view-animations

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"

  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"

  const isOpen = ref(false)

  function openModal() {
    view(async () => {
      isOpen.value = true

      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>

<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"

const header = useTemplateRef("header")

const props = defineProps({
  opacity: { type: Number, default: 1 }
})

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#animate-timeline-sequences

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"

const header = useTemplateRef("header")

const props = defineProps({
  opacity: { type: Number, default: 1 }
})

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#animate-on-prop-change

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"


const header = useTemplateRef("header")


const props = defineProps({
  opacity: { type: Number, default: 1 }
})


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"

watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#viewport-detection

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"


const header = useTemplateRef("header")


const props = defineProps({
  opacity: { type: Number, default: 1 }
})


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"

const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true

    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#scroll-triggered-animations

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"


const header = useTemplateRef("header")


const props = defineProps({
  opacity: { type: Number, default: 1 }
})


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"


const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking


onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>

<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })

    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"

let stopScrollAnimation

onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})

onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#scroll-linked-animations

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"


const header = useTemplateRef("header")


const props = defineProps({
  opacity: { type: Number, default: 1 }
})


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"


const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking


onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>


<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })


    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"


let stopScrollAnimation


onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})


onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/vue#next

Docs

Examples

Motion+

Documentation

JavaScript

Vue

Integrate Motion with Vue 3

Motion is fully framework agnostic, therefore it works within any JavaScript environment, including Vue 3. In this guide, we'll learn how to:

Animate on enter and exit




Perform view/layout animations




Animate timeline sequences




Animate when props change




Change HTML and CSS when an element enters or leaves the viewport




Animate on scroll

Install

Install Motion into the Vue project.

npm install motion
Enter and exit animations

To animate elements when they enter and exit the DOM, we can use Vue's Transition component.

<template>
  <Transition :css="false">
    <h1>Hello world</h1>
  </Transition>
</template>


<style>
  h1 { opacity: 0; }
</style>

Start by creating an onEnter function with Motion's animate function.

<script setup>
  import { animate } from "motion"


  async function onEnter(el, onComplete) {
    await animate(el, { opacity: 1 })
    onComplete()
  }
</script>

You can now provide this to Transition with the @enter event.

<Transition :css="false" @enter="onEnter">

Likewise, to animate when a component exits, you can make a onLeave function.

<script setup>
  import { animate } from "motion"


  async function onLeave(el, onComplete) {
    await animate(el, { opacity: 0 })
    onComplete()
  }
</script>

Then pass this to the @leave event.

<Transition :css="false" @leave="onLeave">
View animations

Motion's powerful view() function (currently in Motion+ early access) can perform full page transitions, animate between different layouts and even between different elements.

By await-ing Vue's nextTick function within view's update function, we ensure the view animation starts after the page has been updated.

<script setup>
  import { ref, nextTick } from "vue"


  const isOpen = ref(false)


  function openModal() {
    view(async () => {
      isOpen.value = true


      await nextTick()
    }).enter({ opacity: 1 })
  }
</script>


<template>
  <button @click="openModal">Open modal</button>
  <div :style="{display: isOpen ? 'block' : 'none'}" class="modal"></div>
</template>
Animate timeline sequences

onEnter and onLeave are passed the element provided as the first Transition child, in this case the ul:

<Transition :css="false" @enter="onEnter" @leave="onLeave">
  <ul>
    <li></li>
    <li></li>
    <li></li>
  </ul>
</Transition>

This is useful for building timeline animations scoped to the component:

async function onEnter(el, onComplete) {
  const sequence = [
    [el, { opacity: 1 }],
    [el.querySelectorAll("li"), { y: 100, opacity: 1 }]
  ]
  
  await animate(sequence)
  onComplete()
}
Animate on prop change

Using Vue's watch function and refs, we can start watching changes in props passed into the component to trigger animate calls.

import { useTemplateRef, defineProps, watch, onWatcherCleanup } from "vue"


const header = useTemplateRef("header")


const props = defineProps({
  opacity: { type: Number, default: 1 }
})


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
})

Add a cleanup function to ensure animations are stopped when the component's removed.

import { animate } from "vue"


watch(props, async () => {
  const animation = animate(header.value, { opacity: props.opacity })
  
  onWatcherCleanup(() => animation.stop())
})
Viewport detection

With Motion's inView function, it's possible to detect when an element enters or leaves the viewport and change its appearance accordingly.

Start by adding a ref to track visibility state:

<script setup>
import { ref, useTemplateRef } from "vue"
  
const isInView = ref(false)
const container = useTemplateRef("container")
</script>

We can attach a "container" ref to an element in our template:

<template>
  <div ref="container"></div>
</template>

We can now pass this element to inView within an onMounted lifecycle hook.

onMounted(() => {
  inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})

Finally, we want to make sure we clean up when the element's removed using the onUnmounted hook:

import { ref, onMounted, onUnmounted } from "vue"
import { inView } from "motion"


const isInView = ref(false)
const container = useTemplateRef("container")
let stopViewTracking


onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    isInView.value = true


    return () => {
      isInView.value = false
    }
  })
})
  
onUnmounted(() => stopViewTracking())

With this state now changing as the element enters/leaves the viewport, we can use this isInView state to animate with CSS by swapping out classes:

<template>
  <div ref="container" :class="{ 'in-view': isInView }"></div>
</template>


<style scoped>
  div {
    background-color: blue;
    transition: background-color 0.5s linear;
  }
  
  .in-view {
    background-color: red;
  }
</style>

Or to render different HTML entirely:

<div ref="container">
  <p v-if="isInView">Element in view</p>
  <p v-else>Element out of view</p>
</div>
Scroll-triggered animations

We can also use inView to trigger the animate function itself. This can be useful if we want to trigger more complex animation sequences or animate transforms independently of each other.

onMounted(() => {
  stopViewTracking = inView(container.value, () => {
    animate(container.value, { scale: 1.2 })


    return () => {
      animate(container.value, { scale: 1 })
    }
  })
})
Scroll-linked animations

The scroll function can be used to link animations and functions to scroll progress by using Vue's template refs and lifecycle functions as before.

import { scroll, animate } from "motion"
import { onMounted, onUnmounted } from "vue"


let stopScrollAnimation


onMounted(() => {
  stopScrollAnimation = scroll(
    animate(container.value, { transform: ["none", "rotate(90deg)"] })
  )
})


onUnmounted(() => stopScrollAnimation())
Next

With Motion set up in your Vue project, we recommend you follow the rest of the Quick Start guide to begin learning how to use Motion's animate, scroll and inView functions.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

          

---

# https://motion.dev/docs/framer#import

Docs

Examples

Motion+

Documentation

React

Framer

Framer

Framer is the world's best no-code website builder. If you have a Framer website, all your animations are already powered by Motion.

Framer offers a number of animations, interactions and components that mean you usually never need to write any code to achieve amazing effects.

However, advanced users can write code components and overrides, which are custom React components that you can drop into your canvas.

The full Motion for React API is available to use in both.

Import

Import Motion for React via "framer-motion":

import { motion, useSpring } from "framer-motion"

Use "framer-motion" whenever the Motion docs instruct you to use "motion/react".

Next

With Motion set up in your Framer project, we recommend you follow the rest of the Quick Start guide to begin learning Motion for React.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/framer#next

Docs

Examples

Motion+

Documentation

React

Framer

Framer

Framer is the world's best no-code website builder. If you have a Framer website, all your animations are already powered by Motion.

Framer offers a number of animations, interactions and components that mean you usually never need to write any code to achieve amazing effects.

However, advanced users can write code components and overrides, which are custom React components that you can drop into your canvas.

The full Motion for React API is available to use in both.

Import

Import Motion for React via "framer-motion":

import { motion, useSpring } from "framer-motion"

Use "framer-motion" whenever the Motion docs instruct you to use "motion/react".

Next

With Motion set up in your Framer project, we recommend you follow the rest of the Quick Start guide to begin learning Motion for React.

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

           

---

# https://motion.dev/docs/migrate-from-gsap-to-motion

Docs

Examples

Motion+

Documentation

JavaScript

GSAP migration

Migrate from GSAP to Motion

GSAP is an incredible animation library. But, you can achieve most of the same effects with Motion, with hardware accelerated performance, often for a far smaller bundlesize.

Unlike GSAP, Motion doesn't need a costly yearly license to run on commercial websites, as its supported by corporate sponsors and optional Motion+ memberships.

By the end of this guide we'll have learned the benefits and drawbacks of migrating, and also how to migrate basic animations, timeline sequences, scroll-linked and scroll-triggered animations, and React animations.

Benefits

Motion is built on modern browser APIs like Web Animations API (WAAPI) and Scroll Timeline, which is what enables it to offer hardware acceleration for common animations like transform, filter and opacity.

There are other optimisations, like using the Intersection Observer API for scroll-triggered animations rather than measuring the scroll position every frame (which can trigger style recalculations).

Likewise, when you start an animation with the animate function and it needs to read initial styles from the DOM, that process is batched and optimised, reducing layout thrashing and style recalculations.

Motion's APIs are generally smaller than GSAP too, with our scroll function is just 75% the size of its GSAP equivalent, and the mini animate function 90% smaller. Even the hybrid animate function, which offers timeline sequencing, independent transform animations, and more, is 18kb, smaller than the GSAP animation functions.

Finally, because Motion is built with ES modules, it is tree-shakable. Which means if you only import the scroll function, then only this code will end up being delivered to your users. This is an immediate SEO benefit of a few Lighthouse performance points.

Drawbacks

A robust feature comparison with GSAP can be found in our feature comparison guide, but the biggest missing feature from the Motion JavaScript API is layout animations.

Motion for React's layout animations go far beyond traditional "FLIP" techniques, with every animation performed with transforms, full scale correction for children and border-radius, and more. So if you are a keen user of GSAP's FLIP functionality then Motion doesn't offer a comparable API yet.

GSAP is also geared squarely towards power users, with APIs that we don't believe are used by the majority of users, like the ability to get/set a delay after an animation has started. Motion's philosophy is to tend towards a more accessible, smaller API, and this is shown in the relative filesizes.

Finally, animate's onUpdate callback is currently only available for animating single values, though this will change in the future.

Migrate

For this guide, we're going to take a look at the examples given in the GSAP documentation and see how we'd rewrite them in Motion.

Basic animations

The "Hello world' of JavaScript animations, a rotating box. In GSAP, this would be written with gsap.to:

gsap.to("#animate-anything-css", {
  duration: 10,
  ease: "none",
  repeat: -1,
  rotation: 360,
})

Motion's basic animation function is animate:

animate(
  "#animate-anything-css",
  { rotate: 360 },
  { ease: "linear", duration: 10, repeat: Infinity }
)

You can see here that it looks broadly similar, with a couple of key differences.

rotate instead of rotation




repeat: Infinity instead of -1 for infinitely-repeating animations




ease: "linear" instead of ease: "none"

Something else to note is that in GSAP the options and animating values are all bundled in together. Whereas with Motion, these are separate objects. This isn't of huge practical importance but when animating a plain object it means that object can't have properties with the same name as GSAP options.

GSAP has two other animation methods, fromTo and from. 

fromTo allows you to specify start and end keyframes:

gsap.fromTo(".box", { opacity: 0 }, { opacity: 0.5, duration: 1 })

With Motion, you just use the keyframe syntax:

animate(".box", { opacity: [0, 0.5] }, { duration: 1 })

This type of syntax (or equivalent also exists in GSAP, but fromTo is more of a legacy API.

from allows you to define values to animate from, with the target values being read from the DOM.

gsap.from(".box", { opacity: 0 })

Motion doesn't have a comparable API to this, but this is partly because we don't recommend it. Practically what has to happen here is GSAP reads the existing value from the DOM, set this as a target value, then animate from the given value. Unless the user writes their JavaScript to be render-blocking (discouraged), this "incorrect" style will be visible for a frame or more, which is rarely what we want.

Animation controls

Both GSAP and Motion animations return animation controls. GSAP offers far more here. For instance, each animation option gets a method to get/set that option, whereas Motion tends towards the immutability of options.

const animation = gsap.to()

animation.delay(0.5) // No Motion equivalent

However, there are some Motion equivalents to know about.

.timeScale() is .speed




.time() is .time




.kill() is .stop()




.revert() is .cancel()




.progress(1) is .complete()




.resume() is .play()

Timeline sequencing

Both Motion and GSAP offer timeline sequencing. The fundamental difference is that GSAP has a more imperative API, with a .timeline() constructor and .to, .add() and .addLabel() methods used to compose/amend the timeline:

const timeline = gsap.timeline(options)

timeline.to("#id", { x: 100, duration: 1 })
timeline.addLabel("My label")
timeline.to("#id", { y: 50, duration: 1 })

Whereas Motion uses a declarative array syntax:

const timeline = [
  ["#id", { x: 100, duration: 1 }],
  "My label",
  ["#id", { y: 100, duration: 1 }]
]

animate(timeline, options)

The benefit of the GSAP approach is it's easier to dynamically change a timeline in progress. Whereas with Motion, it's a little less boilerplate to compose long animations. 

Composing multiple timelines is different in each library, much as above:

// GSAP
timeline.add(timelineA)
timeline.add(timelineB)

// Motion
const timeline = [...timelineA, ...timelineB]
Scroll-triggered animations

Scroll-triggered animations are normal time-based animations that trigger when an element enters the viewport.

GSAP has the ScrollTrigger plugin whereas Motion uses inView function. 

// GSAP
gsap.to('.box', {
  scrollTrigger: '.box',
  x: 500
})

// Motion
inView(".box", ({ target }) => {
  animate(target, { x: 500 })
})

There fundamental technical difference between the two is inView is based on the browser's Intersection Observer API, which is a super-performant way of detecting when elements enter the viewport. Whereas ScrollTrigger measures the element and then tracks its position relative to scroll every frame. These reads/writes cause style recalculations.

Additionally, as inView only triggers when the tracked element enters the viewport, it means scroll-triggered animations are lazily initialised. In combination with Motion's deferred keyframe resolution, this can result in drastically shorter startup times when using many scroll-triggered animations.

Scroll-pinning

GSAP has an option called pin. If set, this will pin the element to the viewport during the scroll animation. For performance reasons, we recommend using CSS position: sticky instead.

Scroll-linked animations

By passing scrub: true to scrollTrigger, GSAP can create scroll-linked animations. These are fundamentally different in that instead of animations being driven by time, they're being driven by scroll progress instead.

gsap.to('.box', {
    scrollTrigger: {
      trigger: '.box',
      scrub: true
    }
    x: 500
});

In Motion, these kinds of animations are driven by the scroll function.

const animation = animate(element, { x: 500 })
scroll(animation, { target: element })

scroll is different in that, much like animate can use the Web Animations API for hardware accelerated performance, scroll can use the Scroll Timeline API for two performance benefits:

Enables hardware accelerated scroll animations




Can measure scroll progress for callbacks without polling scroll position (removing style recalculations)

Instead of start and end offset options, scroll accepts a single offset array, with options much like those found in GSAP.

scroll(callback, {
  target: element,
  offset: ["start start", "end start"] // Exits the viewport top
})

You can see here that instead of using "top"/"bottom", or "left"/"right", Motion uses the axis-agnostic "start" and "end" keywords.

The benefit of a single offset option is we can map more than two offsets to more than two animation keyframes. Here's an animation where the element fades in and out of the viewport:

const animation = animate(element, { opacity: [0, 1, 1, 0] })

scroll(animation, {
  target: element,
  offset: [
    // When the target starts entering the bottom of the viewport, opacity = 0
    "start end",
    // When the target is fully in the bottom of the viewport, opacity = 1
    "end end",
    // When the target starts exiting the top of the viewport, opacity = 1
    "start start",
    // When the target is fully off the top of the viewport, opacity = 0
    "end start"
  ]
})
React

Motion began life as a React animation library: Framer Motion. As such, its suite of React APIs goes far beyond GSAP's useGSAP function.

That said, you can achieve a similar pattern for a smaller bundlesize with Motion's useAnimate hook.

Take this rotating cube example from the GSAP docs:

const RotatingCube = () => {
  const boxRef = useRef()

  useGSAP(() => {
    gsap.to(boxRef.current, {
      duration: 10,
      repeat: -1,
      rotation: 360,
    })
  })

  return <div ref={boxRef} />
}

We can rewrite this with Motion's mini useAnimate, which offers a React interface to the 2.5kb animate function.

import { useAnimate } from "motion/react-mini"

const RotatingCube = () => {
  const [scope, animate] = useAnimate()

  useEffect(() => {
    const animation = animate(
      scope.current,
      { transform: "rotate(360deg)" },
      { duration: 10, repeat: Infinity }
    )

    return () => animation.stop()
  }, [])

  return <div ref={scope} />
}

Now we're running the same effect with 90% less code included in the bundlesize, plus the animation is running with hardware acceleration, which means fewer stutters (especially during React re-renders.

If you wanted to use { rotate: 360 } like in the GSAP example then that's also possible by using the hybrid animate function:

import { useAnimate } from "motion/react"
Conclusion

Although Motion and GSAP's feature sets don't fully overlap, thanks to modern practises and new browser APIs we think the majority of users will see better performance and lower filesizes by migrating to Motion.

Are there more GSAP features you'd like to see covered in this guide? Or a GSAP feature you'd like to see in Motion? Let me know!

FAQs

Improvements to Web Animations API

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/webflow#install

Docs

Examples

Motion+

Documentation

JavaScript

Webflow

Integrate Motion with Webflow

Webflow already comes with some animation capabilities, but it can be that you want to go that little bit further by introducing custom code:

Animate previously unanimatable values (like gradients and masks)




Hardware accelerated scroll animations




Complex timeline sequences




Three.js

If you're migrating from GSAP, you'll achieve better Lighthouse Performance scores, and you can even use Motion without a business license.

In this guide, we'll walk through how you can add Motion to your project, and give an overview of how to optionally generate custom scripts for even better performance.

Install

First, open the Pages dialog in your project and click "Edit page settings" on the page you want to add Motion to.

Scroll down until you find the "Before <body /> tag" dialog. In here, we can add our Motion code.

Here, you can add a new script block that imports Motion.

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/+esm"


  animate("header", { opacity: 1 })
</script>

You can replace 11.13.5 here with whichever version you want to install. The latest published version can be found on the npm package page.

This script contains all the Motion imports, but you can also achieve even greater filesize savings if you want to use just the mini version of the animate function, which is just 2.5kb, by importing from https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm:

<script type="module">
  import { animate } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm"
</script>
Custom scripts

By importing scripts directly from this URL, you're importing everything, even the bits of Motion you're not using. But, one of the great things about Motion is it's tree-shakable. This means you can use a bundler like Vite or Rollup to only include the bits you use.

In fact, this is a good practise for all of your Webflow custom code. It will ensure you package everything into one neat bundle and only package the bits you need.

For example, if you only wanted to use the animate function, you could replace the above code with this:

import { animate } from "motion"

animate("header", { opacity: 1 })

Building this with Rollup, uploading to a CDN, and then including with an async JS tag will boost SEO scores even further:

<script async src="https://yourdomain.com/my-script.js"></script>
Next

Now that you have Motion running in your Webflow project, you can follow our quick start guide to start making animations!

CSS

Integrate Motion with Vue 3

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/webflow#custom-scripts

Docs

Examples

Motion+

Documentation

JavaScript

Webflow

Integrate Motion with Webflow

Webflow already comes with some animation capabilities, but it can be that you want to go that little bit further by introducing custom code:

Animate previously unanimatable values (like gradients and masks)




Hardware accelerated scroll animations




Complex timeline sequences




Three.js

If you're migrating from GSAP, you'll achieve better Lighthouse Performance scores, and you can even use Motion without a business license.

In this guide, we'll walk through how you can add Motion to your project, and give an overview of how to optionally generate custom scripts for even better performance.

Install

First, open the Pages dialog in your project and click "Edit page settings" on the page you want to add Motion to.

Scroll down until you find the "Before <body /> tag" dialog. In here, we can add our Motion code.

Here, you can add a new script block that imports Motion.

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/+esm"


  animate("header", { opacity: 1 })
</script>

You can replace 11.13.5 here with whichever version you want to install. The latest published version can be found on the npm package page.

This script contains all the Motion imports, but you can also achieve even greater filesize savings if you want to use just the mini version of the animate function, which is just 2.5kb, by importing from https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm:

<script type="module">
  import { animate } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm"
</script>
Custom scripts

By importing scripts directly from this URL, you're importing everything, even the bits of Motion you're not using. But, one of the great things about Motion is it's tree-shakable. This means you can use a bundler like Vite or Rollup to only include the bits you use.

In fact, this is a good practise for all of your Webflow custom code. It will ensure you package everything into one neat bundle and only package the bits you need.

For example, if you only wanted to use the animate function, you could replace the above code with this:

import { animate } from "motion"

animate("header", { opacity: 1 })

Building this with Rollup, uploading to a CDN, and then including with an async JS tag will boost SEO scores even further:

<script async src="https://yourdomain.com/my-script.js"></script>
Next

Now that you have Motion running in your Webflow project, you can follow our quick start guide to start making animations!

CSS

Integrate Motion with Vue 3

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/webflow#next

Docs

Examples

Motion+

Documentation

JavaScript

Webflow

Integrate Motion with Webflow

Webflow already comes with some animation capabilities, but it can be that you want to go that little bit further by introducing custom code:

Animate previously unanimatable values (like gradients and masks)




Hardware accelerated scroll animations




Complex timeline sequences




Three.js

If you're migrating from GSAP, you'll achieve better Lighthouse Performance scores, and you can even use Motion without a business license.

In this guide, we'll walk through how you can add Motion to your project, and give an overview of how to optionally generate custom scripts for even better performance.

Install

First, open the Pages dialog in your project and click "Edit page settings" on the page you want to add Motion to.

Scroll down until you find the "Before <body /> tag" dialog. In here, we can add our Motion code.

Here, you can add a new script block that imports Motion.

<script type="module">
  import { animate, scroll } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/+esm"


  animate("header", { opacity: 1 })
</script>

You can replace 11.13.5 here with whichever version you want to install. The latest published version can be found on the npm package page.

This script contains all the Motion imports, but you can also achieve even greater filesize savings if you want to use just the mini version of the animate function, which is just 2.5kb, by importing from https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm:

<script type="module">
  import { animate } from "https://cdn.jsdelivr.net/npm/motion@11.13.5/mini/+esm"
</script>
Custom scripts

By importing scripts directly from this URL, you're importing everything, even the bits of Motion you're not using. But, one of the great things about Motion is it's tree-shakable. This means you can use a bundler like Vite or Rollup to only include the bits you use.

In fact, this is a good practise for all of your Webflow custom code. It will ensure you package everything into one neat bundle and only package the bits you need.

For example, if you only wanted to use the animate function, you could replace the above code with this:

import { animate } from "motion"


animate("header", { opacity: 1 })

Building this with Rollup, uploading to a CDN, and then including with an async JS tag will boost SEO scores even further:

<script async src="https://yourdomain.com/my-script.js"></script>
Next

Now that you have Motion running in your Webflow project, you can follow our quick start guide to start making animations!

CSS

Integrate Motion with Vue 3

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/blog/reacts-experimental-view-transition-api

Docs

Examples

Motion+

Jan 13, 2025

Revealed: React's experimental animations API

Matt Perry

Since its inception over 12(!) years ago, there's been a glaring animation-sized hole in React's API.

Over the year its closest competitors like Vue and Svelte have introduced APIs that, while not extensive, still make animations a little easier. Whereas React developers have had to rely on third-party libraries like Motion for React, React Spring or others.

Until now.

Yes, React is getting its first animations API. The angels sing, the heavens part, and through the break in the long gloom descends author Seb Markbåge, gifting <ViewTransition /> unto the world. (Incidentally I have to thank Seb for fielding my many questions about this new API)

As its name implies, <ViewTransition /> is based on the browser's powerful new View Transition API feature.

Excitingly, it's already available in React's pre-release channels. So in this post we'll explain how to start playing with <ViewTransition /> in React and Next.js, today, and explore its capabilities using live, copy/pastable examples.

There's even an accompanying microsite where you can browse these examples to your heart's content.

But I'm getting ahead of myself. First, what is a view transition? And why is it this feature that has prompted the first animation API from the React team?

View transitions 101

The View Transition API is a new browser feature that allows developers animate between any two views.

It's immensely powerful, allowing the animation of previously unanimatable values like switching justify-content between flex-start and flex-end:

Or animating between two entirely separate elements as if they were one:

Though advanced in many ways, view transitions aren't without their downsides. In short, they're essentially uninterruptible, the pseudo-element CSS API is unpleasant, changes in scroll position are animated, and they mandate that every independently animating element is assigned a unique view-transition-name, the management of which is error-prone busywork that makes composition needlessly difficult.

To start addressing these pain points we recently launched the new view() function alpha, which is available in Motion+ early access.

So you might think, great, if you manage to solve this stuff for vanilla JS users then it should be an easy next step to throw view() into a React wrapper.

Unfortunately, when integrating with React, view() shares the same fundamental limitations as the View Transition API itself:

The need to start a view transition before setting state.




The need to wrap that state update in React's flushSync:

view(() => {
  flushSync(() => setState(yourNewState))
})

This is a one-two punch of poor performance.

You see, a view transition essentially animates pseudo-elements that contain screenshots of elements, rather than the elements themselves. This process has benefits and drawbacks, which are a broader conversation, but the bottom line is that this, in turn, visually freezes all or part of a page, leaving it static and non-interactive until after the animation has finished.

Therefore, the best time to start a view transition is just before you change the DOM. Not before you've even set the state update that will lead to the render that will lead to the commit. 

Worse still, in React flushSync is the least performant way to perform this state update, because it blocks the main thread until the new state has rendered. Freezing all main thread animations and interactions, and preventing bail-outs or cancellations.

This is why <ViewTransition /> is so important. It has its hooks (no relation) deep into the React render cycle. Because of that, it can trigger view transitions as late as possible, leaving the page visually unfrozen in the meantime.

Additionally, it only works with asynchronous updates, like startTransition and <Suspense />, which means that state updates can be interrupted or aborted before the animation begins. UIs will be more responsive.

Wow, sounds perfect, right? Well, beyond the intrinsic limitations of the View Transition API itself, pretty much. So now we know why it's so good, let's dive in.

Get started

First: Be warned! <ViewTransition /> is an experimental API. It can (and probably will) change at any time, without warning. The point of these early releases is to find bugs and holes in the API. So although fun to play with, I wouldn't write production code on this today.

That being said, the quickest way to get started is to fork this CodeSandbox, which is already set up with React on the experimental channel.

You can also install react and react-dom in your own project like this:

npm install react@experimental react-dom

Next.js users must install a canary version of at least 15.2.0-canary.6. Then, in your next.config file, add:

const nextConfig = {
    experimental: {
        viewTransition: true,
    },
}

Finally, as an unstable API, ViewTransition is exported as unstable_ViewTransition. So you can import it like this:

import { unstable_ViewTransition as ViewTransition } from "react"
Basic usage

When <ViewTransition /> wraps a component, its first DOM child will be automatically assigned a view-transition-name.

For instance, this toggle is made by wrapping the .handle element with ViewTransition:

<button style={{ justifyContent: isOn ? "flex-end" : "flex-start" }}>
  <ViewTransition>
    <div className="handle" />
  </ViewTransition>
</button>

Importantly, the isOn state update must be wrapped with startTransition, otherwise the animation won't work.

const toggleOn = startTransition(() => setIsOn(!isOn))

The great thing about this, is that this view-transition-name isn't just automatically generated, but it's also automatically applied.

What does this mean? With the View Transition API, you can't just set view-transition-name on an element and forget about it. Without further dirty work managing what's known as view transition "types", all the elements with a view-transition-name will be scooped up and included in every single view transition.

Which means with a naive approach, clicking any one of these switches would result in six animations, even when only one of them will actually be noticable:

But by looking in the inspector, we can see that we only have one animation generated for these switches.

This is because the view-transition-name style gets applied just before, and removed just after, the animation. This is great both for performance and for isolating microinteractions. Between the name generation and application we've already solved two of the big pain points of View Transition API.

<ViewTransition /> is quite robust at detecting visual changes. Here, we're simply changing the URL of an img, and the component is ensuring that the images correctly crossfade from one to the next.

Switching children

A powerful facet of this view-transition-name application is that it doesn't just work when the element stays the same. We can crossfade between two completely different elements simply by switching them out.

<ViewTransition>
  {state ? <MenuA /> : <MenuB />}
</ViewTransition>

This even works with the Suspense component, so we can animate from its fallback to its content (when ready).

<ViewTransition>
  <Suspense fallback={<Skeleton />}>
    <Content />
  </Suspense>
</ViewTransition>

Unfortunately I couldn't get a mock version of this setup working, but will update this post if and when I succeed.

Shared element animations

In the previous example, did you also notice the underline animation? This is performed by conditionally rendering <ViewTransition /> in either button, depending on state. We link the two by manually providing a matching name prop:

{isSelected && (
  <ViewTransition name="underline">
    <Underline />
  </ViewTransition>
)}

When <ViewTransition /> is removed in one location and created elsewhere, the two elements become shared.

This capability also has a super-clever feature that I am absolutely copying for Motion's view() function. When two elements are linked like this, if one of them lies outside the viewport, then a simple fade animation will be used. This prevents elements flying all over the screen when there's no benefit to the user.

To demonstrate, try pressing "Toggle box position" and noticing the layout animation, then press "Toggle container size" to move the bottom box off screen before toggling box position again:

Customising animations

So far, we've made a bunch of animations, but we haven't actually customised any of them with easing, duration or delays.

It is possible to use CSS, by setting name manually and using the View Transition API's normal cumbersome pseudo-selectors:

<>
  <ViewTransition name="photo" />
  <style>{`
    ::view-transition-group(photo),
    ::view-transition-new(photo),
    ::view-transition-old(photo) {
      animation-duration: 1s;
    }
  `}</style>
</>

But perhaps more useful is the ability to use the component's handy event handlers. There are five:

onEnter/onLeave: This component is entering or leaving the DOM and there are no others that share its name.




onLayout: This component's boundaries have changed due to external components.




onUpdate: This component's contents or boundaries have changed due to itself or child components.




onShare: This component is performing a shared element transition.

Each event callback is provided with a ViewTransitionInstance, which contains a reference to each pseudo-element used in the animation. This reference contains a pre-bound Web Animations API function, which we can use to create entirely custom animations.

So to take our image swap example, we can now use direction to dynamically animate the images to the left or right:

 function onUpdate(instance: ViewTransitionInstance) {
      const offset = 100 * direction

      instance.old.animate(
          {
              clipPath: ["none", `translateX(${-offset}px)`],
          },
          { duration: 300, fill: "both", easing: "ease-in" }
      )

      instance.new.animate(
          {
              transform: [`translateX(${offset}px)`, "none"],
          },
          { duration: 400, delay: 200, fill: "both", easing: "ease-out" }
      )
  }

We're not limited to the typical opacity/transform animations either. Here, we're using a clipPath animation to animate a mask:

Where does this leave Motion?

So, that's  <ViewTransition /> in a nutshell. It's definitely going to unlock a number of new capabilities for React animations, and make the View Transition API much easier to use than in its raw form.

However, it only addresses some of the drawbacks View Transition API, and view transitions themselves aren't a shotgun solution to all of web animations. They're "just" an amazing new tool that we can put on our shelf, alongside our other amazing tools like CSS transitions, scroll animations, and the rest.

However, Motion for React does contain one API that lives in a very venn-diagram-overlappingly close space to view transitions, and that's layout animations.

Layout animations do a similar job of animating the impossible, but using transforms and scale-distortion correcting calculations. For micro-interactions they remain preferable, partly because they account for scroll offsets, partly because they handle relatively/nested animations, but mostly because they're interruptible:

<motion.div layout />

The obvious downside is that they come at the cost of the ~33kb motion component. So here's an alternative that performs many of the same features for an undoubtedly smaller bundlesize, which is Good News.

What's more exciting to me is thinking about a <ViewTransition /> component in Motion that can go further with making view transitions accessible to all developers.  Perhaps a declarative API that allows for JS easing functions and springs, and contains sensible defaults, similar to the rest of Motion:

<AnimateView share={{ type: "spring", bounce: 0.3 }}>

With a couple more events, notably a onRead that could run just before the view transition starts, we could also bring some of the planned enhancements for view() to <ViewTransition />, notably the ability to cancel out changes in scroll position.

Though, this will probably have to wait until <ViewTransition /> hits stable. 

Until then, let me know what you think of React's new animation API, and let me know what you make with it!

Read more
How to add cmd-k search shortcut to your Framer site

By default, the Framer Search component doesn't support the cmd-k keyboard shortcut. Here's how to add it to your Framer site.

Framer Motion is now independent, introducing Motion

Framer Motion is now independent. Introducing Motion, a new animation library for React and all JavaScript environments. Here's what it means for you.

Do you still need Framer Motion?

In the five years since Framer Motion was released, CSS animation APIs have come a long way. Do you still need to use Framer Motion?

When browsers throttle requestAnimationFrame

In specific situations Safari and Firefox may throttle requestAnimationFrame. Here’s why your JavaScript animations are janky.

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/blog/how-to-add-cmd-k-search-shortcut-to-your-framer-site

Docs

Examples

Motion+

Nov 20, 2024

How to add cmd-k search shortcut to your Framer site

Matt Perry

On the old Framer Motion docs, the top request from visitors was search functionality. When making the new Motion homepage I knew that search was a must-have. The new site is built with Framer, so adding search is as simple as a drag and drop.

No more excuses.

So I dragged and dropped, and patted myself on the back thinking that would be the end of it.

But no. Now, I'm getting Github issues, Twitter DMs, emails, all asking for a cmd-k keyboard shortcut.

This is a keyboard shortcut I've never used or noticed, I had no idea this was a thing! Apparently it's very popular.

But now, if you hit cmd-k or ctrl-k now, you'll notice our search will open. Framer's search functionality doesn't support this out the box, so there's a little hackery involved.

First, you want to wrap your Search component with a layer named something unique, like "Search Container".

Framer will output this label via the data-framer-name attribute.

Next, we want to go to our Custom Code section in the site settings.

In the "End of <body> tag" section, add the following script. It will add an event listener to the page that listens for the cmd-k shortcut, and simulates a click on the search button.

<script>
document.addEventListener('keydown', (event) => {
  if (event.metaKey && event.key === 'k') {
    event.preventDefault()
    const searchButton = document.querySelector('[data-framer-name="Search Container"] button')
    if (searchButton) searchButton.click()
  }
})
</script>

Naughty? Probably. But hey, enjoy the shortcut 😅

Read more
Revealed: React's experimental animations API

React is experimenting with a new animation API based on the View Transition API. How does it work? What can it do? We reveal all in this blog post.

Framer Motion is now independent, introducing Motion

Framer Motion is now independent. Introducing Motion, a new animation library for React and all JavaScript environments. Here's what it means for you.

Do you still need Framer Motion?

In the five years since Framer Motion was released, CSS animation APIs have come a long way. Do you still need to use Framer Motion?

When browsers throttle requestAnimationFrame

In specific situations Safari and Firefox may throttle requestAnimationFrame. Here’s why your JavaScript animations are janky.

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/blog/framer-motion-is-now-independent-introducing-motion

Docs

Examples

Motion+

Nov 12, 2024

Framer Motion is now independent, introducing Motion

Matt Perry

First, some personal news: Next week will be my last at Framer.

Writing that feels pretty wild. Making Framer Motion has been the best job of my life. To do so for six years within the best product team in the world, both a massive learning experience and a privilege.

However, that leads to some news that I'm incredibly excited to share.

With Framer's blessing and support, Framer Motion is now completely independent. I'm spinning it off into its own project, to better serve the whole community.

Introducing Motion.

What's changing?

There are two big changes to highlight. The first is Motion's brand new home, here at motion.dev. Besides a fresh new design, it finally has a much-requested search!

The second change is also a big request from the community. For a long time, users have asked to use Framer Motion outside of React. Either with vanilla JS, or other frameworks like Vue.

Today, Motion becomes more than a React library, with an amazing set of vanilla APIs that bring Motion's hybrid engine and extensive feature set to everyone.

In the coming weeks and months, more features from Framer Motion will make their way to this new vanilla API, and I'll be writing new integration guides that will help you use them everywhere.

Beyond that, expect improved support and documentation, a stronger community, and a renewed focus on developer-facing features.

Why's this happening?

This news might be surprising to many, but I think in context it's the natural and obvious next step for Motion.

Six years ago, Framer bought my project Popmotion because they wanted a simple React API, unlimited flexibility, and smooth animations across all devices.

As Framer moved from prototyping into sites, these animations only became more important because now they're being shared with millions of monthly visitors.

But Motion also became wildly successful in its own right, becoming the go-to React animation solution with over 4.5 million weekly downloads on npm.

It's a part of Framer, but it's also apart from Framer, serving a much wider set of users.

We feel like the best way to ensure Motion's future as a core driver of animations on not just Framer sites, or just React sites, but all sites, is to spin it out as an independent open source project for the community.

For Motion, the high demands of Framer (in terms of capability and performance) have made Motion the product that it is today. So Framer users can rest assured that their animations will continue to be powered by Motion in the future.

Spinning out Motion is a bold move by Framer, and I'm super delighted that they're on board as Motion's first sponsor!

So, what's next?

Honestly, I have a long list of things I want to do next. The hard part will be picking what's first.

New APIs built on emerging browser features like View Transitions. Bringing the power of Motion's industry-leading layout animations to the new vanilla API. High-level components that are both beautiful and accessible. Better dev tools. Plugins for popular design tools.

Realistically, for Motion to thrive, I first need to make it sustainable. If you or your company already finds value from it, consider a sponsorship. All sponsors receive access to our private Motion Discord and an exclusive wallpaper pack, and higher tiers can get their logo and link on the homepage (110k+ monthly visitors).

In fact, I can already thank Tailwind for becoming Motion's second sponsor. These sponsorships will allow me to spend more time on the core library, and less on finding other avenues of monetisation.

That said, I already have ideas there too, a mix of fun and useful. 

But whatever's next, I'm beyond excited for this next chapter, and if you're an existing Motion One or Framer Motion user, I hope you are too!

Here's to the next six years.

Support Motion

Motion is free and open source. Our amazing sponsors keep the project sustainable!

Every sponsor receives access to our private Discord, and an exclusive mobile and desktop wallpaper pack.

Become a sponsor

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/blog/do-you-still-need-framer-motion

Docs

Examples

Motion+

May 29, 2024

Do you still need Framer Motion?

Matt Perry

Update 12/11/24: Framer Motion is now Motion for React. Some of the references on this page will be outdated. Read the announcement.

Time flies: I released the first version of Framer Motion over five years ago. My goal was (and still is) to make an API that is simpler than animating with CSS, but with all advanced capabilities of a JS library.

Animation in CSS has always been limited, often in surprising ways. For example, with CSS it's always been impossible to animate elements when they enter the DOM. With Framer Motion, it's as simple as:

<motion.li
  initial={{ opacity: 0 }}
  animate={{ opacity: 1 }}
/>

Likewise, it's always been impossible to animate transforms independently, use spring physics, add scroll-linked animations, or make complex layout animations.

But five years is a long time, and CSS continues to improve. Many things that used to be hard or impossible are now surprisingly easy. So for five years of Framer Motion, here are five new CSS features that mean you might not need it anymore.

1. Enter animations

We've just seen how easy it is to make an enter animation in Framer Motion. So easy, mundane even, that over the years I've forgotten that this is technically a feature.

When Framer Motion was first created, animating elements from an initial visual state using just CSS was impossible. You needed a sprinkle of JavaScript and even a little hackery.

First, the element is styled with CSS.

#my-element {
  opacity: 0;
  transition: opacity 0.5s;
}

Then, after adding the element to the DOM, change the value we want to animate (in this case opacity) using a little JavaScript:

const element = document.getElementById("my-element")

element.style.opacity = 1

You'd think, given the transition defined in the CSS, this would be enough to trigger an animation. It doesn't.

Because 1 is set before the element's styles are calculated, 1 is now considered the "initial" value, not 0. 

To fix this, you can first force a style recalculation.

element.getBoundingClientRect()
element.style.opacity = 1

This kind of read/write distributed across an app, if not tightly managed, can lead to style and layout thrashing, which is very bad for performance.

Alternatively, you can wait a couple animation frames to ensure the element has painted.

requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    element.style.opacity = 1
  })
})

Either approach is what I'd charitably call "pretty mucky stuff". The understatement of Framer Motion's animate prop feels like a much bigger feature when looking at the alternative. 

However, CSS has a new trick up its sleeve, @starting-style.

With @starting-style, we can define styles that an element will animate in from once rendered.

#my-element {
  opacity: 1;
  transition: opacity 0.5s;

  @starting-style {
    opacity: 0;
  }
}

@starting-style is available in all modern browsers. Older browsers will simply not show the animation, so it's something we can safely use today.

Though, one interesting wrinkle with this API is that starting styles need to be defined after the normal styles, as they inexplicably share the same specificity. So although writing it like this might be your inclination:

#my-element {
  @starting-style {
    opacity: 0;
  }

  opacity: 1;
  transition: opacity 0.5s;
}

It won't animate, as expected.

2. Independent transforms

In Framer Motion (and all JS animation libraries), transforms like x, scaleX and rotate can all be animated independently of each other.

<motion.div
  initial={{ y: 10 }}
  whileInView={{ y: 0 }}
  whileHover={{ scale: 1.2 }}
  whileTap={{ scale: 0.9, rotateX: 5 }}
/>

This used to be impossible in CSS, because transform is a single value and therefore has to be animated in its entirety. All values, together, with the same transition settings.

Whereas JS libraries can construct and render a new transform string every frame and thus its constituent values can start and stop animating independently, all with different transition settings.

After many years of failed starts and dead-end proposals, CSS recently gained new shorthand properties translate, scale and rotate. Unlike transform, these can be set and animated independently of each other:

button {
  translate: 0px 0px;
  transition:
    translate 0.2s ease-out,
    scale 0.5s ease-in-out;
}

@starting-style {
  button {
    translate: 0px 10px;
  }
}

button:hover {
  scale: 1.2;
}

The benefit to using these values over building transform strings in JS libraries is that these animations can be hardware accelerated.

The downside is that they're still a halfway house towards true independent transforms. None of the individual axes can be controlled independently. So if we want a velocity-based x/y animation, or animate scaleX separately from scaleY, we need to rely on another new CSS feature, @property.

@property allows us to give browsers some type information on CSS variables. This unlocks the ability to animate them with CSS/WAAPI.

For instance, if we want to animate rotateX and rotateY with different easing curves, we could first define variables with @property:

@property --rotate-x {
  syntax: "<angle>";
  inherits: false;
  initial-value: 0deg;
}

@property --rotate-y {
  syntax: "<angle>";
  inherits: false;
  initial-value: 0deg;
}

Then use these variables in a transform/rotate string.

button {
  transform: rotateX(var(--rotate-x)) rotateY(var(--rotate-y));
  // rotate: var(--rotate-x) var(--rotate-y);
  transition:
    --rotate-x 0.2s ease-out,
    --rotate-y 0.3s linear;
}

button:hover {
  --rotate-x: 10deg;
  --rotate-y: 20deg;
}

However, the big caveat with animating CSS variables is that they're slow, because they always trigger paint. Even though we're only using these two values in a transform, because of this paint it's still way slower to animate with CSS variables than building transform strings once a frame via a JS library.

3. Springs

In all the Framer Motion examples given so far, you may have noticed a lack of transition settings. This is because Motion attempts to provide some sensible, dynamic defaults, and for transforms, these are springs.

<motion.div
  initial={{ x: -100 }}
  animate={{ x: 0 }}
  transition={{ type: "spring", stiffness: 300, damping: 10 }}
/>

Springs are a bedrock of the library. Velocity from a gesture or interrupted animation is fed into the next animation, so UIs feel more tactile, responsive, even playful.

Springs have long been impossible with CSS, but recently it gained the linear() easing function.

linear() is such a slam dunk idea that it was probably the shortest period time I've seen an API proposed and then shipped in notorious laggard Safari.

Not to be confused with linear (no function brackets), the linear() easing function accepts a series of points and interpolates between them linearly (hence the name). Provide enough points and they can "draw" the easing curve of a spring, or a bounce, or any other custom easing curve.

A spring defined via linear() might look like this:

transition: transform 2s linear(
  0, 0.009, 0.035 2.1%, 0.141, 0.281 6.7%, 0.723 12.9%, 0.938 16.7%, 1.017,
  1.077, 1.121, 1.149 24.3%, 1.159, 1.163, 1.161, 1.154 29.9%, 1.129 32.8%,
  1.051 39.6%, 1.017 43.1%, 0.991, 0.977 51%, 0.974 53.8%, 0.975 57.1%,
  0.997 69.8%, 1.003 76.9%, 1.004 83.8%, 1
);

Obviously, it isn't intended that you write out a linear() definition yourself. I actually lifted this one straight from an online linear() generator.

The developer experience here is pretty poor, having to copy/paste these definitions from an outside tool rather than just passing options to a spring() function. The feeling of springs can be difficult to nail, so going back and forth between one of these tools is tedious.

The other downside is that they're predefined easing curves, not a real physics simulation running on each style's actual value and velocity. So they're not going to provide that same feeling when picking up the velocity from a user gesture or interrupted animation.

However, they can look pretty convincing for certain animations, so it can be a good-enough, lightweight option in many cases. 

4. Scroll-linked animations

There are two types of scroll animations: Scroll-triggered and scroll-linked.

Scroll-triggered animations are normal time-based animations that get triggered when an element appears in view. These are trivial in Framer Motion thanks to the whileInView prop.

<motion.div initial={{ opacity: 0 }} whileInView={{ opacity: 1 }} />

Although possible to hack together, there's still not a good solution for scroll-triggered animations in CSS today.

Conversely, rather than being driven by time, scroll-linked animations link values directly to scroll progress. In Framer Motion these are created by composing MotionValues:

const { scrollYProgress } = useScroll()

// Map scroll progress to x
const x = useTransform(scrollYProgress, [0, 1], [0, 500])

return <motion.div style={{ x }} />

CSS does have a new feature for scroll-linked animations. Two, actually: The new scroll() and view() animation timelines.

Either can be assigned to the animation-timeline style to drive animations via scroll progress instead of time:

div {
  animation-name: fadeAnimation;
  animation-timeline: scroll();
}

@keyframes fadeAnimation {
  from {
    transform: translateX(0px);
  }
  to {
    transform: translateX(500px);
  }
}

The difference between the two is that scroll() is used to track the scroll progress of the viewport or scrollable element, while view() is used to detect the progress of an element as it moves through a viewport/element.

The great thing about these new timelines is when a style animation can be hardware accelerated, like transform or opacity, these scroll animations will also run completely off the main thread, ensuring scroll animations stay smooth even as your site is performing heavy lifting.

Framer Motion does have some preliminary support for accelerated scroll animations via the new ScrollTimeline JS API, while maintaining compatibility with older browsers. But more work needs to be done to support ViewTimeline.

One downside to the CSS timeline is that when we want to do anything fancier, like base an animation on scroll velocity, or dampen motion, we have to resort to CSS variable trickery.

Not only are these effects arguably more straightforward to compose using Framer Motion's useVelocity and useSpring, because they rely on CSS variables they run on the main thread and trigger paint, so they're actually less performant than using JavaScript.

5. Layout animations

Framer Motion has a powerful layout animation API that can take any two layouts and animate between them using transform.

It's great for animating values that are usually unanimatable, like justify-content:

It seems overkill for this simple example, but the nice thing to notice is it illustrates that you get to create your layouts using your preferred CSS, like grid, flexbox etc, across different breakpoints, and Motion will figure out the required transform animations in real time.

The API is super simple too. Just tag animating elements with the layout prop.

<motion.div layout />

Framer Motion's layout animations go way beyond the classic FLIP technique, as they perform scale correction on infinitely deep trees, including distortion on border-radius and box-shadow, ensuring any layout can animate rather than just the top-level element.

It can also perform shared layout animations across completely different trees by providing two elements the same layoutId prop.

<motion.div layoutId="modal" />

Without Framer Motion, an animation like this one would have been prohibitively complex to write and maintain.

But now, there's the View Transition API, a browser-native API that can animate between two different views and has been positioned by some as a replacement for Motion's layout animations.

The differences are extensive and could be a post of their own, so I'll attempt to be brief.

It works by wrapping DOM updates with document.startViewTransition():

document.startViewTransition(updateDOM)

By default this will crossfade the whole viewport to its new visual state.

Note: The following demos will only animate in browsers supporting the View Transitions API.

The way this practically works is a new pseudo DOM is created on top of the page. This is made up of a screenshot of the previous view, and a live screenshot of the new view. These are then crossfaded.

For this switch example, this default effect is pretty poor, but for full page transitions it's quite good. This very site uses a similar effect when navigating between pages.

For this switch, we can improve it by adding a unique view-transition-name style to the toggle element.

<div style={{ viewTransitionName: "toggle" }} />

Now, the page will still crossfade, but the toggle element will be screenshotted and crossfaded in its own layer in the pseudo DOM. It's size and position will also be animated.

For this simple example the code looks slightly more complex than Framer Motion's API, and IMO it is a pain to have to provide each element a unique ID. It's needless complexity, and becomes a pain to manage across a tree of components. view-transition: persist or similar would be better for these same-element animations. 

On the other hand it doesn't get any more complex to create shared element transitions. The element with the view-transition-name can be different before and after the transition.

In terms of the API, it's not great that we have to remove the view-transition-name style on the list items when a modal is opened.

viewTransitionName: isOpen ? undefined : "container"

Framer Motion maintains layoutId stacks so you can add multiple elements with the same ID and it'll know which elements to animate to and back from.

You can also see the images don't animate between their positions as well as in the Framer Motion example. This is because that effect was made of two layers, the outer container clipping the inner image-container. Because each named element gets screenshotted and animated in a new pseudo element, that sits in parallel to other layers (rather than maintaining their DOM hierarchy) you can encounter visual artefacts where elements were previously clipped:

In Framer Motion the elements themselves are animated so you don't run into these kinds of situations.

That said, the pseudo DOM is a completely unique and new setup, one that opens possibilities that don't exist with the way layout animations work on the DOM itself.

For instance, we can lift a layer off the page while we crosswipe beneath it with an animated gradient mask:

Other fundamental differences exist with drawbacks and opportunities.

Scroll delta

View transitions are literally that: Transitions between two views. This means that if the scroll position changes during the DOM update, then every element with a view-transition-name is going to animate across the viewport by that scroll distance.

Whereas layout animations are, unsurprisingly, literally that: Transitions between two layouts. Scroll is accounted for, so elements that have only changed position in the viewport because they scrolled aren't going to animate. Or, if they do animate because they've also changed layout, they will animate out of their new scroll position, not where they used to be drawn on screen.

Transform animations

Transforms aren't layout, so in Framer Motion they can animate separately. Notice when toggling the layout here the rotation animation continues uninterrupted:

Mixed transitions

When animating multiple layers with different transition settings, there's no concept in view transitions of relative layout. A parent layer could animate away from a child with a delay or slower transition (and vice versa):

Whereas Framer Motion is aware of the relationship between these two elements and will ensure parents and children can't animate away from each other:

Interruptible animations

Try clicking rapidly on the Framer Motion switch example, and then the view transitions switch example. Motion's layout animations are interruptible, whereas view transitions aren't. By default the pseudo DOM blocks pointer events, but if you do interrupt a view transition manually, the next animation will start from where the real DOM element actually is in the viewport, not where it looks like it is in the view transition.

Interruptibility is a table stakes animation feature, so more than anything else, this makes them completely unsuitable for these kinds of micro-interactions.

All said

Some of these differences are being addressed and while some are inherent to the concept of view transitions.

All said, a choice between view transitions and layout animations is a false dichotomy. In Framer we use them both, each for their respective strengths.

View transitions are great at animating the entire view from one state to the other, so we use those for animations between different pages. You can create unique effects that simply aren't possible with layout animations.

Whereas layout animations are interruptible, aren't affected by scroll, can mix transition settings, and work much better with isolated parts of the page. So we use these for animating component variants.

So depending on what you want to animate, view transitions may or may not be a valid alternative.

Bonus: Auto-height

Okay so I promised five reasons, but this one is really exciting. I'll keep it short.

Framer Motion has long been able to animate between fixed heights and auto.

<motion.div animate={{ height: isOpen ? "auto" : 0 }} />

CSS doesn't support animating to/from auto, but with CSS5's brand new calc-size proposal, the same effect will finally be doable.

li {
  height: 0px;
  transition: height 0.3s ease-out;
  
  .open {
    height: calc-size(auto);
  }
}

No catch, just a great new feature.

So, do you still need Framer Motion?

This is an amazing set of new features that have landed, or will soon land, in CSS. If you're only using Framer Motion for very specific reasons, like enter animations or height: auto, then there's a compelling argument for starting with CSS and bringing in Framer Motion only when you hit its limitations.

For me, bias acknowledged, I simply prefer the Framer Motion API. With the peculiarities of CSS APIs, like @starting-style specificity, or the Assembly-level aesthetics of linear(), most of these new features are still simpler to achieve in Motion. Simplicity is fun to write, and more maintainable.

Further, there's a fidelity with Framer Motion (and JS animation libraries in general) that I don't feel CSS achieves yet. Be it true velocity-based springs, or interruptible layout animations, or even humble hover gestures that aren't weirdly polyfilled to touch devices because of the state of the web back in 2007, animations and gestures built in Framer Motion should feel better.

There's also an ocean of features that CSS still doesn't have, like complex timeline sequencing, exit animations, stagger, scroll-triggered animations, velocity-based springs, and many more besides.

So, do you still need Framer Motion? Thanks to these five new CSS features, the calculus has changed, but my answer is the same as it was five years ago: Go hang out with your loved ones or something.

Read more
Revealed: React's experimental animations API

React is experimenting with a new animation API based on the View Transition API. How does it work? What can it do? We reveal all in this blog post.

How to add cmd-k search shortcut to your Framer site

By default, the Framer Search component doesn't support the cmd-k keyboard shortcut. Here's how to add it to your Framer site.

Framer Motion is now independent, introducing Motion

Framer Motion is now independent. Introducing Motion, a new animation library for React and all JavaScript environments. Here's what it means for you.

When browsers throttle requestAnimationFrame

In specific situations Safari and Firefox may throttle requestAnimationFrame. Here’s why your JavaScript animations are janky.

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/blog/when-browsers-throttle-requestanimationframe

Docs

Examples

Motion+

Oct 1, 2020

When browsers throttle requestAnimationFrame

Matt Perry

requestAnimationFrame (rAF) is a browser API that allows the execution of code before the next available frame on the device display.

requestAnimationFrame(timestamp => {
  // Do stuff
})

Most JavaScript animation libraries use this API to change the visual properties of DOM elements, 3D models, or canvas contexts to create motion on the web.

However, it isn't a guarantee that this method will run before every frame. A browser might choose to run requestAnimationFrame at lower intervals, and this leads to jerky animations.

Look at these two boxes:

If your browser doesn't fall into one of the situations we'll explore in this post, the top box will be animating smoothly at 60fps. The second box is artificially running at half the framerate of the top box. You can see how obvious the effect of halving the framerate is for the smoothness of animations.

Because the situations in which a browser might choose to throttle requestAnimationFrame aren't always obvious or consistent, debugging these animations can be a mind-bending experience.

If you're on this page, you might well have arrived via Google, trying to understand why your JavaScript animation is janky. I imagine you sat there, as I once was, with two identical iPhones side by side, running the same JavaScript animation, one at the expected 60fps and one at a jerky 30fps.

You're not going crazy. Your browser is. Let's take a look at when and why browsers throttle requestAnimationFrame. 

iOS throttles rAF in low-power mode

Discovering this was a real test of sanity. Debugging animations on an old website, I noticed all the animations were janky on my phone.

Suspecting garbage collection or other source of low-performing animations, I tried to debug on my MacBook. Nothing unusual about memory consumption. I set CPU throttling to maximum. Still 60fps.

I put my phone next to my partner's, same OS, same make and model. 60fps on hers, unmistakably 30 on mine.

I started to suspect the paint job. But then I spotted this on my screen:

Toggling low-power mode on and off had an immediate effect on the smoothness of the animations. I found a Webkit issue that confirmed iOS throttles requestAnimationFrame in low-power mode, along with all CSS animations.

It's a clever battery-saving trick, and one of an infinite array of examples why developing against mobile browsers is such a dreadful, soul-crushing experience.

iOS app developers are given the ability and responsibility to respond to low-power mode. Yet Webkit's characteristic obstinence is the reason why Battery Status API is now deprecated.

Safari throttles rAF in cross-origin iframes

The example at the top of the frame is running in a cross-origin iframe. "Cross origin" essentially means that iframe is serving content from a different domain from that of this site.

If you're using Safari, you may have noticed that not even the first box was running very smoothly. Go back and click or tap inside the iframe. The animation should start running as expected.

The Webkit ticket doesn't provide a reason for this behaviour. To speculate, iframes are commonly used for advertising. Adverts are liberal with your CPU cycles, often using quite overt attention-stealing animations.

So the throttling is an attempt to prevent adverts from draining your battery. The framerate is uncapped on click/tap (but not mouse/touchstart 🙄) because that's considered a sign of intent that the content is acceptable by the user.

In an age of ad-blockers this solution feels like the wrong approach. Preferably, iOS would take a more aggressive stance against adverts by default, then revert this change.

Make the web less shit, not more shit.

Firefox obliterates JavaScript time accuracy for privacy features

I was first made aware of this via a ticket about laggy animations in Firefox. Firefox users across browsers and devices were all reporting the same issue, but I couldn't replicate it myself on any operating system.

It turns out that Firefox has an anti-tracking privacy setting called resistFingerprinting that, if enabled, reduces JavaScript time accuracy to 100ms.

This Bugzilla ticket details the ramifications of Mozilla lowering the accuracy of performance.now() to just 2ms(!). That's considered low enough to cause havoc in game calculations, so 100ms is certainly low enough to wreck animations.

The previous cases of throttling we've seen only halved framerate. 100ms is enough to swallow six whole frames of animation! Callbacks provided to requestAnimationFrame receive the timestamp of the latest frame, and in animation libraries this is used to calculate the correct visual output. If the timestamp isn't accurate, the animations will be a visual manifestation of that.

Luckily there is a potential fix. The MDN (RIP) page for performance.now() says that serving content with the following headers will allow your page to access high resolution timers:

Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp

High resolution timers === smooth animation.

Conclusion

requestAnimationFrame is just that - a request. It's to the browser's discretion whether that request is granted, and as we've seen, there are a variety of situations where it might not.

It's a trade off. By degrading the quality of the experience for users, browsers can improve their battery life, or hide them from advertising companies.

The quality of the web experience is currently at an all-time low, so in my opinion it's a shame to see anything making it even worse.

For the sanity of the developers having to work with these browsers, the very least I could ask is that, when enforced, these throttling techniques were flagged in the Performance tab. It would give us sharable and repeatable reproduction steps for ourselves and users to follow when they encounter this bizarre behaviour, as the next optimisation is always around the corner...

Read more
Revealed: React's experimental animations API

React is experimenting with a new animation API based on the View Transition API. How does it work? What can it do? We reveal all in this blog post.

How to add cmd-k search shortcut to your Framer site

By default, the Framer Search component doesn't support the cmd-k keyboard shortcut. Here's how to add it to your Framer site.

Framer Motion is now independent, introducing Motion

Framer Motion is now independent. Introducing Motion, a new animation library for React and all JavaScript environments. Here's what it means for you.

Do you still need Framer Motion?

In the five years since Framer Motion was released, CSS animation APIs have come a long way. Do you still need to use Framer Motion?

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/privacy-policy

Docs

Examples

Motion+

Privacy Policy

Last updated 12/11/24

This privacy policy ("Policy") describes how Motion One ("Motion One", "we", "us" or "our") collects, protects and uses the personally identifiable information ("Personal Information") you ("User", "you" or "your") may provide through the Motion website (motion.dev) or in the course of purchasing any Motion products (collectively, "Website"). The Policy also describes the choices available to you regarding our use of your Personal Information and how you can access and update this information. This Policy does not apply to the practices of companies that we do not own or control, or to individuals that we do not employ or manage.

Collection of personal information

We only store information you knowingly provide to us when you make a purchase through the Website. This is limited to your email address, which is required for us to link your identity with purchased products or subscriptions.

Collection of non-personal information

When you visit the Website our servers automatically record information that your browser sends. This data may include information such as your device's IP address, browser type and version, operating system type and version, language preferences or the webpage you were visiting before you came to our Website, pages of our Website that you visit, the time spent on those pages, information you search for on our Website, access times and dates, and other statistics.

Purchases

All purchases made through the Website are processed by a third party payment processor, Paddle (paddle.com). Paddle may ask you for personal and/or non-personal information, such as your name, address, email address, credit card information, or other Personal Information. Paddle has a privacy policy (paddle.com/legal-buyers/) that describes their collection and use of personal information. Motion does not control Paddle or its collection or use of information. Any questions or concerns about Paddle’s practices should be directed to Paddle.

Paddle provides us with certain non-personal information relating to purchases made by visitors to the Website. The non-personal information may include details of the purchase such as the date, amount paid, and product purchased. The non-personal purchase information may be linked to the Personal Information you provide to us (typically limited to your email address, as stated above). Paddle does not supply us with any of your other Personal Information such as your name, street address, or credit card information.

Newsletter

By signing up for our newsletter, either directly through a signup form or by opting-in during the purchase of product or subscription, this is processed by a third party processor, Loops (loops.so). Loops has a privacy policy (loops.so/privacy) that describes their collection and use of personal information. Motion does not control Loops or its collection or use of information. Any questions or concerns about Loops's practices should be directed to Loops.

You may choose to stop receiving our newsletter or marketing emails by following the unsubscribe instructions included in these emails or by contacting us. However, you will continue to receive essential transactional emails.

Managing personal information

You can contact us to request that we delete your email address, but this will prevent you from accessing the products you have purchased from Motion.

When you update information, we may maintain a copy of the unrevised information in our records. Some information may remain in our private records after deletion of such information from your account for a retention period. Once the retention period expires, Personal Information shall be deleted. Therefore, the right to access, the right to erasure, your rights to access, add to, and update your information cannot be enforced after the expiration of the retention period.

We will retain and use your information as necessary to comply with our legal obligations, resolve disputes, and enforce our agreements. We may use any aggregated data derived from or incorporating your Personal Information after you update or delete it, but not in a manner that would identify you personally.

Use and processing of collected information

Any of the information we collect from you may be used to personalize your experience; improve our Website; improve customer service; process transactions; send notification emails such as password reminders, updates, etc; and operate our Website. Non-Personal Information collected is used only to identify potential cases of abuse and establish statistical information regarding Website usage. This statistical information is not otherwise aggregated in such a way that would identify any particular user of the system.

We may process Personal Information related to you if one of the following applies: (i) You have given their consent for one or more specific purposes. Note that under some legislations we may be allowed to process information until you object to such processing (by opting out), without having to rely on consent or any other of the following legal bases below. This, however, does not apply, whenever the processing of Personal Information is subject to European data protection law; (ii) Provision of information is necessary for the performance of an agreement with you and/or for any pre-contractual obligations thereof; (ii) Processing is necessary for compliance with a legal obligation to which you are subject; (iv) Processing is related to a task that is carried out in the public interest or in the exercise of official authority vested in us; (v) Processing is necessary for the purposes of the legitimate interests pursued by us or by a third party. In any case, we will be happy to clarify the specific legal basis that applies to the processing, and in particular whether the provision of Personal Data is a statutory or contractual requirement, or a requirement necessary to enter into a contract.

Information transfer and storage

Depending on your location, data transfers may involve transferring and storing your information in a country other than your own. You are entitled to learn about the legal basis of information transfers to a country outside the European Union or to any international organization governed by public international law or set up by two or more countries, such as the UN, and about the security measures taken by us to safeguard your information. If any such transfer takes place, you can find out more by checking the relevant sections of this document or inquire with us using the information provided in the Contact section.

The rights of users

You may exercise certain rights regarding your information processed by us. In particular, you have the right to do the following: (i) you have the right to withdraw consent where you have previously given your consent to the processing of your information; (ii) you have the right to object to the processing of your information if the processing is carried out on a legal basis other than consent; (iii) you have the right to learn if information is being processed by us, obtain disclosure regarding certain aspects of the processing and obtain a copy of the information undergoing processing; (iv) you have the right to verify the accuracy of your information and ask for it to be updated or corrected; (v) you have the right, under certain circumstances, to restrict the processing of your information, in which case, we will not process your information for any purpose other than storing it; (vi) you have the right, under certain circumstances, to obtain the erasure of your Personal Information from us; (vii) you have the right to receive your information in a structured, commonly used and machine readable format and, if technically feasible, to have it transmitted to another controller without any hindrance. This provision is applicable provided that your information is processed by automated means and that the processing is based on your consent, on a contract which you are part of or on pre-contractual obligations thereof.

The right to object to processing

Where Personal Information is processed for a public interest, in the exercise of an official authority vested in us or for the purposes of the legitimate interests pursued by us, you may object to such processing by providing a ground related to your particular situation to justify the objection. You must know that, however, should your Personal Information be processed for direct marketing purposes, you can object to that processing at any time without providing any justification. To learn whether we are processing Personal Information for direct marketing purposes, you may refer to the relevant sections of this document.

How to exercise these rights

Any requests to exercise User rights can be directed to the Owner by email at matt@motion.dev. These requests can be exercised free of charge and will be addressed by the Owner as early as possible and always within one month.

Privacy of children

We do not knowingly collect any Personal Information from children under the age of 13. If you are under the age of 13, please do not submit any Personal Information through our Website. We encourage parents and legal guardians to monitor their children's Internet usage and to help enforce this Policy by instructing their children never to provide Personal Information through our Website without their permission. If you have reason to believe that a child under the age of 13 has provided Personal Information to us through our Website, please contact us.

Cookies

The Website uses "cookies" to help personalize your online experience. A cookie is a text file that is placed on your hard disk by a web page server. Cookies cannot be used to run programs or deliver viruses to your computer. Cookies are uniquely assigned to you, and can only be read by a web server in the domain that issued the cookie to you. We may use cookies to collect, store, and track information for statistical purposes to operate our Website. You have the ability to accept or decline cookies. Most web browsers automatically accept cookies, but you can usually modify your browser setting to decline cookies if you prefer.

In addition to using cookies and related technologies as described above, we also may permit certain third-party companies to help us tailor advertising that we think may be of interest to users and to collect and use other data about user activities on the Website. These companies may deliver ads that might also place cookies and otherwise track user behavior.

Links to other websites

Our Website contains links to other websites that are not owned or controlled by us. Please be aware that we are not responsible for the privacy practices of such other websites or third parties. We encourage you to be aware when you leave our Website and to read the privacy statements of each and every website that may collect Personal Information.

In particular, as noted above, purchases made through the Website are handled by Paddle and all such transactions, including any Personal Information or non-personal information collected by Paddle, are under the control of Paddle. We encourage purchasers to read Paddle’s Privacy Policy (paddle.com/legal-buyers/).

Information security

We secure information you provide on computer servers in a controlled, secure environment, protected from unauthorized access, use, or disclosure. We maintain reasonable administrative, technical, and physical safeguards in an effort to protect against unauthorized access, use, modification, and disclosure of Personal Information in its control and custody. However, no data transmission over the Internet or wireless network can be guaranteed. Therefore, while we strive to protect your Personal Information, you acknowledge that (i) there are security and privacy limitations of the Internet which are beyond our control; (ii) the security, integrity, and privacy of any and all information and data exchanged between you and our Website cannot be guaranteed; and (iii) any such information and data may be viewed or tampered with in transit by a third-party, despite best efforts.

Data breach

In the event we become aware that the security of the Website has been compromised or users’ Personal Information has been disclosed to unrelated third-parties as a result of external activity, including, but not limited to, security attacks or fraud, we reserve the right to take reasonably appropriate measures, including, but not limited to, investigation and reporting, as well as notification to and cooperation with law enforcement authorities. In the event of a data breach, we will make reasonable efforts to notify affected individuals if we believe that there is a reasonable risk of harm to the user as a result of the breach or if notice is otherwise required by law. When we do we will send you an email.

Legal disclosure

We will disclose any information we collect, use or receive if required or permitted by law, such as to comply with a subpoena, or similar legal process, and when we believe in good faith that disclosure is necessary to protect our rights, protect your safety or the safety of others, investigate fraud, or respond to a government request. In the event we go through a business transition, such as a merger or acquisition by another company, or sale of all or a portion of its assets, your user account and personal data will likely be among the assets transferred.

Changes and amendments

We reserve the right to modify this privacy policy relating to the Website at any time, effective upon posting of an updated version of this Policy on the Website. When we do we will revise the updated date at the bottom of this page. Continued use of the Website after any such changes shall constitute your consent to such changes.

Acceptance of this policy

You acknowledge that you have read this Policy and agree to all its terms and conditions. By using the Website you agree to be bound by this Policy. If you do not agree to abide by the terms of this Policy, you are not authorized to use or access the Website.

Contacting us

If you have any questions about this Policy, please contact us by email at matt@motion.dev.

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

    

---

# https://motion.dev/docs/react-lazy-motion

Docs

Examples

Motion+

Documentation

React

LazyMotion

LazyMotion

For ease of use, the motion component comes pre-bundled with all of its features for a bundlesize of around 34kb.

With LazyMotion and the m component, we can reduce this to 6kb for the initial render and then sync or async load a subset of features.

import { LazyMotion, domAnimations } from "motion/react"
import * as m from "motion/react-m"


export const MyComponent = ({ isVisible }) => (
  <LazyMotion features={domAnimations}>
    <m.div animate={{ opacity: 1 }} />
  </LazyMotion>
)

Read the Reduce bundle size guide for full usage instructions.

Props
features

Define a feature bundle to load sync or async.

Sync loading

Synchronous loading is useful for defining a subset of functionality for a smaller bundlesize.

import { LazyMotion, domAnimations } from "motion/react"
import * as m from "motion/react-m"


export const MyComponent = ({ isVisible }) => (
  <LazyMotion features={domAnimations}>
    <m.div animate={{ opacity: 1 }} />
  </LazyMotion>
)
Async loading

Asynchronous loading can ensure your site is hydrated before loading in some or all animation functionality.

// features.js
import { domAnimations } from "motion/react"
export default domAnimations
  
// index.js
const loadFeatures = import("./features.js")
  .then(res => res.default)

function Component() {
  return (
    <LazyMotion features={loadFeatures}>
      <m.div animate={{ scale: 1.5 }} />
    </LazyMotion>
  )
}
strict

Default: false

If true, will throw an error if a motion component renders within a LazyMotion component (thereby removing the bundlesize benefits of lazy-loading).

// This component will throw an error that explains using a motion component
// instead of the m component will break the benefits of code-splitting.
function Component() {
  return (
    <LazyMotion features={domAnimations} strict>
      <motion.div />
    </LazyMotion>
  )
}

Cursor

LayoutGroup

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/hover

Docs

Examples

Motion+

Documentation

JavaScript

hover

hover

Motion's hover function detects hover gestures, firing events when they start and end.

For legacy reasons, browsers emulate hover events from touch devices, which can lead to "stuck" UIs and other unwanted visual artefacts/broken behaviours. hover filters these fake events out.

hover(".button", (element) => {
  console.log("hover started on", element)


  return () => console.log("hover end")
})

hover is also:

Clean: Automatically manages event listeners




Convenient: Accepts either elements or CSS selectors for attaching multiple gestures at once




Lazy: Attaches only the event listeners needed

hover callbacks can do anything, but often they're used to start or control animations.

hover("li", (element) => {
  const animation = animate(element, { rotate: 360 })


  return () => animation.stop()
})
Usage
Import

hover can be imported into your project via "motion":

import { hover } from "motion"
Hover start

hover can detect hover gestures on either an Element/array of elements:

hover(
  document.getElementById("my-id"),
  () => {
    console.log("my-id hovered!")
  }
)

Or via a CSS selector:

hover("a", () => console.log("link hovered"))

When a hover gesture starts, the provided callback is provided both the element that's being hovered, and the triggering PointerEvent:

hover("div:nth-child(2)", (element, startEvent) => {
  console.log("Hover started on", element)
  console.log("At", startEvent.clientX, startEvent.clientY)
})
Hover end

The hover start function can optionally return a callback. This will be called when the hover gesture ends:

hover("a", () => {
  console.log("hover start")
  
  return (endEvent) => {
    console.log("hover end")
  }
})

This callback will be provided the triggering PointerEvent.

Cancelling gesture detection

hover returns a function that, when fired, will cancel all active event handlers associated with the gesture.

const cancelHover = hover(element, callback)

cancelHover()
Options
passive

Default: true

If set to false, it'll be possible to call event.preventDefault() but the gesture will be less performant. Learn more about passive events.

once

Default: false

If set to true, each provided element will fire their gesture only once.

View animations

inView

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#usage

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#html-svg

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#transforms

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#css-variables

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#svg-paths

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})


// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#single-values

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})


// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#motion-values

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"


// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")


animate(box, { opacity: 0 }, { duration: 0.5 })


// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})


// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/react-motion-value

Docs

Examples

Motion+

Documentation

React

Overview

Motion values overview

Motion values track the state and velocity of animated values.

They are composable, signal-like values that are performant because Motion can render them with its optimised DOM renderer.

Usually, these are created automatically by motion components. But for advanced use cases, it's possible to create them manually.

import { motion, useMotionValue } from "motion/react"


export function MyComponent() {
  const x = useMotionValue(0)
  return <motion.div style={{ x }} />
}

By manually creating motion values you can:

Set and get their state.




Pass to multiple components to synchronise motion across them.




Chain MotionValues via the useTransform hook.




Update visual properties without triggering React's render cycle.




Subscribe to updates.

const x = useMotionValue(0)
const opacity = useTransform(
  x,
  [-200, 0, 200],
  [0, 1, 0]
)


// Will change opacity as element is dragged left/right
return <motion.div drag="x" style={{ x, opacity }} />
Usage

Motion values can be created with the useMotionValue hook. The string or number passed to useMotionValue will act as its initial state.

import { useMotionValue } from "motion/react"

const x = useMotionValue(0)

Motion values can be passed to a motion component via style:

<motion.li style={{ x }} />

Or for SVG attributes, via the attribute prop itself:

<motion.circle cx={cx} />

It's possible to pass the same motion value to multiple components.

Motion values can be updated with the set method.

x.set(100)

Changes to the motion value will update the DOM without triggering a React re-render. Motion values can be updated multiple times but renders will be batched to the next animation frame.

A motion value can hold any string or number. We can read it with the get method.

x.get() // 100

Motion values containing a number can return a velocity via the getVelocity method. This returns the velocity as calculated per second to account for variations in frame rate across devices.

const xVelocity = x.getVelocity()

For strings and colors, getVelocity will always return 0.

Events

Listeners can be added to motion values via the on method or the useMotionValueEvent hook.

useMotionValueEvent(x, "change", (latest) => console.log(latest))

Available events are "change", "animationStart", "animationComplete" "animationCancel".

Composition

Beyond useMotionValue, Motion provides a number of hooks for creating and composing motion values, like useSpring and useTransform.

For example, with useTransform we can take the latest state of one or more motion values and create a new motion value with the result.

const y = useTransform(() => x.get() * 2)

useSpring can make a motion value that's attached to another via a spring.

const dragX = useMotionValue(0)
const dragY = useMotionValue(0)
const x = useSpring(dragX)
const y = useSpring(dragY)

These motion values can then go on to be passed to motion components, or composed with more hooks like useVelocity.

API
get()

Returns the latest state of the motion value.

getVelocity()

Returns the latest velocity of the motion value. Returns 0 if the value is non-numerical.

set()

Sets the motion value to a new state.

x.set("#f00")
jump()

Jumps the motion value to a new state in a way that breaks continuity from previous values:

Resets velocity to 0.




Ends active animations.




Ignores attached effects (for instance useSpring's spring).

const x = useSpring(0)
x.jump(10)
x.getVelocity() // 0
isAnimating()

Returns true if the value is currently animating.

stop()

Stop the active animation.

on()

Subscribe to motion value events. Available events are:

change




animationStart




animationCancel




animationComplete

It returns a function that, when called, will unsubscribe the listener.

const unsubscribe = x.on("change", latest => console.log(latest))

When calling on inside a React component, it should be wrapped with a useEffect hook, or instead use the useMotionValueEvent hook.

destroy()

Destroy and clean up subscribers to this motion value.

This is normally handled automatically, so this method is only necessary if you've manually created a motion value outside the React render cycle using the vanilla motionValue hook.

Reorder

useMotionValueEvent

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/animate#objects

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)


animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}


animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()


animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#timeline-sequences

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)


animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}


animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()


animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"

animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/#at

Docs

Examples

Motion+

MOTION

A modern animation library for JavaScript and React

Quick start

Motion makes animation

simple, fun, and limitless.

Go beyond the browser with super smooth

springs, layout animations, timelines

and much, much more.

Free

Completely free to use and open-source under the MIT license.

Tiny

Mini animate is 90% smaller than its GSAP equivalent, scroll 75% smaller.

Production-ready

Written in TypeScript, with extensive test coverage.

Hybrid engine

The power of JS animations with the performance of hardware acceleration.

Simple

Motion One's pick-up-and-play API is easy to start and fun to master.

Examples:

Transforms

Go beyond CSS by animating transforms on every axis.

Examples:

Springs

Go beyond time-based animations with real spring physics for great-feeling animations.

Examples:

Scroll

Motion One uses browser APIs for beautiful scroll-linked and scroll-triggered animations.

Examples:

Exit animations

Motion One for React makes it easier than ever to animate elements as they exit the DOM.

Examples:

Layout animations

Animate between different layouts with Motion One's industry-leading layout animation engine.

Examples:

Gestures

Animate transforms on every axis independently, with full control over timing.

Examples:

Timeline

Animate transforms on every axis independently, with full control over timing.

Examples:

Our Sponsors

Motion is made possible thanks to our amazing sponsors.

Framer
Figma
Linear
Emil Kowalski
Tailwind
Liveblocks
Vercel
Luma

Become a sponsor

Courses

Motion for React has video and interactive courses built by the best educators in the world.

Animations on the Web

Taught by 

Emil Kowalski

The Joy of React

Taught by 

Josh W. Comeau

See all courses

Premium components

Motion+ grants access to premium React components, starting with Cursor and AnimateNumber.

All components are built in TypeScript and supported by a strong test suite. Install via npm, with source access via our private Github repo.

Showcase

All the beautiful sites featured in the Framer gallery are powered by Motion.

Here are some more amazing interactions made by developers with its flexible APIs.

Delight the web with Motion

Quick start

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

                 

---

# https://motion.dev/#options

Docs

Examples

Motion+

MOTION

A modern animation library for JavaScript and React

Quick start

Motion makes animation

simple, fun, and limitless.

Go beyond the browser with super smooth

springs, layout animations, timelines

and much, much more.

Free

Completely free to use and open-source under the MIT license.

Tiny

Mini animate is 90% smaller than its GSAP equivalent, scroll 75% smaller.

Production-ready

Written in TypeScript, with extensive test coverage.

Hybrid engine

The power of JS animations with the performance of hardware acceleration.

Simple

Motion One's pick-up-and-play API is easy to start and fun to master.

Examples:

Transforms

Go beyond CSS by animating transforms on every axis.

Examples:

Springs

Go beyond time-based animations with real spring physics for great-feeling animations.

Examples:

Scroll

Motion One uses browser APIs for beautiful scroll-linked and scroll-triggered animations.

Examples:

Exit animations

Motion One for React makes it easier than ever to animate elements as they exit the DOM.

Examples:

Layout animations

Animate between different layouts with Motion One's industry-leading layout animation engine.

Examples:

Gestures

Animate transforms on every axis independently, with full control over timing.

Examples:

Timeline

Animate transforms on every axis independently, with full control over timing.

Examples:

Our Sponsors

Motion is made possible thanks to our amazing sponsors.

Framer
Figma
Linear
Emil Kowalski
Tailwind
Liveblocks
Vercel
Luma

Become a sponsor

Courses

Motion for React has video and interactive courses built by the best educators in the world.

Animations on the Web

Taught by 

Emil Kowalski

The Joy of React

Taught by 

Josh W. Comeau

See all courses

Premium components

Motion+ grants access to premium React components, starting with Cursor and AnimateNumber.

All components are built in TypeScript and supported by a strong test suite. Install via npm, with source access via our private Github repo.

Showcase

All the beautiful sites featured in the Framer gallery are powered by Motion.

Here are some more amazing interactions made by developers with its flexible APIs.

Delight the web with Motion

Quick start

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

                 

---

# https://motion.dev/docs/animate#stagger

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()


const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/stagger

Docs

Examples

Motion+

Documentation

JavaScript

stagger

stagger

When animating elements with the animate function, it's possible to stagger animations across them using stagger().

import { animate, stagger } from "motion"


animate(
  "li",
  { opacity: 1 },
  { delay: stagger(0.1) }
)
Usage

Import stagger from Motion.

import { animate, stagger } from "motion"

By passing a duration, in seconds, to stagger, the delay of each element will be increased by that amount for each animation.

animate(
  "li",
  { opacity: 1 },
  { delay: stagger(0.1) }
)
Options

stagger accepts options via its second argument.

startDelay

Default: 0

The initial delay from which to calculate subsequent delays.

stagger(0.1, { startDelay: 0.2 }) // 0.2, 0.3, 0.4...
from

Default: "first"

Specifies which element in the array from which to stagger. Can be set as "first", "center", "last", or a number to specify an index.  

ease

Default: "linear"

By passing an easing function, staggers can be redistributed through the total stagger time.

Any easing function or Motion easing is accepted, like a cubic bezier definition:

stagger(0.1, { ease: [.32, .23, .4, .9] })

Name of an easing function:

stagger(0.1, { ease: "easeOut" })

Or a custom easing function:

stagger(0.1, { ease: p => Math.sin(p) })

spring

transform

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#options

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#type

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"

animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#tween

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#duration

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#ease

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#times

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#spring

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#bounce

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#visualduration

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#stiffness

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#damping

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#mass

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#velocity

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#restspeed

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#restdelta

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#orchestration

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#delay

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#repeat

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#repeattype

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#repeatdelay

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#at

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#onupdate

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })

animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })

const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })

// Set animation time to 0.5 seconds
animation.time = 0.5

// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#controls

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#duration-1

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#time

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })

const currentSpeed = animation.speed

// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })

// Async/await
await animation
console.log("Animation complete")

// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#speed

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#then()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()

// Will resume from 1 second
animation.time = 1
animation.play()

// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#pause()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()


// Will resume from 1 second
animation.time = 1
animation.play()


// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#play()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()


// Will resume from 1 second
animation.time = 1
animation.play()


// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#complete()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()


// Will resume from 1 second
animation.time = 1
animation.play()


// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#cancel()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()


// Will resume from 1 second
animation.time = 1
animation.play()


// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/animate#stop()

Docs

Examples

Motion+

Documentation

JavaScript

animate

animate

The animate() function is a powerful tool for creating and controlling animations.

animate("li", { opacity: 0 })

It comes in two sizes, mini (2.5kb) and hybrid (18kb).

The mini version can animate HTML and SVG styles using native browser APIs for incredible performance.

The hybrid version can additionally animate:

Independent transforms (x/y/rotateZ etc)




More styles, like mask-image and gradients




CSS variables




SVG paths




Animation sequences




Colors/strings/numbers




JavaScript objects and WebGL

Usage

animate can be imported from the "motion" package:

// Hybrid
import { animate } from "motion"

// Mini
import { animate } from "motion/mini"
HTML & SVG

Both versions of animate are capable of animating HTML and SVG styles either by passing elements directly, or via CSS selectors.

// Element(s)
const box = document.getElementById("box")

animate(box, { opacity: 0 }, { duration: 0.5 })

// CSS selectors
animate("div", { opacity: 0 }, { duration: 0.5 })
Transforms

The hybrid version of animate can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

animate("div", { rotate: 360 })
CSS variables

Hybrid  animate can animate CSS variables in every browser:

animate(element, { "--rotate": "360deg" })

Mini animate can only animate registered CSS properties in modern browsers.

SVG paths

The hybrid animate function can perform line drawing animations with most SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

animate("circle", { pathLength: [0, 1] })

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Single values

By passing a to and from value, the hybrid animate will output the latest values to the provided onUpdate callback.

// Numbers
animate(0, 100, {
  onUpdate: latest => console.log(latest)
})

// Colors
animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Motion values

By passing hybrid animate a React motion value, it'll be automatically updated with the latest values.

const x = motionValue(0)

animate(x, 200, { duration: 0.5 })
Objects

Objects can be animated much in the same way as HTML & SVG elements.

const values = {
  x: 100,
  color: "#f00"
}

animate(values, { x: 200, color: "#00f" })

Any object can be animated, for instance an Object3D from Three.js:

const camera = new THREE.Camera()

animate(camera.rotation, { y: 360 }, { duration: 10 })
Timeline sequences

The hybrid animate function can also accept complex animation sequences.

const sequence = []

animate(sequence)

A sequence is an array of animate definitions:

const sequence = [
  ["ul", { opacity: 1 }, { duration: 0.5 }],
  ["li", 100, { ease: "easeInOut" }]
]

Each definition will, by default, play one after the other.

It's possible to change when a segment will play by passing an at option, which can be either an absolute time, relative time, or label.

const sequence = [
  ["ul", { opacity: 1 }],
  ["li", { x: [-100, 0] }, { at: 1 }]
]

Each segment can accept all animate options (except repeatDelay and repeatType) to control the duration and other animation settings of that segment.

const sequence = [
  ["ul", { opacity: 1 }, { duration: 1 }]
]

Both type: "keyframes" and type: "spring" transitions are supported.

It's also possible to override transitions for each value individually.

const sequence = [
  [
    "ul",
    { opacity: 1, x: 100 },
    { duration: 1, x: { duration: 2 }}
   ]
]

Sequence durations are automatically calculated, but it's also possible to pass any animate option to change playback as a whole:

animate(sequence, { duration: 10, repeat: 2 })

You can also define default transition settings to be passed to all items in the sequence with the defaultTransition option:

animate(sequence, {
  defaultTransition: { duration: 0.2 }
})

Any value supported by animate can be animated in sequences, mixing HTML & SVGs, motion values and objects in the same animation:

const color = motionValue("rgba(255, 0, 0, 1)")
const box = new THREE.BoxGeometry()

const sequence = [
  ["li", { x: 100 }],
  [box.position, { y: 10 }],
  [color, "#444"]
]
Stagger

When animating more than one element, it's possible to stagger animations by passing the stagger function to delay.

import { stagger, animate } from "motion"


animate(".item", { x: 300 }, { delay: stagger(0.1) })
Options

Animations can be configured with transition options. By default, provided options will affect every animating value.

animate(
  element,
  { x: 100, rotate: 0 },
  { duration: 1 }
)

By providing named transitions, these can be overridden on a per-value basis:

animate(
  element,
  { x: 100, rotate: 0 },
  {
    duration: 1,
    rotate: { duration: 0.5, ease: "easeOut" }
  }
)
type

type decides the type of animation to use.

Mini animate can either animate with the default keyframes animation, or spring:

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, stiffness: 300 }
)

Hybrid animate has all animation types built-in, and can be set to "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

animate("path", { pathLength: 1 }, { duration: 2, type: "tween" })
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

animate(
  element,
  { x: [0, 100, 0] },
  { ease: ["easeIn", "easeOut"] }
)
times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

animate(
  element,
  { x: [0, 100, 0] },
  { times: [0, 0.3, 1] }
)

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
Time
Physics
Duration
Bounce
Use visual duration
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", bounce: 0.25 }
)
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

animate(
  "section",
  { rotateX: 90 },
  { type: "spring", visualDuration: 0.5, bounce: 0.25 }
)
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

animate(
  "section",
  { rotate: 180 },
  { type: "spring", stiffness: 50 }
)
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

animate(
  "section",
  { rotate: 180 },
  { type: "spring", damping: 300 }
)
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

animate(
  "feTurbulence",
  { baseFrequency: 0.5 },
  { type: "spring", mass: 0.5 }
)
velocity

Default: Current value velocity

The initial velocity of the spring.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", velocity: 2 }
)
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

animate(
  ".my-element",
  { rotate: 180 },
  { type: "spring", restSpeed: 2 }
)
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

animate(
  ".my-element",
  { x: 200 },
  { type: "spring", restDelta: 0.5 }
)
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: Infinity, duration: 2 }
)
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatType: "reverse", duration: 2 }
)
repeatDelay

Default: 0

Note: Not available in animate mini.

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

animate(
  element,
  { backgroundColor: "#fff" },
  { repeat: 1, repeatDelay: 1 }
)
at

When defining animations as part of a larger sequence, each definition will start one after the other:

const sequence = [
  ["ul", { opacity: 1 }],
  // This will start when ul opacity is 1
  ["li", { x: [-100, 0] }]
]

By passing at, this behaviour can be changed.

Pass a number to define a specific time:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 from the start of the whole timeline:
  ["nav", { x: 100 }, { at: 0.5 }],
]

Pass a string starting with + or - to start relative to the end of the previous animation:

const sequence = [
  ["nav", { opacity: 1 }],
  // This will start 0.5 seconds after the previous animation:
  ["nav", { x: 100 }, { at: "+0.5" }],
  // This will start 0.2 seconds before the end of the previous animation:
  ["nav li", { opacity: 1 }, { at: "-0.2" }],
]

Pass "<" to start at the same time as the previous segment:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  // This will start at the same time as the x: 100 animation
  ["li", { opacity: 1 }, { at: "<" }],
]

Or pass a label name to start at the same point as the original label definition:

const sequence = [
  ["nav", { x: 100 }, { duration: 1 }],
  "my-label",
  ["li", { opacity: 1 }],
  // my-label was defined at 1 second
  ["a", { scale: 1.2 }, { at: "my-label" }],
]
onUpdate

A function that's provided the latest animation values.

Note: Currently for single value and motion value animations only.

animate("#fff", "#000", {
  duration: 2
  onUpdate: latest => console.log(latest)
})
Controls

animate() returns animation playback controls. These can be used to pause, play, cancel, change playback speed and more.

const animation = animate(element, { opacity: 1 })


animation.time = 0.5
animation.stop()
duration

Returns the duration of the animation.

This is the duration of a single iteration of the animation, without delay or repeat options. It is read-only.

const animation = animate(element, { opacity: 0 })


const duration = animation.duration
time

Gets and sets the current time of the animation.

const animation = animate(x, 100, { duration: 1 })


// Set animation time to 0.5 seconds
animation.time = 0.5


// Get animation time
console.log(animation.time) // 0.5
speed

Gets and sets the current playback speed of the animation.

1 is normal rate.




0.5 is half rate.




2 doubles the playback rate.




-1 reverses playback.

const animation = animate(element, { opacity: 0 })


const currentSpeed = animation.speed


// Double current speed
animation.speed = currentSpeed * 2
then()

A Promise-like API that resolves when the animation finishes:

const animation = animate(element, { opacity: 0 })


// Async/await
await animation
console.log("Animation complete")


// Promise
animation.then(() => {
  console.log("Animation complete")
})

Note: When an animation finishes, a new Promise is created. If the animation is then replayed via the play() method, any old callbacks won't fire again.

pause()

Pauses the animation until resumed with play().

const animation = animate(element, { opacity: 0 })
animation.pause()
play()

Plays an animation.

If an animation is paused, it will resume from its current time.




If an animation has finished, it will restart.

animation.pause()


// Will resume from 1 second
animation.time = 1
animation.play()


// Will play from start
await animation
animation.play()
complete()

Immediately completes the animation, running it to the end state.

animation.complete()
cancel()

Cancels the animation, reverting it to the initial state.

const animation = animate(element, { opacity: 0 })
animation.cancel()
stop()

Stops the animation.

Any values being animated via the Web Animations API will be committed to the element via style.

Stopped animations cannot be restarted.

const animation = animate(element, { opacity: 0 })
animation.stop()

Quick start

scroll

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#usage

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#sampling-a-spring

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#visualiser

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#css-generation

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#options

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#keyframes

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#time-options

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#duration

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#visualduration

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#bounce

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#physics-options

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#damping

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#mass

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#stiffness

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#velocity

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#restspeed

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/spring#restdelta

Docs

Examples

Motion+

Documentation

JavaScript

spring

spring

The spring function is most often used to provide spring functionality to the mini animate() function. 

import { animate } from "motion/mini"
import { spring } from "motion"


animate(
  element,
  { transform: "translateX(100px)" },
  { type: spring, bounce: 0.3, duration: 0.8 }
)

However, spring can also be used directly for low-level, advanced use cases. For instance, creating a spring visualiser.

Usage

Import spring from Motion.

import { spring } from "motion"

spring is a function that returns a generator.

const generator = spring({ keyframes: [0, 100] })

This generator can be used to sample to spring at specific times (defined in milliseconds).

As a generator, next() returns two values, value and done.

const { value, done } = generator.next(10) // Spring state at 10 milliseconds

The spring can be sampled in a non-linear fashion, meaning you can sample the spring at any time.

generator.next(100)
generator.next(10)
Sampling a spring

For most use-cases, like linear() easing generation or visualisation, you will probably want to run the generator in time order. You can do this with a normal loop that continues until the spring is done.

const generator = spring({ keyframes: [25, 75], stiffness: 400 })
const output = []


let isDone = false
let time = 0
const sampleDuration = 20 // ms


while (!isDone) {
  const { value, done } = generator.next(time)


  output.push(value)


  time += sampleDuration


  if (done) isDone = true
}

Warning: Springs with damping: 0 will run forever, so you'll need to put some kind of constraint on how many times the spring will be sampled, or what the minimum damping can be, etc.

Visualiser
Time
Physics
Duration
Bounce
Use visual duration
CSS generation

It's possible to use spring() to generate CSS transitions.

element.style.transition = "all " + spring(0.5)

Read the CSS generation guide for more details.

Options

The spring can be configured with a number of options.

keyframes

spring must be provided with two keyframes to animate between. These can be any two numerical values.

spring({ keyframes: [0, 100] })
Time options

Note: Time options will be overridden if any physics options are set.

duration

Default: 800

Duration for the entire spring.

Important: Most Motion APIs use seconds, for historical reasons duration is set in milliseconds. 

visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

Physics options
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

velocity

Default: Current value velocity

The initial velocity of the spring.

restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

mix

stagger

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/mix

Docs

Examples

Motion+

Documentation

JavaScript

mix

mix

mix can create a function that will mix between two values, based on a 0-1 progress value.

const mixer = mix(0, 100)
mixer(0.5) // 50

mix is capable of mixing between many different value types:

Numbers




Colors (RGBA, HSLA)




Complex strings




Arrays and objects of the above

Additionally, RGB color mixing is performed using the linear RGB color space, ensuring colors are mixed without the typical CSS brightness dips/greyness.

Usage

Import from Motion:

import { mix } from "motion"

Create a mixer by passing two values of the same type:

const mixNumber = mix(0, 100)
const mixColor = mix("#000", "#FFF")
const mixObject = mix(
  { a: "0px", b: 10 },
  { a: "20px", b: 0 }
)

Pass the mixer function a 0-1 progress to return a mixed value.

const mixComplex = mix("0px 0px #fff", "100px 100px #000")

mixComplex(0.5) // 50px 50px rgba(128, 128, 128, 1)

Values outside the 0-1 range are also accepted.

const mixNumber = mix(0, 100)

mixNumber(2) // 200
mixNumber(-1) // -100
Easing

You can apply easing to the mixed value by passing progress through an easing function:

import { mix, easeInOut } from "motion"

const mixNumber = mix(0, 100)

mixNumber(easeInOut(0.75))

frame

spring

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#usage

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#callbacks

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#animation

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#scroll-axis

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#track-element-scroll

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#track-element-position

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#scroll-offsets

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#pinning

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#scroll-information

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)

cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#cancel-animation

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#options

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#container

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#axis

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#target

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#offset

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/scroll#accepted-intersections

Docs

Examples

Motion+

Documentation

JavaScript

scroll

scroll

Motion's 5.1kb scroll() function creates scroll-linked animations.

A scroll-linked animation is where a value is bound directly to scroll progress. When the scroll changes, the value changes by the relative amount.

This is in contrast to a scroll-triggered animation, which is when an animation starts/stops when an element enters/leaves the viewport. In Motion, these can be built with inView. 

scroll is the only API that takes advantage of Motion's hybrid engine, using the ScrollTimeline API where possible for optimal performance. This removes scroll measurements and enables hardware-accelerated animations.

Usage

Import scroll from Motion:

import { scroll } from "motion"
Callbacks

scroll() can accept a callback function. This callback will be called when scroll changes with the latest progress value, between 0 and 1.

scroll(progress => console.log(progress))
Animation

scroll() can also accept animations created with the animate() function.

const animation = animate(
  "div",
  { transform: ["none", "rotate(90deg)"] },
  { ease: "linear" }
)  


scroll(animation)

Browsers that support the ScrollTimeline API will use this to run supported animations with hardware acceleration.

Scroll axis

By default, vertical scroll is tracked. By providing an axis: "x" option, it can instead track horizontal scrolling.

scroll(callback, { axis: "x" })
Track element scroll

scroll() tracks window scroll by default. It can also track the scroll of an Element, by passing it in via the container option.

scroll(callback, { container: document.getElementById("scroller") })
Track element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

scroll(animation, { target: document.getElementById("item") })
Scroll offsets

With the offset option we can define which parts of the target we want to track within the container, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

Pinning

To use the browser for best performance, pinning should be performed with position: sticky.

This works well, for instance, to create section-based full-screen effects, by using a larger container element to define the scroll distance and passing this to the target option:

Scroll information

By passing a callback with a second info argument, it's possible to get detailed information about scrolling.

scroll((progress, info) => {
  console.log(info.x.current)
})

The info object contains:

time: The time the scroll position was recorded.




x: Info on the x scroll axis.




y: Info on the y scroll axis.

Each individual axis is an object containing the following data:

current: The current scroll position.




offset: The scroll offsets resolved as pixels.




progress: A progress value, between 0-1 of the scroll within the resolved offsets.




scrollLength: The total scrollable length on this axis. If target is the default scrollable area, this is the container scroll length minus the container length.




velocity: The velocity of the scroll on this axis.

Cancel animation

scroll() returns a cleanup function. Call this to cancel the scroll animation.

const cancel = scroll(callback)


cancel()
Options
container

Default: window

The container scroller element or window that we're tracking the scroll progress of.

scroll(
  (progress) => console.log(progress),
  { container: document.getElementById("carousel") }  
)
axis

Default: "y"

The axis of scroll to track. Defaults to "y".

scroll(
  (progress) => console.log(progress),
  { axis: "x" }  
)
target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

scroll(
  animation
  { target: document.getElementById("item") }  
)
offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

animate

View animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#usage

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)

stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#leaving-the-viewport

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)

stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#change-viewport

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")

inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#stop-detection

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#options

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#root

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#margin

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/inview#amount

Docs

Examples

Motion+

Documentation

JavaScript

inView

inView

inView detects when elements enter and leave the viewport.

inView("#carousel li", (element) => {
  animate(element, { opacity: 1 })
})

Detecting when an element is in view can help creating effects like:

Animating elements when they scroll into and out of view.




Deactivating animations when they're no longer visible.




Lazy-loading content.




Automatically start/stop videos.

inView function is built on the browser's native Intersection Observer API for the best possible performance (all calculations happen off the main JavaScript thread) and a tiny filesize (just 0.5kb).

Usage

Import from "motion":

import { inView } from "motion"

inView can accept either a selector, Element, or array of Elements.

// Selector
inView("section", callback)


// Element
const box = document.getElementById("box")
inView(box, callback)

By default, the provided callback will fire just once, when the element first enters the viewport.

inView(element, () => {
  console.log("Element has entered the viewport")
})

This callback is provided the matched element and an IntersectionObserverEntry object which contains information on the intersection.

inView("a", (element, info) => {
  console.log("The link ", element, " has entered the viewport")
})
Leaving the viewport

A function returned from this callback will fire when the element leaves the viewport.

inView(element,
  (element, enterInfo) => {
    const animation = animate(element, { opacity: 1 })
    
    // This will fire when the element leaves the viewport
    return (leaveInfo) => animation.stop()
  }
)

Additionally, the gesture will also continue to fire as the element enters/leaves the viewport.

Change viewport

By default, inView detects when the provided element(s) enter/leave the default viewport: The browser window.

But it can also detect when the element(s) enter/leave the viewport of a scrollable parent element, by passing that element to the root option:

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
Stop detection

inView returns a function that, when fired, will stop viewport detection.

const stop = inView(element, callback)


stop()
Options
root

Default: window

If provided, inView will use the root element's viewport to detect whether the target elements are in view. Otherwise defaults to the browser window.

const carousel = document.querySelector("#carousel")


inView("#carousel li", callback, { root: carousel })
margin

Default: 0

One or more margins to apply to the viewport. This will extend or contract the point at which the element is considered inside or outside the viewport.

margin can be defined in pixels or percentages. It can accept up to four values in the order of top/right/bottom/left.

inView(element, callback, { margin: "0px 100px 0px 0px" })

Positive values extend the viewport boundaries beyond the root whereas negative values will pull it in.

Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

amount

Default: "some"

The amount of the target element that needs to be within the viewport boundaries to be considered in view.

This can be defined as "some", for some of the element, or "all", for all of the element.

Additionally, it can be defined as a number proportion between 0 and 1 where 0 is "some" and 1 is "all".

hover

press

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/press

Docs

Examples

Motion+

Documentation

JavaScript

press

press

Motion's press function detects press gestures, firing events when they start, end or cancel.

It's different to native browser events like "pointerstart" etc in that press automatically filters out secondary pointer events, like right clicks or a second touch point.

It also expands on "click" by being great for accessibility. Every element with a press gesture automatically becomes keyboard accessible via focus and the enter key.

press("button", (element) => {
  console.log("press started on", element)


  return () => console.log("press ended")
})

press is also:

Clean: Automatically manages event listeners




Convenient: Accepts either elements or CSS selectors for attaching multiple listeners at once




Lazy: Attaches only the listeners needed

It can be used to fire any function, but also to start and stop animations:

press("button", (element) => {
  animate(element, { scale: 0.9 })

  return () => animate(element, { scale: 1 })
})
Video overview
Usage
Import

press can be imported via "motion".

import { press } from "motion"
Press start

press can detect press start gestures on either a Element/array of elements:

press(
  document.getElementById("my-id"),
  () => {
    console.log("my-id pressed!")
  }
)

It also accepts CSS selectors to detect press start on multiple elements:

press("a", () => console.log("link pressed"))

The callback is provided the element being pressed, and the triggering PointerEvent:

press("div:nth-child(2)", (element, startEvent) => {
  console.log("Pressed", element)
  console.log("At", startEvent.clientX, startEvent.clientY)
})
Press end

The press start function can optionally return a function that will be called when the press gesture ends:

press(element, (element, startEvent) => {
  console.log("press start")
  
  return (endEvent) => {
    console.log("press end")
  }
})

The press end callback is passed a second argument, info. It currently has one property, success. If true, the press was successfully completed, like a click. If false, the press ended outside the element.

press(element, () => {
  return (endEvent, info) => {
    console.log("press ", info.success ? "end" : "cancel")
  }
})

When using keyboard accessibility, success will be false if the element is blurred while the enter key is held.

Cancelling gesture

press returns a function that, when fired, will cancel all active event handlers associated with the gesture.

const cancelPress = press(element, callback)

cancelPress()
Options
passive

Default: true

If set to false, it'll be possible to call event.preventDefault() but the gesture will be less performant. Learn more about passive events.

once

Default: false

If set to true, each provided element will fire their gesture only once.

inView

Easing functions

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/react-motion-component#usage

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#performance

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#server-side-rendering

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#custom-components

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#props

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#animation

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#initial

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#animate

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#exit

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#transition

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#variants

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"


// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)


useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)


  return () => clearTimeout(timeout)
}, [])


return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-animation#variants

Docs

Examples

Motion+

Documentation

React

Overview

Animation

Motion for React offers a number of ways to animate your UI. Scaling from extremely simple prop-based animations, to more complex orchestration.

Basic animations

You'll perform almost all animations on a <motion /> component. This is basically a DOM element with motion superpowers.

import { motion } from "motion/react"

For basic animations, you can update values on the animate prop:

<motion.div animate={{ opacity: 1 }} />

When any value in its animate prop changes, the component will automatically animate to the new target.

Animatable values

Motion can animate any CSS value, even those that can't be animated by browsers, like mask-image. It supports:

Numbers: 0, 100 etc.




Strings containing numbers: "0vh", "10px" etc.




Colors: Hex, RGBA, HSLA.




Complex strings containing multiple numbers and/or colors (like box-shadow).




display: none/block and visibility: hidden/visible.

Value type conversion

In general, values can only be animated between two of the same type (i.e "0px" to "100px").

However, x, y, width, height, top, left, right and bottom can animate between different value types.

<motion.div
  initial={{ x: "100%" }}
  animate={{ x: "calc(100vw - 50%)" }}
/>

Additionally, hex, RGBA and HSLA can be animated between on another.

Transforms

Unlike CSS, Motion can animate every transform axis independently:

Translate: x, y, z




Scale: scale, scaleX, scaleY




Rotate: rotate, rotateX, rotateY, rotateZ




Skew: skew, skewX, skewY




Perspective: transformPerspective

motion components have enhanced style props, allowing you to set individual transforms:

<motion.section style={{ x: -20 }} />

Animating transforms independently provides great flexibility, especially around gestures.

<motion.button whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} />

Independent transforms perform great, but Motion's hybrid engine also uniquely offers hardware acceleration by setting transform directly.

<motion.li
  initial={{ transform: "translateX(-100px)" }}
  animate={{ transform: "translateX(0px)" }}
  transition={{ type: "spring" }}
/>

SVG note: For SVG components, x and y attributes can be set using attrX and attrY.

Transform origin

transform-origin has three shortcut values that can be set and animated individually:

originX




originY




originZ

If set as numbers, originX and Y default to a progress value between 0 and 1. originZ defaults to pixels.

<motion.div style={{ originX: 0.5 }} />
CSS variables

Motion for React can animate the value of CSS variables, and also use CSS variables as animation targets.

Animating CSS variables

Sometimes it's convenient to be able to animate a CSS variable to animate many children:

<motion.ul
  initial={{ '--rotate': '0deg' }}
  animate={{ '--rotate': '360deg' }}
  transition={{ duration: 2, repeat: Infinity }}
>
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
  <li style={{ transform: 'rotate(var(--rotate))' }} />
</motion.ul>

Note: Animating the value of a CSS variable always triggers paint, therefore it can be more performant to use MotionValues to setup this kind of animation.

CSS variables as animation targets

HTML motion components accept animation targets with CSS variables:

<motion.li animate={{ backgroundColor: "var(--action-bg)" }} />
SVG line drawing

Line drawing animations can be created with many different SVG elements using three special properties: pathLength, pathSpacing and pathOffset.

<motion.path initial={{ pathLength: 0 }} animate={{ pathLength: 1 }} />

All three are set as a progress value between 0 and 1, 1 representing the total length of the path.

Path animations are compatible with circle, ellipse, line, path, polygon, polyline and rect elements.

Transitions

By default, Motion will create appropriate transitions for snappy animations based on the type of value being animated.

For instance, physical properties like x or scale are animated with spring physics, whereas values like opacity or color are animated with duration-based easing curves.

However, you can define your own animations via the transition prop.

<motion.div
  animate={{ x: 100 }}
  transition={{ ease: "easeOut", duration: 2 }}
/>
Enter animations

When a motion component is first created, it'll automatically animate to the values in animate if they're different from those initially rendered, which you can either do via CSS or via the initial prop. 

<motion.li
  initial={{ opacity: 0, scale: 0 }}
  animate={{ opacity: 1, scale: 1 }}
/>

You can also disable the enter animation entirely by setting initial={false}. This will make the element render with the values defined in animate.

<motion.div initial={false} animate={{ y: 100 }} />
Exit animations

You can also easily animate elements as they exit the DOM.

In React, when a component is removed, it's usually removed instantly. Motion provides the AnimatePresence component which keeps elements in the DOM while they perform an exit animation.

<AnimatePresence>
  {isVisible && (
    <motion.div
      key="modal"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    />
  )}
</AnimatePresence>
Keyframes

Values in animate can be set as a series of keyframes. This will animate through each value in sequence.

<motion.div animate={{ x: [0, 100, 0] }} />

We can use a value's current state as the initial keyframe by setting it to null.

<motion.div animate={{ x: [null, 100, 0] }} />

This way, if a keyframe animation is interrupting another animation, the transition will feel more natural.

By default, each keyframe is spaced naturally throughout the animation. You can override this by setting the times option via transition.

times is an array of progress values between 0 and 1, defining where in the animation each keyframe should be positioned.

<motion.circle
  cx={500}
  animate={{
    cx: [null, 100, 200],
    transition={{ duration: 3, times: [0, 0.2, 1] }}
  }}
/>
Gesture animations

Motion for React has shortcut props for animating to/from a target when a gesture starts/ends.

<motion.button
  initial={{ opacity: 0 }}
  whileHover={{ backgroundColor: "rgba(220, 220, 220, 1)" }}
  whileTap={{ backgroundColor: "rgba(255, 255, 255, 1)" }}
  whileInView={{ opacity: 1 }}
/>

It supports hover, tap, drag, focus and inView.

Variants

Setting animate as a target is useful for simple, single-element animations. But sometimes we want to orchestrate animations that propagate throughout the DOM. We can do so with variants.

Variants are a set of named targets.

const variants = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

They're passed to motion components via the variants prop:

<motion.div variants={variants} />

These variants can now be referred to by a label, wherever you can define an animation target:

<motion.div
  variants={variants}
  initial="hidden"
  whileInView="visible"
/>

You can also define multiple variants via an array:

animate={["visible", "danger"]}

I love using variants alongside React state – just pass your state to animate, and now you've got a tidy place to define all your animation targets!

const [status, setStatus] = useState<"inactive" | "active" | "complete">(
  "inactive"
);

<motion.div
  animate={status} // pass in our React state!
  variants={{
    inactive: { scale: 0.9 color: "var(--gray-500)" },
    active: { scale: 1 color: "var(--blue-500)" },
    complete: { scale: 1 color: "var(--blue-500)" }
  }}
>
  <motion.svg
    path={checkmarkPath}
    variants={{
      inactive: { pathLength: 0 },
      active: { pathLength: 0 },
      complete: { pathLength: 1}
    }}
  />
</motion.div>

~ Sam Selikoff, Motion for React Recipes

Propagation

This is already useful for reusing and combining animation targets. But it becomes powerful for orchestrating animations throughout trees.

Variants will flow down through motion components. So in this example when the ul enters the viewport, all of its children with a "visible" variant will also animate in:

const list = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
}

const item = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
}

return (
  <motion.ul
    initial="hidden"
    whileInView="visible"
    variants={list}
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
Orchestration

By default, this children animations will start simultaneously with the parent. But with variants we gain access to new transition props like when, delayChildren, staggerChildren and staggerDirection.

const list = {
  visible: {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      staggerChildren: 0.3, // Stagger children by .3 seconds
    },
  },
  hidden: {
    opacity: 0,
    transition: {
      when: "afterChildren",
    },
  },
}
Dynamic variants

Each variant can be defined as a function that resolves when a variant is made active.

const variants = {
  hidden: { opacity: 0 },
  visible: (index) => ({
    opacity: 1,
    transition: { delay: index * 0.3 }
  })
}

These functions are provided a single argument, which is passed via the custom prop:

items.map((item, index) => <motion.div custom={index} variants={variants} />)

This way, variants can be resolved differently for each animating element.

Animation controls

Declarative animations are ideal for most UI interactions. But sometimes we need to take manual control over animation playback.

The useAnimate hook can be used for:

Animating any HTML/SVG element (not just motion components).




Complex animation sequences.




Controlling animations with time, speed, play(), pause() and other playback controls.

function MyComponent() {
  const [scope, animate] = useAnimate()

  useEffect(() => {
    const controls = animate([
      [scope.current, { x: "100%" }],
      ["li", { opacity: 1 }]
    ])

    controls.speed = 0.8

    return () => controls.stop()
  }, [])

  return (
    <ul ref={scope}>
      <li />
      <li />
      <li />
    </ul>
  )
}
Animate content

By passing a MotionValue as the child of a motion component, it will render its latest value in the HTML.

import { useMotionValue, motion, animate } from "motion/react"

function Counter() {
  const count = useMotionValue(0)

  useEffect(() => {
    const controls = animate(count, 100, { duration: 5 })
    return () => controls.stop()
  }, [])

  return <motion.pre>{count}</motion.pre>
}

This is more performant than setting React state as the motion component will set innerHTML directly.

Quick start

Transitions

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#style

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onupdate

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onanimationstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onanimationcomplete

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#hover

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#whilehover

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onhoverstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onhoverend

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#tap

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#whiletap

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ontapstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ontap

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ontapcancel

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#focus

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#whilefocus

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#pan

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onpan

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onpanstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onpanend

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#drag

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#drag-1

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#whiledrag

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragconstraints

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragsnaptoorigin

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragelastic

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragmomentum

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragtransition

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragdirectionlock

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()

function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}

return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragpropagation

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#dragcontrols

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}


return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)


return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-drag-controls

Docs

Examples

Motion+

Documentation

React

useDragControls

useDragControls

Usually, dragging is initiated by pressing down on a motion component with a drag prop and then moving the pointer.

For some use-cases, for example clicking at an arbitrary point on a video scrubber, we might want to initiate that dragging from a different element.

With useDragControls, we can create a set of controls to manually start dragging from any pointer event.

Usage

Import useDragControls from Motion:

import { useDragControls } from "motion/react"

useDragControls returns drag controls that can be passed to a draggable motion component:

const controls = useDragControls()


return <motion.div drag dragControls={controls} />

Now we can start a drag session from another any element's onPointerDown event via the start method.

<div onPointerDown={event => controls.start(event)} />
Touch support

To support touch screens, the triggering element should have the touch-action: none style applied.

<div onPointerDown={startDrag} style={{ touchAction: "none" }} />
Snap to cursor

By default, the drag gesture will only apply changes to the pointer position.

We can also make the motion component immediately snap to the cursor by passing snapToCursor: true to the start method.

controls.start(event, { snapToCursor: true })
Disable automatic drag

With this configuration, the motion component will still automatically start a drag gesture when it receives a pointerdown event itself.

We can stop this behaviour by passing it a dragListener={false} prop.

<motion.div
  drag
  dragListener={false}
  dragControls={controls}
/>

useAnimationFrame

useInView

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#draglistener

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ondrag

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ondragstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ondragend

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#ondirectionlock

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#viewport

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#whileinview

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#viewport-1

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onviewportenter

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onviewportleave

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layout

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layout-1

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layoutid

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layoutdependency

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layoutscroll

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#layoutroot

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}

return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onlayoutanimationstart

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#onlayoutanimationcomplete

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#advanced

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#inherit

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#custom

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-component#transformtemplate

Docs

Examples

Motion+

Documentation

React

motion

motion

The motion component drives most animations in Motion for React.

There's a motion component for every HTML and SVG element, for instance motion.div, motion.circle etc. Think of it as a normal React component, supercharged for 120fps animation and gestures.

Usage

Import motion from Motion:

// React
import { motion } from "motion/react"

// React Server Components
import * as motion from "motion/react-client"

Now you can use it exactly as you would any normal HTML/SVG component:

<motion.div className="box" />

But you also gain access to powerful animation APIs like the animate, layout, whileInView props and much more.

<motion.div
  className="box"
  // Animate when this value changes:
  animate={{ scale: 2 }}
  // Fade in when the element enters the viewport:
  whileInView={{ opacity: 1 }}
  // Animate the component when its layout changes:
  layout
  // Style now supports indepedent transforms:
  style={{ x: 100 }}
/>

Checkout the Animation guide for a full overview on animations in Motion for React.

Performance

motion components animate values outside the React render cycle for improved performance.

Using motion values instead of React state to update style will also avoid re-renders.

const x = useMotionValue(0)

useEffect(() => {
  // Won't trigger a re-render!
  const timeout = setTimeout(() => x.set(100), 1000)

  return () => clearTimeout(timeout)
}, [])

return <motion.div style={{ x }} />
Server-side rendering

motion components are fully compatible with server-side rendering, meaning the initial state of the component will be reflected in the server-generated output.

// Server will output `translateX(100px)`
<motion.div initial={false} animate={{ x: 100 }} />

This is with the exception of some SVG attributes like transform which require DOM measurements to calculate.

Custom components

Any React component can be supercharged into a motion component by passing it to motion.create() as a function.

const MotionComponent = motion.create(Component)

React 18 users must use forwardRef to wrap their components and pass ref to the element they want to animate:

const Component = React.forwardRef((props, ref) => {
  return <div ref={ref} />
})

React 19 users can pass a normal component, and ref will be passed in via props:

const Component = (props) => {
  return <div ref={props.ref} />
})

Important: Make sure not to call motion.create() within another React render function! This will make a new component every render, breaking your animations.

It's also possible to pass strings to motion.create, which will create custom DOM elements.

// Will render <custom-element /> into HTML
const MotionComponent = motion.create('custom-element')

By default, all motion props (like animate etc) are filtered out of the props forwarded to the provided component. By providing a forwardMotionProps config, the provided component will receive these props.

motion.create(Component, { forwardMotionProps: true })
Props

motion components accept the following props.

Animation
initial

The initial visual state of the motion component.

This can be set as an animation target:

<motion.section initial={{ opacity: 0, x: 0 }} />

Variants:

<motion.li initial="visible" />
<motion.div initial={["visible", "active"]} />

Or set as false to disable the enter animation and initially render as the values found in animate.

<motion.div initial={false} animate={{ opacity: 0 }} />
animate

A target to animate to on enter, and on update.

Can be set as an animation target:

<motion.div
  initial={{ boxShadow: "0px 0px #000" }}
  animate={{ boxShadow: "10px 10px #000" }}
/>

Or variants:

<motion.li animate="visible" />
<motion.div initial="hidden" animate={["visible", "active"]} />
exit

A target to animate to when a component is removed from the tree. Can be set either as an animation target, or variant.

Note: Owing to React limitations, the component being removed must be a direct child of AnimatePresence to enable this animation.

<AnimatePresence>
  {isVisible && (
    <ul key="list">
      <motion.li exit={{ opacity: 0 }} />
    </ul>
  )}
</AnimatePresence>
transition

The default transition for this component to use when an animation prop (animate, whileHover etc) has no transition defined.

<motion.div transition={{ type: "spring" }} animate={{ scale: 1.2 }} />
variants

The variants for this component.

const variants = {
  active: {
      backgroundColor: "#f00"
  },
  inactive: {
    backgroundColor: "#fff",
    transition: { duration: 2 }
  }
}

return (
  <motion.div
    variants={variants}
    animate={isActive ? "active" : "inactive"}
  />
)
style

The normal React DOM style prop, with added support for motion values and independent transforms. 

const x = useMotionValue(30)

return <motion.div style={{ x, rotate: 90, originX: 0.5 }} />
onUpdate

Callback triggered every frame any value on the motion component updates. It's provided a single argument with the latest values.

<motion.article
  animate={{ opacity: 1 }}
  onUpdate={latest => console.log(latest.opacity)}
/>
onAnimationStart

Callback triggered when any animation (except layout animations, see onLayoutAnimationStart) starts.

It's provided a single argument, with the target or variant name of the started animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationStart={latest => console.log(latest.r)}
/>
onAnimationComplete

Callback triggered when any animation (except layout animations, see onLayoutAnimationComplete) completes.

It's provided a single argument, with the target or variant name of the completed animation.

<motion.circle
  animate={{ r: 10 }}
  onAnimationComplete={latest => console.log(latest.r)}
/>
Hover
whileHover

Target or variants to label to while the hover gesture is active.

// As target
<motion.button whileHover={{ scale: 1.2 }} />
// As variants
<motion.div whileHover="hovered" />
onHoverStart

Callback function that fires when a pointer starts hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverStart={(event) => console.log(event)} />
onHoverEnd

Callback function that fires when a pointer stops hovering over the component. Provided the triggering PointerEvent.

<motion.div onHoverEnd={(event) => console.log(event)} />
Tap
whileTap

Target or variants to label to while the tap gesture is active.

// As target
<motion.button whileTap={{ scale: 0.9 }} />
// As variants
<motion.div whileTap="tapped" />
onTapStart

Callback function that fires when a pointer starts pressing the component. Provided the triggering PointerEvent.

<motion.div onTapStart={(event) => console.log(event)} />
onTap

Callback function that fires when a pointer stops pressing the component and the pointer was released inside the component. Provided the triggering PointerEvent.

<motion.div onTap={(event) => console.log(event)} />
onTapCancel

Callback function that fires when a pointer stops pressing the component and the pointer was released outside the component. Provided the triggering PointerEvent.

<motion.div onTapCancel={(event) => console.log(event)} />
Focus
whileFocus

Target or variants to label to while the focus gesture is active.

// As target
<motion.button whileFocus={{ outline: "dashed #000" }} />
// As variants
<motion.div whileFocus="focused" />
Pan
onPan

Callback function that fires when the pan gesture is recognised on this element.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

function onPan(event, info) {
  console.log(info.point.x, info.point.y)
}

<motion.div onPan={onPan} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onPanStart

Callback function that fires when a pan gesture starts. Provided the triggering PointerEvent and info.

<motion.div onPanStart={(event, info) => console.log(info.delta.x)} />
onPanEnd

Callback function that fires when a pan gesture ends. Provided the triggering PointerEvent and info.

<motion.div onPanEnd={(event, info) => console.log(info.delta.x)} />
Drag
drag

Default: false

Enable dragging for this element. Set true to drag in both directions. Set "x" or "y" to only drag in a specific direction.

<motion.div drag />
whileDrag

Target or variants to label to while the drag gesture is active.

// As target
<motion.div drag whileDrag={{ scale: 0.9 }} />
// As variants
<motion.div drag whileDrag="dragging" />
dragConstraints

Applies constraints on the draggable area.

Set as an object of optional top, left, right, and bottom values, measured in pixels:

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or as a ref to another element to use its bounding box as the draggable constraints:

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}
dragSnapToOrigin

Default: false

If true, the draggable element will animate back to its center/origin when released.

<motion.div drag dragSnapToOrigin />
dragElastic

Default: 0.5

The degree of movement allowed outside constraints. 0 = no movement, 1 = full movement.

Set to 0.5 by default. Can also be set as false to disable movement.

By passing an object of top/right/bottom/left, individual values can be set per constraint. Any missing values will be set to 0.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragElastic={0.2}
/>
dragMomentum

Default: true

Apply momentum from the pan gesture to the component when dragging finishes. Set to true by default.

<motion.div
  drag
  dragConstraints={{ left: 0, right: 300 }}
  dragMomentum={false}
/>
dragTransition

Allows you to change dragging momentum transition. When releasing a draggable element, an animation with type "inertia" starts. The animation is based on your dragging velocity. This property allows you to customize it.

<motion.div
  drag
  dragTransition={{ bounceStiffness: 600, bounceDamping: 10 }}
/>
dragDirectionLock

Default: false

Locks drag direction into the soonest detected direction. For example, if the component is moved more on the x axis than y axis before the drag gesture kicks in, it will only drag on the x axis for the remainder of the gesture.

<motion.div drag dragDirectionLock />
dragPropagation

Default: false

Allows drag gesture propagation to child components.

<motion.div drag="x" dragPropagation />
dragControls

Usually, dragging is initiated by pressing down on a component and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we might want to initiate dragging from a different component than the draggable one.

By creating a dragControls using the useDragControls hook, we can pass this into the draggable component's dragControls prop. It exposes a start method that can start dragging from pointer events on other components.

const dragControls = useDragControls()


function startDrag(event) {
  dragControls.start(event, { snapToCursor: true })
}


return (
  <>
    <div onPointerDown={startDrag} />
    <motion.div drag="x" dragControls={dragControls} />
  </>
)

Note: Given that by setting dragControls you are taking control of initiating the drag gesture, it is possible to disable the draggable element as the initiator by setting dragListener={false}.

dragListener

Determines whether to trigger the drag gesture from event listeners. If passing dragControls, setting this to false will ensure dragging can only be initiated by the controls, rather than a pointerdown event on the draggable element.

onDrag

Callback function that fires when the drag gesture is recognised on this element.

function onDrag(event, info) {
  console.log(info.point.x, info.point.y)
}


<motion.div drag onDrag={onDrag} />

Pan and drag events are provided the origin PointerEvent as well as an object info that contains x and y point values for the following:

point: Relative to the device or page.




delta: Distance since the last event.




offset: Distance from the original event.




velocity: Current velocity of the pointer.

onDragStart

Callback function that fires when a drag gesture starts. Provided the triggering PointerEvent and info.

<motion.div drag onDragStart={(event, info) => console.log(info.delta.x)} />
onDragEnd

Callback function that fires when a drag gesture ends. Provided the triggering PointerEvent and info.

<motion.div drag onDragEnd={(event, info) => console.log(info.delta.x)} />
onDirectionLock

Callback function that fires a drag direction is determined.

<motion.div
  drag
  dragDirectionLock
  onDirectionLock={axis => console.log(axis)}
/>
Viewport
whileInView

Target or variants to label to while the element is in view.

// As target
<motion.div whileInView={{ opacity: 1 }} />
// As variants
<motion.div whileInView="visible" />
viewport

Options to define how the element is tracked within the viewport.

<motion.section
  whileInView={{ opacity: 1 }}
  viewport={{ once: true }}
/>

Available options:

once: If true, once element enters the viewport it won't detect subsequent leave/enter events.




root: The ref of an ancestor scrollable element to detect intersections with (instead of window).




margin: A margin to add to the viewport to change the detection area. Defaults to "0px". Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".




amount: The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. Defaults to "some".

onViewportEnter

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportEnter={(entry) => console.log(entry.isIntersecting)} />
onViewportLeave

Callback function that fires when an element enters the viewport. Provided the IntersectionObserverEntry with details of the intersection event.

<motion.div onViewportLeave={(entry) => console.log(entry.intersectionRect)} />
Layout
layout

Default: false

If true, this component will animate changes to its layout.

<motion.div layout />

If set to "position" or "size", only its position or size will animate, respectively.

<motion.img layout="position" />
layoutId

If set, this component will animate changes to its layout. Additionally, when a new element enters the DOM and an element already exists with a matching layoutId, it will animate out from the previous element's size/position.

{items.map(item => (
   <motion.li layout>
      {item.name}
      {item.isSelected && <motion.div layoutId="underline" />}
   </motion.li>
))}

If the previous component remains in the tree, the two elements will crossfade.

layoutDependency

By default, layout changes are detected every render. To reduce measurements and thus improve performance, you can pass a layoutDependency prop. Measurements will only occur when this value changes.

<motion.nav layout layoutDependency={isOpen} />
layoutScroll

For layout animations to work correctly within scrollable elements, their scroll offset needs measuring. For performance reasons, Framer Motion doesn't measure the scroll offset of every ancestor. Add the layoutScroll prop to elements that should be measured.

<motion.div layoutScroll style={{ overflow: "scroll" }}>
  <motion.div layout />
</motion.div>
layoutRoot

For layout animations to work correctly within position: fixed elements, we need to account for page scroll. Add layoutRoot to mark an element as position: fixed.

<motion.div layoutRoot style={{ position: "fixed" }}>
  <motion.div layout />
</motion.div>
onLayoutAnimationStart

A callback to run when a layout animation starts.

onLayoutAnimationComplete

A callback to run when a layout animation completes.

Advanced
inherit

Set to false to prevent a component inheriting or propagating changes in a parent variant.

custom

Custom data to pass through to dynamic variants.

const variants = {
  visible: (custom) => ({
    opacity: 1,
    transition: { delay: custom * 0.2 }
  })
}


return (
  <motion.ul animate="visible">
    <motion.li custom={0} variants={variants} />
    <motion.li custom={1} variants={variants} />
    <motion.li custom={2} variants={variants} />
  </motion.ul>
)
transformTemplate

By default, transforms are applied in order of translate, scale, rotate and skew.

To change this, transformTemplate can be set as a function that accepts the latest transforms and the generated transform string and returns a new transform string.

// Use the latest transform values
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    ({ x, rotate }) => `rotate(${rotate}deg) translateX(${x}px)`
  }
/>
// Or the generated transform string
<motion.div
  style={{ x: 0, rotate: 180 }}
  transformTemplate={
    (latest, generated) => `translate(-50%, -50%) ${generated}`
  }
/>

Layout animations

AnimatePresence

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#setting-a-transition

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>


// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#value-specific-transitions

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>


// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#default-transitions

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>


// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-motion-config#transition

Docs

Examples

Motion+

Documentation

React

MotionConfig

MotionConfig

The MotionConfig component can be used to set configuration options for all child motion components.

import { motion, MotionConfig } from "motion/react"


export const MyComponent = ({ isVisible }) => (
  <MotionConfig transition={{ duration: 1 }}>
    <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
      />
  </MotionConfig>
)
Props
transition

Define a fallback transition to use for all child motion components.

reducedMotion

Default: "never"

reducedMotion lets you set a site-wide policy for handling reduced motion. It offers the following options:

"user": Respect the user's device setting.




"always": Enforce reduced motion (useful for debugging).




"never": Don't respect reduced motion.

When reduced motion is on, transform and layout animations will be disabled. Other animations, like opacity and backgroundColor, will persist.

nonce

If using a Content Security Policy with a nonce attribute, passing the same attribute through MotionConfig will allow any style blocks generated by Motion to adhere the the security policy.

LayoutGroup

Reorder

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#transition-settings

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#type

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#spring-visualiser

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#tween

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#duration

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#ease

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>


// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/easing-functions

Docs

Examples

Motion+

Documentation

JavaScript

Easing

Easing functions

Easing functions are used to change the speed of an animation throughout the course of its duration. Different easing functions provide your animations with different "feelings".

Both the animate function and Motion for React's motion component have the following easing functions built-in and you can just refer to them by name.

// Named easing
ease: "easeIn"


// Bezier curve
ease: [0.39, 0.24, 0.3, 1]

But you can still import them separately to use them directly, either for use with the tiny animate function from "motion/dom" or for novel use-cases.

Usage

All of Motion's easing functions can be imported straight from "motion":

import { easeIn } from "motion"

By passing a 0-1 progress value to these functions, you'll receive an eased progress back.

const eased = easeIn(0.75)
Functions

Motion provides a number of easing functions:

cubicBezier




easeIn/easeOut/easeInOut




backIn/backOut/backInOut




circIn/circOut/circInOut




anticipate




linear




steps

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

cubicBezier

cubicBezier provides very precise control over the easing curve.

import { cubicBezier } from "motion"

const easing = cubicBezier(.35,.17,.3,.86)

const easedProgress = easing(0.5)

New easing curve definitions can be generated on cubic-bezier.com.

steps

steps creates an easing with evenly-spaced, discrete steps. It is spec-compliant with CSS steps easing.

import { steps } from "motion"

const easing = steps(4)

easing(0.2) // 0
easing(0.25) // 0.25

By default, the "steps" change at the end of a step, this can be changed by passing "start" to steps:

const easing = steps(4, "start")

easing(0.2) // 0.25

The distribution of steps is linear by default but can be adjusted by passing progress through another easing function first.

const easing = steps(4)

easing(circInOut(0.2))
Modifiers

Easing modifiers can be used to create mirrored and reversed easing functions.

reverseEasing

reverseEasing accepts an easing function and returns a new one that reverses it. For instance, an ease in function will become an ease out function.

import { reverseEasing } from "motion"

const powerIn = (progress) => progress * progress

const powerOut = reverseEasing(powerIn)
mirrorEasing

mirrorEasing accepts an easing function and returns a new one that mirrors it. For instance, an ease in function will become an ease in-out function.

import { mirrorEasing } from "motion"

const powerIn = (progress) => progress * progress

const powerInOut = mirrorEasing(powerInOut)

press

delay

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

            

---

# https://motion.dev/docs/react-transitions#times

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#spring

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#bounce

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#visualduration

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#damping

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#mass

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#stiffness

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#velocity

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#restspeed

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#restdelta

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#inertia

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#power

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#timeconstant

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#modifytarget

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#min

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#max

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#bouncestiffness

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#bouncedamping

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#orchestration

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#delay

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#repeat

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#repeattype

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#repeatdelay

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#when

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}

const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}

return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#delaychildren

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}


const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}


return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#staggerchildren

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}


const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}


return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}

return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#staggerdirection

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}


const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}


return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-transitions#

Docs

Examples

Motion+

Documentation

React

Transitions

Transitions

A transition defines the type of animation used when animating between two values.

const transition = {
  duration: 0.8,
  delay: 0.5,
  ease: [0, 0.71, 0.2, 1.01],
}
// Motion component
<motion.div
  animate={{ x: 100 }}
  transition={transition}
/>

// animate() function
animate(".box", { x: 100 }, transition)
Setting a transition

transition can be set on any animation prop, and that transition will be used when the animation fires.

<motion.div
  whileHover={{
    scale: 1.1,
    transition: { duration: 0.2 }
  }}
/>
Value-specific transitions

When animating multiple values, each value can be animated with a different transition, with default handling all other values:

// Motion component
<motion.li
  animate={{
    x: 0,
    opacity: 1,
    transition: {
      default: { type: "spring" },
      opacity: { ease: "linear" }
    }
  }}
/>

// animate() function
animate("li", { x: 0, opacity: 1 }, {
  default: { type: "spring" },
  opacity: { ease: "linear" }
})
Default transitions

It's possible to set default transitions via the transition prop. Either for specific motion components:

<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }}
/>

Or for a group of motion components via MotionConfig:

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />
</MotionConfig>
Transition settings
type

Default: Dynamic

type decides the type of animation to use. It can be "tween", "spring" or "inertia".

Tween animations are set with a duration and an easing curve.

Spring animations are either physics-based or duration-based.

Physics-based spring animations are set via stiffness, damping and mass, and these incorporate the velocity of any existing gestures or animations for natural feedback.

Duration-based spring animations are set via a duration and bounce. These don't incorporate velocity but are easier to understand.

Inertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.

<motion.path
  animate={{ pathLength: 1 }}
  transition={{ duration: 2, type: "tween" }}
/>
Spring visualiser
Time
Physics
Duration
Bounce
Use visual duration
Tween
duration

Default: 0.3 (or 0.8 if multiple keyframes are defined)

The duration of the animation. Can also be used for "spring" animations when bounce is also set.

animate("ul > li", { opacity: 1 }, { duration: 1 })
ease

The easing function to use with tween animations. Accepts:

Easing function name. E.g "linear"




An array of four numbers to define a cubic bezier curve. E.g [.17,.67,.83,.67]




A JavaScript easing function, that accepts and returns a value 0-1.

These are the available easing function names:

"linear"




"easeIn", "easeOut", "easeInOut"




"circIn", "circOut", "circInOut"




"backIn", "backOut", "backInOut"




"anticipate"

When animating keyframes, ease can optionally be set as an array of easing functions to set different easings between each value:

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { ease: ["easeIn", "easeOut"] }
  }}
/>

I usually use the "easeOut" curve for enter and exit transitions. The acceleration at the beginning gives the user a feeling of responsiveness. I use a duration no longer than 0.3/0.4 seconds to keep the animation fast.

~ Emil Kowalski, Animations on the Web

times

When animating multiple keyframes, times can be used to adjust the position of each keyframe throughout the animation.

Each value in times is a value between 0 and 1, representing the start and end of the animation.

<motion.div
  animate={{
    x: [0, 100, 0],
    transition: { times: [0, 0.3, 1] }
  }}
/>

There must be the same number of times as there are keyframes. Defaults to an array of evenly-spread durations.

Spring
bounce

Default: 0.25

bounce determines the "bounciness" of a spring animation.

0 is no bounce, and 1 is extremely bouncy.

Note: bounce and duration will be overridden if stiffness, damping or mass are set.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{ type: "spring", bounce: 0.25 }}
/>
visualDuration

If visualDuration is set, this will override duration.

The visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.

In other words, the bulk of the transition will occur before this time, and the "bouncy bit" will mostly happen after.

This makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.

<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5,
    bounce: 0.25
  }}
/>
damping

Default: 10

Strength of opposing force. If set to 0, spring will oscillate indefinitely. 

<motion.a
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', damping: 300 }}
/>
mass

Default: 1

Mass of the moving object. Higher values will result in more lethargic movement. 

<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }}
  transition={{ type: "spring", mass: 0.5 }}
/>
stiffness

Default: 1

Stiffness of the spring. Higher values will create more sudden movement.

<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', stiffness: 50 }}
/>

I never really understood how damping, mass and stiffness influence a spring animation, so I made a tool for myself to visualise it.

~ Emil Kowalski, Animations on the Web

velocity

Default: Current value velocity

The initial velocity of the spring.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', velocity: 2 }}
/>
restSpeed

Default: 0.1

End animation if absolute speed (in units per second) drops below this value and delta is smaller than restDelta.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restSpeed: 0.5 }}
/>
restDelta

Default: 0.01

End animation if distance is below this value and speed is below restSpeed. When animation ends, the spring will end.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ type: 'spring', restDelta: 0.5 }}
/>
Inertia

An animation that decelerates a value based on its initial velocity. Optionally, min and max boundaries can be defined, and inertia will snap to these with a spring animation.

This animation will automatically precalculate a target value, which can be modified with the modifyTarget property.

This allows you to add snap-to-grid or similar functionality.

Inertia is also the animation used for dragTransition, and can be configured via that prop.

power

Default: 0.8

A higher power value equals a further calculated target.

<motion.div
  drag
  dragTransition={{ power: 0.2 }}
/>
timeConstant

Default: 700

Adjusting the time constant will change the duration of the deceleration, thereby affecting its feel.

<motion.div
  drag
  dragTransition={{ timeConstant: 200 }}
/>
modifyTarget

A function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.

<motion.div
  drag
  // dragTransition always type: inertia
  dragTransition={{
    power: 0,
    // Snap calculated target to nearest 50 pixels
    modifyTarget: target => Math.round(target / 50) * 50
  }}
/>
min

Minimum constraint. If set, the value will "bump" against this value (or immediately spring to it if the animation starts as less than this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
max

Maximum constraint. If set, the value will "bump" against this value (or immediately snap to it, if the initial animation value exceeds this value).

<motion.div
  drag
  dragTransition={{ min: 0, max: 100 }}
/>
bounceStiffness

Default: 500

If min or max is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
bounceDamping

Default: 10

If min or max is set, this affects the damping of the bounce spring. If set to 0, spring will oscillate indefinitely. 

<motion.div
  drag
  dragTransition={{
    min: 0,
    max: 100,
    bounceStiffness: 100
  }}
/>
Orchestration
delay

Default: 0

Delay the animation by this duration (in seconds).

animate(element, { filter: "blur(10px)" }, { delay: 0.3 })

By setting delay to a negative value, the animation will start that long into the animation. For instance to start 1 second in, delay can be set to -1.

repeat

Default: 0

The number of times to repeat the transition. Set to Infinity for perpetual animation.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, duration: 2 }}
/>
repeatType

Default: "loop"

How to repeat the animation. This can be either:

loop: Repeats the animation from the start.




reverse: Alternates between forward and backwards playback.




mirror: Switches animation origin and target on each iteration.

<motion.div
  animate={{ rotate: 180 }}
  transition={{
    repeat: 1,
    repeatType: "reverse",
    duration: 2
  }}
/>
repeatDelay

Default: 0

When repeating an animation, repeatDelay will set the duration of the time to wait, in seconds, between each repetition.

<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }}
/>
when

Default: false

With variants, describes when an animation should trigger, relative to that of its children.

"beforeChildren": Children animations will play after the parent animation finishes.




"afterChildren": Parent animations will play after the children animations finish.

const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }
  }
}


const item = {
  hidden: {
    opacity: 0,
    transition: { duration: 2 }
  }
}


return (
  <motion.ul variants={list} animate="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
delayChildren

Default: 0

With variants, setting delayChildren on a parent will delay child animations by this duration (in seconds).

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
)
staggerChildren

Default: 0

With variants, setting staggerChildren on a parent will stagger children by this duration.

For example, if staggerChildren is set to 0.1, the first child will delayed by 0 seconds, the second by 0.1, the third by 0.2 etc.

The calculated delay will be additional to delayChildren.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      staggerChildren: 0.5
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ol
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ol>
)
staggerDirection

Default: 1

The direction in which to stagger children. 1 will stagger from the first to last child, while -1 staggers from last to first.

const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: {
      delayChildren: 0.5,
      staggerDirection: -1
    }
  }
}


const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 }
}


return (
  <motion.ul
    variants={container}
    initial="hidden"
    animate="show"
  >
    <motion.li variants={item} size={50} />
    <motion.li variants={item} size={50} />
  </motion.ul>
)



Animation

Gestures

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#animation-props

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#gestures

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#hover

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#tap

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#accessibility

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#pan

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#drag

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#focus

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#event-propagation

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)

  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#note-svg-filters

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-gestures#motion-examples

Docs

Examples

Motion+

Documentation

React

Gestures

Gestures

Motion extends React's basic set of event listeners with a simple yet powerful set of UI gestures.

The motion component currently has support for hover, tap, pan, drag and inView.

Each gesture has both a set of event listeners and a while- animation prop.

Animation props

motion components provide multiple gesture animation props: whileHover, whileTap, whileFocus, whileDrag and whileInView. These can define animation targets to temporarily animate to while a gesture is active.

<motion.button
  whileHover={{
    scale: 1.2,
    transition: { duration: 1 },
  }}
  whileTap={{ scale: 0.9 }}
/>

All props can be set either as a target of values to animate to, or the name of any variants defined via the variants prop. Variants will flow down through children as normal.

<motion.button
  whileTap="tap"
  whileHover="hover"
  variants={buttonVariants}
>
  <svg>
    <motion.path variants={iconVariants} />
  </svg>
</motion.button>
Gestures
Hover

The hover gesture detects when a pointer hovers over or leaves a component.

It differs from onMouseEnter and onMouseLeave in that hover is guaranteed to only fire as a result of actual mouse events (as opposed to browser-generated mice events emulated from touch input).

<motion.a
  whileHover={{ scale: 1.2 }}
  onHoverStart={event => {}}
  onHoverEnd={event => {}}
/>
Tap

The tap gesture detects when the primary pointer (like a left click or first touch point) presses down and releases on the same component.

<motion.button whileTap={{ scale: 0.9, rotate: 3 }} />

It will fire a tap event when the tap or click ends on the same component it started on, and a tapCancel event if the tap or click ends outside the component.

If the tappable component is a child of a draggable component, it'll automatically cancel the tap gesture if the pointer moves further than 3 pixels during the gesture.

Accessibility

Elements with tap events are keyboard-accessible.

Any element with a tap prop will be able to receive focus and Enter can be used to trigger tap events on focused elements.

Pressing Enter down will trigger onTapStart and whileTap




Releasing Enter will trigger onTap




If the element loses focus before Enter is released, onTapCancel will fire.

Pan

The pan gesture recognises when a pointer presses down on a component and moves further than 3 pixels. The pan gesture is ended when the pointer is released.

<motion.div onPan={(e, pointInfo) => {}} />

Pan doesn't currently have an associated while- prop.

Note: For pan gestures to work correctly with touch input, the element needs touch scrolling to be disabled on either x/y or both axis with the touch-action CSS rule.

Drag

The drag gesture applies pointer movement to the x and/or y axis of the component.

<motion.div drag whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} />

By default, when the drag ends the element will perform an inertia animation with the ending velocity.

This can be disabled by setting dragMomentum to false, or changed via the dragTransition prop.

It's also possible to set dragConstraints, either as an object with top, left, right, and bottom values, measured in pixels.

<motion.div
  drag="x"
  dragConstraints={{ left: 0, right: 300 }}
/>

Or, it can accept a ref to another component created with React's useRef hook. This ref should be passed both to the draggable component's dragConstraints prop, and the ref of the component you want to use as constraints.

const MyComponent = () => {
  const constraintsRef = useRef(null)


  return (
     <motion.div ref={constraintsRef}>
         <motion.div drag dragConstraints={constraintsRef} />
     </motion.div>
  )
}

By default, dragging the element outside the constraints will tug with some elasticity. This can be changed by setting dragElastic to a value between 0 and 1, where 0 equals no motion and 1 equals full motion outside the constraints.

Focus

The focus gesture detects when a component gains or loses focus by the same rules as the CSS :focus-visible selector.

Typically, this is when an input receives focus by any means, and when other elements receive focus by accessible means (like via keyboard navigation).

<motion.a whileFocus={{ scale: 1.2 }} href="#" />
Event propagation

Children can stop pointer events propagating to parent motion components using the Capture React props.

For instance, a child can stop drag and tap gestures and their related while animations from firing on parents by passing e.stopPropagation() to onPointerDownCapture.

<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={e => e.stopPropagation()} />
</motion.div>
Note: SVG filters

Gestures aren't recognised on SVG filter components, as these elements don't have a physical presence and therefore don't receive events.

You can instead add while- props and event handlers to a parent and use variants to animate these elements.

const MyComponent = () => {
  return (
    <motion.svg whileHover="hover">
      <filter id="blur">
        <motion.feGaussianBlur
          stdDeviation={0}
          variants={{ hover: { stdDeviation: 2 } }}
        />
      </filter>
    </motion.svg>
  )
}
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving gestures, including:




Transitions

Scroll animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-velocity

Docs

Examples

Motion+

Documentation

React

useVelocity

useVelocity

useVelocity accepts a motion value and returns a new one that updates with the provided motion value's velocity.

const x = useMotionValue(0)
const xVelocity = useVelocity(x)
const scale = useTransform(
  xVelocity,
  [-3000, 0, 3000],
  [2, 1, 2],
  { clamp: false }
)


return <motion.div drag="x" style={{ x, scale }} />
Usage

Import useVelocity from Motion:

import { useVelocity } from "motion/react"

Pass any numerical motion value to useVelocity. It'll return a new motion value that updates with the velocity of the original value.

import { useMotionValue, useVelocity } from "framer-motion"


function Component() {
  const x = useMotionValue(0)
  const xVelocity = useVelocity(x)


  useMotionValueEvent(xVelocity, "change", latest => {
    console.log("Velocity", latestVelocity)
  })
  
  return <motion.div style={{ x }} />
}

Any numerical motion value will work. Even one returned from useVelocity.

const x = useMotionValue(0)
const xVelocity = useVelocity(x)
const xAcceleration = useVelocity(xVelocity)
Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

useTransform

useAnimate

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#scroll-triggered-animations

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#one-time-animations

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#changing-scroll-container

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#setting-state

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();


return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-in-view

Docs

Examples

Motion+

Documentation

React

useInView

useInView

useInView is a tiny (0.6kb) hook that detects when the provided element is within the viewport. It can be used with any React element.

const ref = useRef(null)
const isInView = useInView(ref)


return <div ref={ref} />
Usage

Import useInView from Motion:

import { useInView } from "motion/react"

useInView can track the visibility of any HTML element. Pass a ref object to both useInView and the HTML element.

function Component() {
  const ref = useRef(null)
  const isInView = useInView(ref)


  return <div ref={ref} />
}

While the element is outside the viewport, useInView will return false. When it moves inside the view, it'll re-render the component and return true.

Effects

useInView is vanilla React state, so firing functions when isInView changes is a matter of passing it to a useEffect.

useEffect(() => {
  console.log("Element is in view: ", isInView)
}, [isInView])
Options

useInView can accept options to define how the element is tracked within the viewport.

const isInView = useInView(ref, { once: true })
root

By default, useInView will track the visibility of an element as it enters/leaves the window viewport. Set root to be the ref of a scrollable parent, and it'll use that element to be the viewport instead.

function Carousel() {
  const container = useRef(null)
  const ref = useRef(null)
  const isInView = useInView({ root: container })
  
  return (
    <div ref={container} style={{ overflow: "scroll" }}>
      <div ref={ref} />
    </div>
  )
}
margin

Default: "0px"

A margin to add to the viewport to change the detection area. Use multiple values to adjust top/right/bottom/left, e.g. "0px -20px 0px 100px".

const isInView = useInView({
  margin: "0px 100px -50px 0px"
})

]Note: For browser security reasons, margin won't take affect within cross-origin iframes unless root is explicitly defined.

once

Default: false

If true, once an element is in view, useInView will stop observing the element and always return true.

const isInView = useInView(ref, { once: true })
initial

Default: false

Set an initial value to return until the element has been measured.

const isInView = useInView(ref, { initial: true })
amount

Default: "some"

The amount of an element that should enter the viewport to be considered "entered". Either "some", "all" or a number between 0 and 1. 

Example

useDragControls

useReducedMotion

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#scroll-linked-animations

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();


return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)

return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-scroll

Docs

Examples

Motion+

Documentation

React

useScroll

useScroll

useScroll is used to create scroll-linked animations, like progress indicators and parallax effects.

const { scrollYProgress } = useScroll()


return <motion.div style={{ scaleX: scrollYProgress }} />
 Usage

Import useScroll from Motion:

import { useScroll } from "motion/react"

useScroll returns four motion values:

scrollX/Y: The absolute scroll position, in pixels.




scrollXProgress/YProgress: The scroll position between the defined offsets, as a value between 0 and 1.

Page scroll

By default, useScroll tracks the page scroll.

const { scrollY } = useScroll()


useMotionValueEvent(scrollY, "change", (latest) => {
  console.log("Page scroll: ", latest)
})

For example, we could show a page scroll indicator by passing scrollYProgress straight to the scaleX style of a progress bar.

const { scrollYProgress } = useScroll()

return <motion.div style={{ scaleX: scrollYProgress }} />

As useScroll returns motion values, we can compose this scroll info with other motion value hooks like useTransform and useSpring:

const { scrollYProgress } = useScroll()
const scaleX = useSpring(scrollYProgress)

return <motion.div style={{ scaleX }} />

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!

~ Sam Selikoff, Motion for React Recipes

Element scroll

To track the scroll position of a scrollable element we can pass the element's ref to useScroll's container option:

const carouselRef = useRef(null)
const { scrollX } = useScroll({
  container: carouselRef
})

return (
  <div ref={carouselRef} style={{ overflow: "scroll" }}>
    {children}
  </div>
)
Element position

We can track the progress of an element as it moves within a container by passing its ref to the target option.

const ref = useRef(null)
const { scrollYProgress } = useScroll({
  target: ref,
  offset: ["start end", "end end"]
})

return <div ref={ref}>

In this example, each item has its own progress indicator.

Scroll offsets

With the offset option we can define which parts of the element we want to track with the viewport, for instance track elements as they enter in from the bottom, leave at the top, or travel throughout the whole viewport.

API

useScroll accepts the following options.

container

Default: Browser window

The scrollable container to track the scroll position of. By default, this is the window viewport. But it can be any scrollable element.

target

By default, this is the scrollable area of the container. It can additionally be set as another element, to track its progress within the viewport.

axis

Default: "y"

The scroll axis to apply offset.

offset

Default: ["start start", "end end"]

offset describes intersections, points where the target and container meet.

For example, the intersection "start end" means when the start of the target on the tracked axis meets the end of the container.

So if the target is an element, the container is the window, and we're tracking the vertical axis then "start end" is where the top of the element meets the bottom of the viewport.

Accepted intersections

Both target and container points can be defined as:

Number: A value where 0 represents the start of the axis and 1 represents the end. So to define the top of the target with the middle of the container you could define "0 0.5". Values outside this range are permitted.




Names: "start", "center" and "end" can be used as clear shortcuts for 0, 0.5 and 1 respectively.




Pixels: Pixel values like "100px", "-50px" will be defined as that number of pixels from the start of the target/container.




Percent: Same as raw numbers but expressed as "0%" to "100%".




Viewport: "vh" and "vw" units are accepted.

Examples
React Three Fiber
Scroll velocity

useMotionTemplate

useSpring

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#value-smoothing

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")


useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})


return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-spring

Docs

Examples

Motion+

Documentation

React

useSpring

useSpring

useSpring creates a motion value that will animate to its latest target with a spring animation.

The target can either be set manually via .set, or automatically by passing in another motion value.

Usage

Import useSpring from Motion:

import { useSpring } from "motion/react"
Direct control

useSpring can be created with a number, or a unit-type (px, % etc) string:

const x = useSpring(0)
const y = useSpring("100vh")

Now, whenever this motion value is updated via set(), the value will animate to its new target with the defined spring.

x.set(100)
y.set("50vh")

It's also possible to update this value immediately, without a spring, with the jump() method.

x.jump(50)
y.jump("0vh")
Track another motion value

Its also possible to automatically spring towards the latest value of another motion value:

const x = useMotionValue(0)
const y = useSpring(x)

This source motion value must also be a number, or unit-type string.

Transition

The type of spring can be defined with the usual spring transition option.

useSpring(0, { stiffness: 300 })
Premium examples

useScroll

useTime

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#transform-other-values

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})


return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-use-transform

Docs

Examples

Motion+

Documentation

React

useTransform

useTransform

useTransform creates a new motion value that transforms the output of one or more motion values.

const x = useMotionValue(1)
const y = useMotionValue(1)


const z = useTransform(() => x.get() + y.get()) // z.get() === 2
Usage

Import from Motion:

import { useTransform } from "motion/react"

useTransform can be used in two ways: with a transform function and via value maps:

// Transform function
useTransform(() => x.get() * 2)


// Value mapping
useTransform(x, [0, 100], ["#f00", "00f"])
Transform function

A transform function is a normal function that returns a value.

useTransform(() => x.get() * 2)

Any motion values read in this function via the get() method will be automatically subscribed to.

When these motion values change, the function will be run again on the next animation frame to calculate a new value.

const distance = 100
const time = useTime()
const y = useTransform(() => Math.sin(time.get() / 1000) * distance)
Value mapping

useTransform can also map a single motion value from one range of values to another.

To illustrate, look at this x motion value:

const x = useMotionValue(0)

We can use useTransform to create a new motion value called opacity.

const opacity = useTransform(x, input, output)

By defining an input range and an output range, we can define relationships like "when x is 0, opacity should be 1. When x is 100 pixels either side, opacity should be 0".

const input = [-100, 0, 100]
const output = [0, 1, 0]

Both ranges can be any length but must be the same length as each other.

The input range must always be a series of increasing or decreasing numbers.

The output range must be values all of the same type, but can be in any order. It can also be any value type that Motion can animate, like numbers, units, colors and other strings.

const backgroundColor = useTransform(
  x,
  [0, 100],
  ["#f00", "#00f"]
)

By setting clamp: false, the ranges will map perpetually. For instance, in this example we're saying "for every 100px scrolled, rotate another 360deg":

const { scrollY } = useScroll()
const rotate = useTransform(
  scrollY,
  [0, 100],
  [0, 360],
  { clamp: false }
)
Options

With value mapping, we can set some additional options.

clamp

Default: true

If true, will clamp output to within the provided range. If false, will carry on mapping even when the input falls outside the provided range.

const y = useTransform(x, [0, 1], [0, 2])
const z = useTransform(x, [0, 1], [0, 2], { clamp: false })

useEffect(() => {
  x.set(2)
  console.log(y.get()) // 2, input clamped
  console.log(z.get()) // 4
})
ease

An easing function, or array of easing functions, to ease the mixing between each value.

These must be JavaScript functions.

import { cubicBezier, circOut } from "motion"
import { useTransform } from "motion/react"

// In your component
const y = useTransform(x, [0, 1], [0, 2], { ease: circOut })

const z = useTransform(
  x,
  [0, 1],
  [0, 2],
  { ease: cubicBezier(0.17, 0.67, 0.83, 0.67) }
)
mixer

A function to use to mix between each pair of output values.

This function will be called with each pair of output values and must return a new function, that accepts a progress value between 0 and 1 and returns the mixed value.

This can be used to inject more advanced mixers than Framer Motion's default, for instance Flubber for morphing SVG paths.

Motion+ examples

Motion+ is a one-time payment, lifetime membership that gains you access to the source code of an ever-growing library of premium examples, as well as premium components like Cursor and AnimateNumber.

It features a number of examples involving useTransform, including:




useTime

useVelocity

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#examples

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#track-element-scroll-offset

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#track-element-within-viewport

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---

# https://motion.dev/docs/react-scroll-animations#parallax

Docs

Examples

Motion+

Documentation

React

Scroll

Scroll animations

There are two types of scroll animations:

Scroll-triggered: A normal animation is triggered when an element enters the viewport.




Scroll-linked: Values are linked directly to scroll progress.

Motion is capable of both types of animation.

Scroll-triggered animations

Scroll-triggered animations are just normal animations that fire when an element enters or leaves the viewport.

Motion offers the whileInView prop to set an animation target or variant when the element enters the view.

<motion.div
  initial={{ opacity: 0 }}
  whileInView={{ opacity: 1 }}
/>
One-time animations

With the viewport options, it's possible to set once: true so once an element has entered the viewport, it won't animate back out.

<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }}
/>
Changing scroll container

By default, the element will be considered within the viewport when it enters/leaves the window. This can be changed by providing the ref of another scrollable element.

function Component() {
  const scrollRef = useRef(null)
  
  return (
    <div ref={scrollRef} style={{ overflow: "scroll" }}>
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }}
      />
    </div>
  )
}

For more configuration options, checkout the motion component API reference.

Setting state

It's also possible to set state when any element (not just a motion component) enters and leaves the viewport with the useInView hook.

Scroll-linked animations

Scroll-linked animations are created using motion values and the useScroll hook.

useScroll returns four motion values, two that store scroll offset in pixels (scrollX and scrollY) and two that store scroll progress as a value between 0 and 1.

These motion values can be passed directly to specific styles. For instance, passing scrollYProgress to scaleX works great as a progress bar.

const { scrollYProgress } = useScroll();

return (
  <motion.div style={{ scaleX: scrollYProgress }} />  
)

Since scrollY is a MotionValue, there's a neat trick you can use to tell when the user's scroll direction changes:

const { scrollY } = useScroll()
const [scrollDirection, setScrollDirection] = useState("down")

useMotionValueEvent(scrollY, "change", (current) => {
  const diff = current - scrollY.getPrevious()
  setScrollDirection(diff > 0 ? "down" : "up")
})

Perfect for triggering a sticky header animation!
~ Sam Selikoff, Motion for React Recipes

Value smoothing

This value can be smoothed by passing it through useSpring.

const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress, {
  stiffness: 100,
  damping: 30,
  restDelta: 0.001
})

return <motion.div style={{ scaleX }} />
Transform other values

With the useTransform hook, it's easy to use the progress motion values to mix between any value, like colors:

const backgroundColor = useTransform(
  scrollYProgress,
  [0, 0.5, 1],
  ["#f00", "#0f0", "#00f"]
)


return <motion.div style={{ backgroundColor }} />
Examples
Track element scroll offset
Track element within viewport
Parallax
3D
Scroll velocity and direction

Read the full useScroll docs to discover more about creating the above effects.

Gestures

Layout animations

A Motion+ membership will give you early access to features & content, access to our private Github and Discord, and more.

It's a one-time fee that grants lifetime access. No subscription necessary!

Learn more

Sign up for newsletter

Site

About

Blog

Docs

Examples

Motion+

Sponsor

Social

Discord

GitHub

X/Twitter

Bluesky

With thanks to our amazing sponsors

Emil Kowalski

©2025 Motion Division Ltd

             

---
